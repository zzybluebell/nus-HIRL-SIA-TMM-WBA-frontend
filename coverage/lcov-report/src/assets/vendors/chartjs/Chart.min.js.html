
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for src/assets/vendors/chartjs/Chart.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">src/assets/vendors/chartjs</a> Chart.min.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/4803</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/4310</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1313</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/2</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >"object"==typeof exports&amp;&amp;"undefined"!=typeof module?module.exports=e():"function"==typeof define&amp;&amp;define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).Chart=e()}</span>(this,(<span class="fstat-no" title="function not covered" >fu</span>nction(){"use strict";function <span class="fstat-no" title="function not covered" >t(</span>){}const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t++}</span>}</span>();</span>function <span class="fstat-no" title="function not covered" >i(</span>t){<span class="cstat-no" title="statement not covered" >return null==t}</span>function <span class="fstat-no" title="function not covered" >s(</span>t){<span class="cstat-no" title="statement not covered" >if(Array.isArray&amp;&amp;Array.isArray(t))<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >Object.prototype.toString.call(t);<span class="cstat-no" title="statement not covered" ></span>return"[object"===e.slice(0,7)&amp;&amp;"Array]"===e.slice(-6)}</span>function <span class="fstat-no" title="function not covered" >n(</span>t){<span class="cstat-no" title="statement not covered" >return null!==t&amp;&amp;"[object Object]"===Object.prototype.toString.call(t)}</span>const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >("number"==typeof t||t instanceof Number)&amp;&amp;isFinite(+t);</span></span>function <span class="fstat-no" title="function not covered" >a(</span>t,e){<span class="cstat-no" title="statement not covered" >return o(t)?t:e}</span>function <span class="fstat-no" title="function not covered" >r(</span>t,e){<span class="cstat-no" title="statement not covered" >return void 0===t?e:t}</span>const l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof t&amp;&amp;t.endsWith("%")?parseFloat(t)/100:t/e,</span></span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof t&amp;&amp;t.endsWith("%")?parseFloat(t)/100*e:+t;</span></span>function <span class="fstat-no" title="function not covered" >c(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;"function"==typeof t.call)<span class="cstat-no" title="statement not covered" >return t.apply(i,e)}</span></span>function <span class="fstat-no" title="function not covered" >d(</span>t,e,i,o){let a,r,l;<span class="cstat-no" title="statement not covered" >if(s(t))<span class="cstat-no" title="statement not covered" >if(r=t.length,o)<span class="cstat-no" title="statement not covered" >for(a=r-1;a&gt;=0;a--)<span class="cstat-no" title="statement not covered" >e.call(i,t[a],a);e</span></span>lse <span class="cstat-no" title="statement not covered" >for(a=0;a&lt;r;a++)<span class="cstat-no" title="statement not covered" >e.call(i,t[a],a);e</span></span></span>lse <span class="cstat-no" title="statement not covered" >if(n(t))<span class="cstat-no" title="statement not covered" >for(l=Object.keys(t),r=l.length,a=0;a&lt;r;a++)<span class="cstat-no" title="statement not covered" >e.call(i,t[l[a]],l[a])}</span></span></span></span>function <span class="fstat-no" title="function not covered" >u(</span>t,e){let i,s,n,o;<span class="cstat-no" title="statement not covered" >if(!t||!e||t.length!==e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=0,s=t.length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >if(n=t[i],o=e[i],n.datasetIndex!==o.datasetIndex||n.index!==o.index)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >f(</span>t){<span class="cstat-no" title="statement not covered" >if(s(t))<span class="cstat-no" title="statement not covered" >return t.map(f);<span class="cstat-no" title="statement not covered" >i</span></span>f(n(t)){const e=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(t),</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >e[i[n]]=f(t[i[n]]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >g(</span>t){<span class="cstat-no" title="statement not covered" >return-1===["__proto__","prototype","constructor"].indexOf(t)}</span>function <span class="fstat-no" title="function not covered" >p(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >if(!g(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >e[t],</span>a=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>n(o)&amp;&amp;n(a)?m(o,a,s):e[t]=f(a)}</span>function <span class="fstat-no" title="function not covered" >m(</span>t,e,i){const o=<span class="cstat-no" title="statement not covered" >s(e)?e:[e],</span>a=<span class="cstat-no" title="statement not covered" >o.length;<span class="cstat-no" title="statement not covered" ></span>if(!n(t))<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >(i=i||{}).merger||p;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;a;++s){<span class="cstat-no" title="statement not covered" >if(!n(e=o[s]))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >Object.keys(e);<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >a.length;</span>s&lt;n;++s)<span class="cstat-no" title="statement not covered" >r(a[s],t,e,i)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >b(</span>t,e){<span class="cstat-no" title="statement not covered" >return m(t,e,{merger:x})}</span>function <span class="fstat-no" title="function not covered" >x(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(!g(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >e[t],</span>o=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>n(s)&amp;&amp;n(o)?b(s,o):Object.prototype.hasOwnProperty.call(e,t)||(e[t]=f(o))}</span>const _=<span class="cstat-no" title="statement not covered" >{"":<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>x:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.x,</span>y:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.y}</span>;</span>function <span class="fstat-no" title="function not covered" >y(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >_[e]||(_[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >v(t);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const i of e){<span class="cstat-no" title="statement not covered" >if(""===i)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>=t&amp;&amp;t[i]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>}</span>(e));<span class="cstat-no" title="statement not covered" ></span>return i(t)}</span>function <span class="fstat-no" title="function not covered" >v(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.split("."),</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(const t of e)<span class="cstat-no" title="statement not covered" >s+=t,s.endsWith("\\")?s=s.slice(0,-1)+".":(i.push(s),s="");<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >w(</span>t){<span class="cstat-no" title="statement not covered" >return t.charAt(0).toUpperCase()+t.slice(1)}</span>const M=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >void 0!==t,</span></span>k=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"function"==typeof t,</span></span>S=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(t.size!==e.size)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(const i of t)<span class="cstat-no" title="statement not covered" >if(!e.has(i))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>;</span>function <span class="fstat-no" title="function not covered" >P(</span>t){<span class="cstat-no" title="statement not covered" >return"mouseup"===t.type||"click"===t.type||"contextmenu"===t.type}</span>const D=<span class="cstat-no" title="statement not covered" >Math.PI,</span>O=<span class="cstat-no" title="statement not covered" >2*D,</span>C=<span class="cstat-no" title="statement not covered" >O+D,</span>A=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY,</span>T=<span class="cstat-no" title="statement not covered" >D/180,</span>L=<span class="cstat-no" title="statement not covered" >D/2,</span>E=<span class="cstat-no" title="statement not covered" >D/4,</span>R=<span class="cstat-no" title="statement not covered" >2*D/3,</span>I=<span class="cstat-no" title="statement not covered" >Math.log10,</span>z=<span class="cstat-no" title="statement not covered" >Math.sign;</span>function <span class="fstat-no" title="function not covered" >F(</span>t){const e=<span class="cstat-no" title="statement not covered" >Math.round(t);<span class="cstat-no" title="statement not covered" ></span>t=N(t,e,t/1e3)?e:t;c</span>onst i=<span class="cstat-no" title="statement not covered" >Math.pow(10,Math.floor(I(t))),</span>s=<span class="cstat-no" title="statement not covered" >t/i;<span class="cstat-no" title="statement not covered" ></span>return(s&lt;=1?1:s&lt;=2?2:s&lt;=5?5:10)*i}</span>function <span class="fstat-no" title="function not covered" >V(</span>t){const e=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >Math.sqrt(t);</span>let s;<span class="cstat-no" title="statement not covered" >for(s=1;s&lt;i;s++)<span class="cstat-no" title="statement not covered" >t%s==0&amp;&amp;(e.push(s),e.push(t/s));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i===(0|i)&amp;&amp;e.push(i),e.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e)</span>).pop(),e}</span>function <span class="fstat-no" title="function not covered" >B(</span>t){<span class="cstat-no" title="statement not covered" >return!isNaN(parseFloat(t))&amp;&amp;isFinite(t)}</span>function <span class="fstat-no" title="function not covered" >N(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Math.abs(t-e)&lt;i}</span>function <span class="fstat-no" title="function not covered" >W(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >Math.round(t);<span class="cstat-no" title="statement not covered" ></span>return i-e&lt;=t&amp;&amp;i+e&gt;=t}</span>function <span class="fstat-no" title="function not covered" >j(</span>t,e,i){let s,n,o;<span class="cstat-no" title="statement not covered" >for(s=0,n=t.length;s&lt;n;s++)<span class="cstat-no" title="statement not covered" >o=t[s][i],isNaN(o)||(e.min=Math.min(e.min,o),e.max=Math.max(e.max,o))}</span></span>function <span class="fstat-no" title="function not covered" >H(</span>t){<span class="cstat-no" title="statement not covered" >return t*(D/180)}</span>function <span class="fstat-no" title="function not covered" >$(</span>t){<span class="cstat-no" title="statement not covered" >return t*(180/D)}</span>function <span class="fstat-no" title="function not covered" >Y(</span>t){<span class="cstat-no" title="statement not covered" >if(!o(t))<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >1,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;Math.round(t*e)/e!==t;)<span class="cstat-no" title="statement not covered" >e*=10,i++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >U(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e.x-t.x,</span>s=<span class="cstat-no" title="statement not covered" >e.y-t.y,</span>n=<span class="cstat-no" title="statement not covered" >Math.sqrt(i*i+s*s);</span>let o=<span class="cstat-no" title="statement not covered" >Math.atan2(s,i);<span class="cstat-no" title="statement not covered" ></span>return o&lt;-.5*D&amp;&amp;(o+=O),{angle:o,distance:n}}</span>function <span class="fstat-no" title="function not covered" >X(</span>t,e){<span class="cstat-no" title="statement not covered" >return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}</span>function <span class="fstat-no" title="function not covered" >q(</span>t,e){<span class="cstat-no" title="statement not covered" >return(t-e+C)%O-D}</span>function <span class="fstat-no" title="function not covered" >K(</span>t){<span class="cstat-no" title="statement not covered" >return(t%O+O)%O}</span>function <span class="fstat-no" title="function not covered" >G(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >K(t),</span>o=<span class="cstat-no" title="statement not covered" >K(e),</span>a=<span class="cstat-no" title="statement not covered" >K(i),</span>r=<span class="cstat-no" title="statement not covered" >K(o-n),</span>l=<span class="cstat-no" title="statement not covered" >K(a-n),</span>h=<span class="cstat-no" title="statement not covered" >K(n-o),</span>c=<span class="cstat-no" title="statement not covered" >K(n-a);<span class="cstat-no" title="statement not covered" ></span>return n===o||n===a||s&amp;&amp;o===a||r&gt;l&amp;&amp;h&lt;c}</span>function <span class="fstat-no" title="function not covered" >Z(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Math.max(e,Math.min(i,t))}</span>function <span class="fstat-no" title="function not covered" >J(</span>t){<span class="cstat-no" title="statement not covered" >return Z(t,-32768,32767)}</span>function <span class="fstat-no" title="function not covered" >Q(</span>t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >1e-6)</span>{<span class="cstat-no" title="statement not covered" >return t&gt;=Math.min(e,i)-s&amp;&amp;t&lt;=Math.max(e,i)+s}</span>function <span class="fstat-no" title="function not covered" >tt(</span>t,e,i){<span class="cstat-no" title="statement not covered" >i=i||(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i]&lt;e)</span>;l</span>et s,n=<span class="cstat-no" title="statement not covered" >t.length-1,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n-o&gt;1;)<span class="cstat-no" title="statement not covered" >s=o+n&gt;&gt;1,i(s)?o=s:n=s;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{lo:o,hi:n}}</span>const et=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >tt(t,i,s?<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t[s][e]&lt;=i:<span class="fstat-no" title="function not covered" ></span>s=</span>&gt;<span class="cstat-no" title="statement not covered" >t[s][e]&lt;i)</span>,</span></span>it=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >tt(t,i,(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t[s][e]&gt;=i)</span>);</span></span>function <span class="fstat-no" title="function not covered" >st(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(;s&lt;n&amp;&amp;t[s]&lt;e;)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >f</span></span>or(;n&gt;s&amp;&amp;t[n-1]&gt;i;)<span class="cstat-no" title="statement not covered" >n--;<span class="cstat-no" title="statement not covered" >r</span></span>eturn s&gt;0||n&lt;t.length?t.slice(s,n):t}</span>const nt=<span class="cstat-no" title="statement not covered" >["push","pop","shift","splice","unshift"];</span>function <span class="fstat-no" title="function not covered" >ot(</span>t,e){<span class="cstat-no" title="statement not covered" >t._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),nt.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >"_onData"+w(e),</span>s=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(t,e,{configurable:!0,enumerable:!1,<span class="fstat-no" title="function not covered" >va</span>lue(...e){const n=<span class="cstat-no" title="statement not covered" >s.apply(this,e);<span class="cstat-no" title="statement not covered" ></span>return t._chartjs.listeners.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >"function"==typeof t[i]&amp;&amp;t[i](...e)}</span>)),n}</span>})}</span>)))}</span>function <span class="fstat-no" title="function not covered" >at(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t._chartjs;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i.listeners,</span>n=<span class="cstat-no" title="statement not covered" >s.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>-1!==n&amp;&amp;s.splice(n,1),s.length&gt;0||(nt.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >delete t[e]}</span>)),delete t._chartjs)}</span>function <span class="fstat-no" title="function not covered" >rt(</span>t){const e=<span class="cstat-no" title="statement not covered" >new Set;</span>let i,s;<span class="cstat-no" title="statement not covered" >for(i=0,s=t.length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >e.add(t[i]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.size===s?t:Array.from(e)}</span>const lt=<span class="cstat-no" title="statement not covered" >"undefined"==typeof window?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t()}</span>:window.requestAnimationFrame;</span>function <span class="fstat-no" title="function not covered" >ht(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >i||(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Array.prototype.slice.call(t))</span>;</span>let n=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(...i){<span class="cstat-no" title="statement not covered" >o=s(i),n||(n=!0,lt.call(window,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n=!1,t.apply(e,o)}</span>)))}</span>}</span>function <span class="fstat-no" title="function not covered" >ct(</span>t,e){let i;<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(...s){<span class="cstat-no" title="statement not covered" >return e?(clearTimeout(i),i=setTimeout(t,e,s)):t.apply(this,s),e}</span>}</span>const dt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"start"===t?"left":"end"===t?"right":"center",</span></span>ut=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >"start"===t?e:"end"===t?i:(e+i)/2,</span></span>ft=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >t===(s?"left":"right")?i:"center"===t?(e+i)/2:e;</span></span>function <span class="fstat-no" title="function not covered" >gt(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.length;</span>let n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(t._sorted){const{iScale:a,_parsed:r}=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >a.axis,</span>{min:h,max:c,minDefined:d,maxDefined:u}=<span class="cstat-no" title="statement not covered" >a.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;(n=Z(Math.min(et(r,a.axis,h).lo,i?s:et(e,l,a.getPixelForValue(h)).lo),0,s-1)),o=u?Z(Math.max(et(r,a.axis,c,!0).hi+1,i?0:et(e,l,a.getPixelForValue(c),!0).hi+1),n,s)-n:s-n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{start:n,count:o}}</span>function <span class="fstat-no" title="function not covered" >pt(</span>t){const{xScale:e,yScale:i,_scaleRanges:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >{xmin:e.min,xmax:e.max,ymin:i.min,ymax:i.max};<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return t._scaleRanges=n,!0;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >s.xmin!==e.min||s.xmax!==e.max||s.ymin!==i.min||s.ymax!==i.max;<span class="cstat-no" title="statement not covered" ></span>return Object.assign(s,n),o}</span>var mt=<span class="cstat-no" title="statement not covered" >new class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.listeners[s],</span>o=<span class="cstat-no" title="statement not covered" >e.duration;<span class="cstat-no" title="statement not covered" ></span>n.forEach((<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)}))</span>)}<span class="fstat-no" title="function not covered" ></span>_r</span>efresh(){<span class="cstat-no" title="statement not covered" >this._request||(this._running=!0,this._request=lt.call(window,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._update(),this._request=null,this._running&amp;&amp;this._refresh()}</span>)))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdate(t=<span class="branch-0 cbranch-no" title="branch not covered" >Date.now())</span>{let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this._charts.forEach((<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >if(!i.running||!i.items.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >i.items;</span>let o,a=<span class="cstat-no" title="statement not covered" >n.length-1,</span>r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(;a&gt;=0;--a)<span class="cstat-no" title="statement not covered" >o=n[a],o._active?(o._total&gt;i.duration&amp;&amp;(i.duration=o._total),o.tick(t),r=!0):(n[a]=n[n.length-1],n.pop());<span class="cstat-no" title="statement not covered" >r</span></span>&amp;&amp;(s.draw(),this._notify(s,i,t,"progress")),n.length||(i.running=!1,this._notify(s,i,t,"complete"),i.initial=!1),e+=n.length}</span>)),this._lastDate=t,0===e&amp;&amp;(this._running=!1)}<span class="fstat-no" title="function not covered" ></span>_g</span>etAnims(t){const e=<span class="cstat-no" title="statement not covered" >this._charts;</span>let i=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}<span class="fstat-no" title="function not covered" ></span>li</span>sten(t,e,i){<span class="cstat-no" title="statement not covered" >this._getAnims(t).listeners[e].push(i)}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t,e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.length&amp;&amp;this._getAnims(t).items.push(...e)}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){<span class="cstat-no" title="statement not covered" >return this._getAnims(t).items.length&gt;0}<span class="fstat-no" title="function not covered" ></span>st</span>art(t){const e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(t,e._duration))</span>,0),this._refresh())}<span class="fstat-no" title="function not covered" ></span>ru</span>nning(t){<span class="cstat-no" title="statement not covered" >if(!this._running)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>return!!(e&amp;&amp;e.running&amp;&amp;e.items.length)}<span class="fstat-no" title="function not covered" ></span>st</span>op(t){const e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>if(!e||!e.items.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e.items;</span>let s=<span class="cstat-no" title="statement not covered" >i.length-1;<span class="cstat-no" title="statement not covered" ></span>for(;s&gt;=0;--s)<span class="cstat-no" title="statement not covered" >i[s].cancel();<span class="cstat-no" title="statement not covered" >e</span></span>.items=[],this._notify(t,e,Date.now(),"complete")}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >return this._charts.delete(t)}</span>};</span></span>
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */function <span class="fstat-no" title="function not covered" >bt(</span>t){<span class="cstat-no" title="statement not covered" >return t+.5|0}</span>const xt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(Math.min(t,i),e);</span></span>function <span class="fstat-no" title="function not covered" >_t(</span>t){<span class="cstat-no" title="statement not covered" >return xt(bt(2.55*t),0,255)}</span>function <span class="fstat-no" title="function not covered" >yt(</span>t){<span class="cstat-no" title="statement not covered" >return xt(bt(255*t),0,255)}</span>function <span class="fstat-no" title="function not covered" >vt(</span>t){<span class="cstat-no" title="statement not covered" >return xt(bt(t/2.55)/100,0,1)}</span>function <span class="fstat-no" title="function not covered" >wt(</span>t){<span class="cstat-no" title="statement not covered" >return xt(bt(100*t),0,100)}</span>const Mt=<span class="cstat-no" title="statement not covered" >{0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},</span>kt=<span class="cstat-no" title="statement not covered" >[..."0123456789ABCDEF"],</span>St=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >kt[15&amp;t],</span></span>Pt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >kt[(240&amp;t)&gt;&gt;4]+kt[15&amp;t],</span></span>Dt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(240&amp;t)&gt;&gt;4==(15&amp;t);</span></span>function <span class="fstat-no" title="function not covered" >Ot(</span>t){var e=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Dt(t.r)&amp;&amp;Dt(t.g)&amp;&amp;Dt(t.b)&amp;&amp;Dt(t.a))</span>(t)?St:Pt;<span class="cstat-no" title="statement not covered" ></span>return t?"#"+e(t.r)+e(t.g)+e(t.b)+(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t&lt;255?e(t):"")</span>(t.a,e):void 0}</span>const Ct=<span class="cstat-no" title="statement not covered" >/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;</span>function <span class="fstat-no" title="function not covered" >At(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >e*Math.min(i,1-i),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n=<span class="branch-0 cbranch-no" title="branch not covered" >(e+t/30)%12)</span>=&gt;<span class="cstat-no" title="statement not covered" >i-s*Math.max(Math.min(n-3,9-n,1),-1);<span class="cstat-no" title="statement not covered" ></span></span>return[n(0),n(8),n(4)]}</span>function <span class="fstat-no" title="function not covered" >Tt(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>,n=<span class="branch-0 cbranch-no" title="branch not covered" >(s+t/60)%6)</span>=&gt;<span class="cstat-no" title="statement not covered" >i-i*e*Math.max(Math.min(n,4-n,1),0);<span class="cstat-no" title="statement not covered" ></span></span>return[s(5),s(3),s(1)]}</span>function <span class="fstat-no" title="function not covered" >Lt(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >At(t,1,.5);</span>let n;<span class="cstat-no" title="statement not covered" >for(e+i&gt;1&amp;&amp;(n=1/(e+i),e*=n,i*=n),n=0;n&lt;3;n++)<span class="cstat-no" title="statement not covered" >s[n]*=1-e-i,s[n]+=e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>function <span class="fstat-no" title="function not covered" >Et(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.r/255,</span>i=<span class="cstat-no" title="statement not covered" >t.g/255,</span>s=<span class="cstat-no" title="statement not covered" >t.b/255,</span>n=<span class="cstat-no" title="statement not covered" >Math.max(e,i,s),</span>o=<span class="cstat-no" title="statement not covered" >Math.min(e,i,s),</span>a=<span class="cstat-no" title="statement not covered" >(n+o)/2;</span>let r,l,h;<span class="cstat-no" title="statement not covered" >return n!==o&amp;&amp;(h=n-o,l=a&gt;.5?h/(2-n-o):h/(n+o),r=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){<span class="cstat-no" title="statement not covered" >return t===n?(e-i)/s+(e&lt;i?6:0):e===n?(i-t)/s+2:(t-e)/s+4}</span>(e,i,s,h,n),r=60*r+.5),[0|r,l||0,a]}</span>function <span class="fstat-no" title="function not covered" >Rt(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return(Array.isArray(e)?t(e[0],e[1],e[2]):t(e,i,s)).map(yt)}</span>function <span class="fstat-no" title="function not covered" >It(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Rt(At,t,e,i)}</span>function <span class="fstat-no" title="function not covered" >zt(</span>t){<span class="cstat-no" title="statement not covered" >return(t%360+360)%360}</span>function <span class="fstat-no" title="function not covered" >Ft(</span>t){const e=<span class="cstat-no" title="statement not covered" >Ct.exec(t);</span>let i,s=<span class="cstat-no" title="statement not covered" >255;<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>[5]!==i&amp;&amp;(s=e[6]?_t(+e[5]):yt(+e[5]));c</span>onst n=<span class="cstat-no" title="statement not covered" >zt(+e[2]),</span>o=<span class="cstat-no" title="statement not covered" >+e[3]/100,</span>a=<span class="cstat-no" title="statement not covered" >+e[4]/100;<span class="cstat-no" title="statement not covered" ></span>return i="hwb"===e[1]?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return Rt(Lt,t,e,i)}</span>(n,o,a):"hsv"===e[1]?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return Rt(Tt,t,e,i)}</span>(n,o,a):It(n,o,a),{r:i[0],g:i[1],b:i[2],a:s}}</span>const Vt=<span class="cstat-no" title="statement not covered" >{x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},</span>Bt=<span class="cstat-no" title="statement not covered" >{OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};</span>let Nt;function <span class="fstat-no" title="function not covered" >Wt(</span>t){<span class="cstat-no" title="statement not covered" >Nt||(Nt=<span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >{},</span>e=<span class="cstat-no" title="statement not covered" >Object.keys(Bt),</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(Vt);</span>let s,n,o,a,r;<span class="cstat-no" title="statement not covered" >for(s=0;s&lt;e.length;s++){<span class="cstat-no" title="statement not covered" >for(a=r=e[s],n=0;n&lt;i.length;n++)<span class="cstat-no" title="statement not covered" >o=i[n],r=r.replace(o,Vt[o]);<span class="cstat-no" title="statement not covered" >o</span></span>=parseInt(Bt[a],16),t[r]=[o&gt;&gt;16&amp;255,o&gt;&gt;8&amp;255,255&amp;o]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>(),Nt.transparent=[0,0,0,0]);c</span>onst e=<span class="cstat-no" title="statement not covered" >Nt[t.toLowerCase()];<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}</span>const jt=<span class="cstat-no" title="statement not covered" >/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;</span>const Ht=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&lt;=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,</span></span>$t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&lt;=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);</span></span>function <span class="fstat-no" title="function not covered" >Yt(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(t){let s=<span class="cstat-no" title="statement not covered" >Et(t);<span class="cstat-no" title="statement not covered" ></span>s[e]=Math.max(0,Math.min(s[e]+s[e]*i,0===e?360:1)),s=It(s),t.r=s[0],t.g=s[1],t.b=s[2]}</span>}</span>function <span class="fstat-no" title="function not covered" >Ut(</span>t,e){<span class="cstat-no" title="statement not covered" >return t?Object.assign(e||{},t):t}</span>function <span class="fstat-no" title="function not covered" >Xt(</span>t){var e=<span class="cstat-no" title="statement not covered" >{r:0,g:0,b:0,a:255};<span class="cstat-no" title="statement not covered" ></span>return Array.isArray(t)?t.length&gt;=3&amp;&amp;(e={r:t[0],g:t[1],b:t[2],a:255},t.length&gt;3&amp;&amp;(e.a=yt(t[3]))):(e=Ut(t,{r:0,g:0,b:0,a:1})).a=yt(e.a),e}</span>function <span class="fstat-no" title="function not covered" >qt(</span>t){<span class="cstat-no" title="statement not covered" >return"r"===t.charAt(0)?<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >jt.exec(t);</span>let i,s,n,o=<span class="cstat-no" title="statement not covered" >255;<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >if(e[7]!==i){const t=<span class="cstat-no" title="statement not covered" >+e[7];<span class="cstat-no" title="statement not covered" ></span>o=e[8]?_t(t):xt(255*t,0,255)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i=+e[1],s=+e[3],n=+e[5],i=255&amp;(e[2]?_t(i):xt(i,0,255)),s=255&amp;(e[4]?_t(s):xt(s,0,255)),n=255&amp;(e[6]?_t(n):xt(n,0,255)),{r:i,g:s,b:n,a:o}}</span>}</span>(t):Ft(t)}</span>class Kt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >if(t instanceof Kt)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >typeof t;</span>let i;var s,n,o;<span class="cstat-no" title="statement not covered" >"object"===e?i=Xt(t):"string"===e&amp;&amp;(o=(s=t).length,"#"===s[0]&amp;&amp;(4===o||5===o?n={r:255&amp;17*Mt[s[1]],g:255&amp;17*Mt[s[2]],b:255&amp;17*Mt[s[3]],a:5===o?17*Mt[s[4]]:255}:7!==o&amp;&amp;9!==o||(n={r:Mt[s[1]]&lt;&lt;4|Mt[s[2]],g:Mt[s[3]]&lt;&lt;4|Mt[s[4]],b:Mt[s[5]]&lt;&lt;4|Mt[s[6]],a:9===o?Mt[s[7]]&lt;&lt;4|Mt[s[8]]:255})),i=n||Wt(t)||qt(t)),this._rgb=i,this._valid=!!i}<span class="fstat-no" title="function not covered" ></span>ge</span>t valid(){<span class="cstat-no" title="statement not covered" >return this._valid}<span class="fstat-no" title="function not covered" ></span>ge</span>t rgb(){var t=<span class="cstat-no" title="statement not covered" >Ut(this._rgb);<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(t.a=vt(t.a)),t}<span class="fstat-no" title="function not covered" ></span>se</span>t rgb(t){<span class="cstat-no" title="statement not covered" >this._rgb=Xt(t)}<span class="fstat-no" title="function not covered" ></span>rg</span>bString(){<span class="cstat-no" title="statement not covered" >return this._valid?(t=this._rgb)&amp;&amp;(t.a&lt;255?`rgba(${t.r}, ${t.g}, ${t.b}, ${vt(t.a)})`:`rgb(${t.r}, ${t.g}, ${t.b})`):void 0;v</span>ar t}<span class="fstat-no" title="function not covered" >he</span>xString(){<span class="cstat-no" title="statement not covered" >return this._valid?Ot(this._rgb):void 0}<span class="fstat-no" title="function not covered" ></span>hs</span>lString(){<span class="cstat-no" title="statement not covered" >return this._valid?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >Et(t),</span>i=<span class="cstat-no" title="statement not covered" >e[0],</span>s=<span class="cstat-no" title="statement not covered" >wt(e[1]),</span>n=<span class="cstat-no" title="statement not covered" >wt(e[2]);<span class="cstat-no" title="statement not covered" ></span>return t.a&lt;255?`hsla(${i}, ${s}%, ${n}%, ${vt(t.a)})`:`hsl(${i}, ${s}%, ${n}%)`}</span>(this._rgb):void 0}<span class="fstat-no" title="function not covered" ></span>mi</span>x(t,e){<span class="cstat-no" title="statement not covered" >if(t){const i=<span class="cstat-no" title="statement not covered" >this.rgb,</span>s=<span class="cstat-no" title="statement not covered" >t.rgb;</span>let n;const o=<span class="cstat-no" title="statement not covered" >e===n?.5:e,</span>a=<span class="cstat-no" title="statement not covered" >2*o-1,</span>r=<span class="cstat-no" title="statement not covered" >i.a-s.a,</span>l=<span class="cstat-no" title="statement not covered" >((a*r==-1?a:(a+r)/(1+a*r))+1)/2;<span class="cstat-no" title="statement not covered" ></span>n=1-l,i.r=255&amp;l*i.r+n*s.r+.5,i.g=255&amp;l*i.g+n*s.g+.5,i.b=255&amp;l*i.b+n*s.b+.5,i.a=o*i.a+(1-o)*s.a,this.rgb=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t,e){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;(this._rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >$t(vt(t.r)),</span>n=<span class="cstat-no" title="statement not covered" >$t(vt(t.g)),</span>o=<span class="cstat-no" title="statement not covered" >$t(vt(t.b));<span class="cstat-no" title="statement not covered" ></span>return{r:yt(Ht(s+i*($t(vt(e.r))-s))),g:yt(Ht(n+i*($t(vt(e.g))-n))),b:yt(Ht(o+i*($t(vt(e.b))-o))),a:t.a+i*(e.a-t.a)}}</span>(this._rgb,t._rgb,e)),this}<span class="fstat-no" title="function not covered" ></span>cl</span>one(){<span class="cstat-no" title="statement not covered" >return new Kt(this.rgb)}<span class="fstat-no" title="function not covered" ></span>al</span>pha(t){<span class="cstat-no" title="statement not covered" >return this._rgb.a=yt(t),this}<span class="fstat-no" title="function not covered" ></span>cl</span>earer(t){<span class="cstat-no" title="statement not covered" >return this._rgb.a*=1-t,this}<span class="fstat-no" title="function not covered" ></span>gr</span>eyscale(){const t=<span class="cstat-no" title="statement not covered" >this._rgb,</span>e=<span class="cstat-no" title="statement not covered" >bt(.3*t.r+.59*t.g+.11*t.b);<span class="cstat-no" title="statement not covered" ></span>return t.r=t.g=t.b=e,this}<span class="fstat-no" title="function not covered" ></span>op</span>aquer(t){<span class="cstat-no" title="statement not covered" >return this._rgb.a*=1+t,this}<span class="fstat-no" title="function not covered" ></span>ne</span>gate(){const t=<span class="cstat-no" title="statement not covered" >this._rgb;<span class="cstat-no" title="statement not covered" ></span>return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}<span class="fstat-no" title="function not covered" ></span>li</span>ghten(t){<span class="cstat-no" title="statement not covered" >return Yt(this._rgb,2,t),this}<span class="fstat-no" title="function not covered" ></span>da</span>rken(t){<span class="cstat-no" title="statement not covered" >return Yt(this._rgb,2,-t),this}<span class="fstat-no" title="function not covered" ></span>sa</span>turate(t){<span class="cstat-no" title="statement not covered" >return Yt(this._rgb,1,t),this}<span class="fstat-no" title="function not covered" ></span>de</span>saturate(t){<span class="cstat-no" title="statement not covered" >return Yt(this._rgb,1,-t),this}<span class="fstat-no" title="function not covered" ></span>ro</span>tate(t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >Et(t);<span class="cstat-no" title="statement not covered" ></span>i[0]=zt(i[0]+e),i=It(i),t.r=i[0],t.g=i[1],t.b=i[2]}</span>(this._rgb,t),this}</span>}function <span class="fstat-no" title="function not covered" >Gt(</span>t){<span class="cstat-no" title="statement not covered" >return new Kt(t)}</span>function <span class="fstat-no" title="function not covered" >Zt(</span>t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;"object"==typeof t){const e=<span class="cstat-no" title="statement not covered" >t.toString();<span class="cstat-no" title="statement not covered" ></span>return"[object CanvasPattern]"===e||"[object CanvasGradient]"===e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Jt(</span>t){<span class="cstat-no" title="statement not covered" >return Zt(t)?t:Gt(t)}</span>function <span class="fstat-no" title="function not covered" >Qt(</span>t){<span class="cstat-no" title="statement not covered" >return Zt(t)?t:Gt(t).saturate(.5).darken(.1).hexString()}</span>const te=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>ee=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>function <span class="fstat-no" title="function not covered" >ie(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e.split(".");<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>e&lt;s;++e){const s=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>t=t[s]||(t[s]=Object.create(null))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >se(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return"string"==typeof e?m(ie(t,e),i):m(ie(t,""),e)}</span>var ne=<span class="cstat-no" title="statement not covered" >new class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.platform.getDevicePixelRatio(),</span>this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Qt(e.backgroundColor),</span>this.hoverBorderColor=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Qt(e.borderColor),</span>this.hoverColor=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Qt(e.color),</span>this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t)}<span class="fstat-no" title="function not covered" ></span>se</span>t(t,e){<span class="cstat-no" title="statement not covered" >return se(this,t,e)}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return ie(this,t)}<span class="fstat-no" title="function not covered" ></span>de</span>scribe(t,e){<span class="cstat-no" title="statement not covered" >return se(ee,t,e)}<span class="fstat-no" title="function not covered" ></span>ov</span>erride(t,e){<span class="cstat-no" title="statement not covered" >return se(te,t,e)}<span class="fstat-no" title="function not covered" ></span>ro</span>ute(t,e,i,s){const o=<span class="cstat-no" title="statement not covered" >ie(this,t),</span>a=<span class="cstat-no" title="statement not covered" >ie(this,i),</span>l=<span class="cstat-no" title="statement not covered" >"_"+e;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperties(o,{[l]:{value:o[e],writable:!0},[e]:{enumerable:!0,<span class="fstat-no" title="function not covered" >ge</span>t(){const t=<span class="cstat-no" title="statement not covered" >this[l],</span>e=<span class="cstat-no" title="statement not covered" >a[s];<span class="cstat-no" title="statement not covered" ></span>return n(t)?Object.assign({},e,t):r(t,e)}</span>,<span class="fstat-no" title="function not covered" >se</span>t(t){<span class="cstat-no" title="statement not covered" >this[l]=t}</span>}})}</span>}({_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("on"),</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"events"!==t,</span>hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}});</span>function <span class="fstat-no" title="function not covered" >oe(</span>){<span class="cstat-no" title="statement not covered" >return"undefined"!=typeof window&amp;&amp;"undefined"!=typeof document}</span>function <span class="fstat-no" title="function not covered" >ae(</span>t){let e=<span class="cstat-no" title="statement not covered" >t.parentNode;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;"[object ShadowRoot]"===e.toString()&amp;&amp;(e=e.host),e}</span>function <span class="fstat-no" title="function not covered" >re(</span>t,e,i){let s;<span class="cstat-no" title="statement not covered" >return"string"==typeof t?(s=parseInt(t,10),-1!==t.indexOf("%")&amp;&amp;(s=s/100*e.parentNode[i])):s=t,s}</span>const le=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >window.getComputedStyle(t,null);</span></span>function <span class="fstat-no" title="function not covered" >he(</span>t,e){<span class="cstat-no" title="statement not covered" >return le(t).getPropertyValue(e)}</span>const ce=<span class="cstat-no" title="statement not covered" >["top","right","bottom","left"];</span>function <span class="fstat-no" title="function not covered" >de(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>i=i?"-"+i:"";<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;4;n++){const o=<span class="cstat-no" title="statement not covered" >ce[n];<span class="cstat-no" title="statement not covered" ></span>s[o]=parseFloat(t[e+"-"+o+i])||0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.width=s.left+s.right,s.height=s.top+s.bottom,s}</span>function <span class="fstat-no" title="function not covered" >ue(</span>t,e){<span class="cstat-no" title="statement not covered" >if("native"in t)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst{canvas:i,currentDevicePixelRatio:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >le(i),</span>o=<span class="cstat-no" title="statement not covered" >"border-box"===n.boxSizing,</span>a=<span class="cstat-no" title="statement not covered" >de(n,"padding"),</span>r=<span class="cstat-no" title="statement not covered" >de(n,"border","width"),</span>{x:l,y:h,box:c}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.touches,</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.length?i[0]:t,</span>{offsetX:n,offsetY:o}=<span class="cstat-no" title="statement not covered" >s;</span>let a,r,l=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if((<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >(t&gt;0||e&gt;0)&amp;&amp;(!i||!i.shadowRoot))</span>(n,o,t.target))<span class="cstat-no" title="statement not covered" >a=n,r=o;e</span>lse{const t=<span class="cstat-no" title="statement not covered" >e.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>a=s.clientX-t.left,r=s.clientY-t.top,l=!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:a,y:r,box:l}}</span>(t,i),</span>d=<span class="cstat-no" title="statement not covered" >a.left+(c&amp;&amp;r.left),</span>u=<span class="cstat-no" title="statement not covered" >a.top+(c&amp;&amp;r.top);</span>let{width:f,height:g}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return o&amp;&amp;(f-=a.width+r.width,g-=a.height+r.height),{x:Math.round((l-d)/f*i.width/s),y:Math.round((h-u)/g*i.height/s)}}</span>const fe=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.round(10*t)/10;</span></span>function <span class="fstat-no" title="function not covered" >ge(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >le(t),</span>o=<span class="cstat-no" title="statement not covered" >de(n,"margin"),</span>a=<span class="cstat-no" title="statement not covered" >re(n.maxWidth,t,"clientWidth")||A,</span>r=<span class="cstat-no" title="statement not covered" >re(n.maxHeight,t,"clientHeight")||A,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s,n;<span class="cstat-no" title="statement not covered" >if(void 0===e||void 0===i){const o=<span class="cstat-no" title="statement not covered" >ae(t);<span class="cstat-no" title="statement not covered" ></span>if(o){const t=<span class="cstat-no" title="statement not covered" >o.getBoundingClientRect(),</span>a=<span class="cstat-no" title="statement not covered" >le(o),</span>r=<span class="cstat-no" title="statement not covered" >de(a,"border","width"),</span>l=<span class="cstat-no" title="statement not covered" >de(a,"padding");<span class="cstat-no" title="statement not covered" ></span>e=t.width-l.width-r.width,i=t.height-l.height-r.height,s=re(a.maxWidth,o,"clientWidth"),n=re(a.maxHeight,o,"clientHeight")}</span>else <span class="cstat-no" title="statement not covered" >e=t.clientWidth,i=t.clientHeight}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{width:e,height:i,maxWidth:s||A,maxHeight:n||A}}</span>(t,e,i);</span>let{width:h,height:c}=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" ></span>if("content-box"===n.boxSizing){const t=<span class="cstat-no" title="statement not covered" >de(n,"border","width"),</span>e=<span class="cstat-no" title="statement not covered" >de(n,"padding");<span class="cstat-no" title="statement not covered" ></span>h-=e.width+t.width,c-=e.height+t.height}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn h=Math.max(0,h-o.width),c=Math.max(0,s?Math.floor(h/s):c-o.height),h=fe(Math.min(h,a,l.maxWidth)),c=fe(Math.min(c,r,l.maxHeight)),h&amp;&amp;!c&amp;&amp;(c=fe(h/2)),{width:h,height:c}}</span>function <span class="fstat-no" title="function not covered" >pe(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >e||1,</span>n=<span class="cstat-no" title="statement not covered" >Math.floor(t.height*s),</span>o=<span class="cstat-no" title="statement not covered" >Math.floor(t.width*s);<span class="cstat-no" title="statement not covered" ></span>t.height=n/s,t.width=o/s;c</span>onst a=<span class="cstat-no" title="statement not covered" >t.canvas;<span class="cstat-no" title="statement not covered" ></span>return a.style&amp;&amp;(i||!a.style.height&amp;&amp;!a.style.width)&amp;&amp;(a.style.height=`${t.height}px`,a.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==s||a.height!==n||a.width!==o)&amp;&amp;(t.currentDevicePixelRatio=s,a.height=n,a.width=o,t.ctx.setTransform(s,0,0,s,0,0),!0)}</span>const me=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>try{const e=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >ge</span>t passive(){<span class="cstat-no" title="statement not covered" >return t=!0,!1}</span>};<span class="cstat-no" title="statement not covered" ></span>window.addEventListener("test",null,e),window.removeEventListener("test",null,e)}</span>catch(t){}<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>();</span>function <span class="fstat-no" title="function not covered" >be(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >he(t,e),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.match(/^(\d+)(\.\d+)?px$/);<span class="cstat-no" title="statement not covered" ></span>return s?+s[1]:void 0}</span>function <span class="fstat-no" title="function not covered" >xe(</span>t){<span class="cstat-no" title="statement not covered" >return!t||i(t.size)||i(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}</span>function <span class="fstat-no" title="function not covered" >_e(</span>t,e,i,s,n){let o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>return o||(o=e[n]=t.measureText(n).width,i.push(n)),o&gt;s&amp;&amp;(s=o),s}</span>function <span class="fstat-no" title="function not covered" >ye(</span>t,e,i,n){let o=<span class="cstat-no" title="statement not covered" >(n=n||{}).data=n.data||{},</span>a=<span class="cstat-no" title="statement not covered" >n.garbageCollect=n.garbageCollect||[];<span class="cstat-no" title="statement not covered" ></span>n.font!==e&amp;&amp;(o=n.data={},a=n.garbageCollect=[],n.font=e),t.save(),t.font=e;l</span>et r=<span class="cstat-no" title="statement not covered" >0;</span>const l=<span class="cstat-no" title="statement not covered" >i.length;</span>let h,c,d,u,f;<span class="cstat-no" title="statement not covered" >for(h=0;h&lt;l;h++)<span class="cstat-no" title="statement not covered" >if(u=i[h],null!=u&amp;&amp;!0!==s(u))<span class="cstat-no" title="statement not covered" >r=_e(t,o,a,r,u);e</span>lse <span class="cstat-no" title="statement not covered" >if(s(u))<span class="cstat-no" title="statement not covered" >for(c=0,d=u.length;c&lt;d;c++)<span class="cstat-no" title="statement not covered" >f=u[c],null==f||s(f)||(r=_e(t,o,a,r,f));<span class="cstat-no" title="statement not covered" >t</span></span></span></span></span>.restore();c</span>onst g=<span class="cstat-no" title="statement not covered" >a.length/2;<span class="cstat-no" title="statement not covered" ></span>if(g&gt;i.length){<span class="cstat-no" title="statement not covered" >for(h=0;h&lt;g;h++)<span class="cstat-no" title="statement not covered" >delete o[a[h]];<span class="cstat-no" title="statement not covered" >a</span></span>.splice(0,g)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >ve(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.currentDevicePixelRatio,</span>n=<span class="cstat-no" title="statement not covered" >0!==i?Math.max(i/2,.5):0;<span class="cstat-no" title="statement not covered" ></span>return Math.round((e-n)*s)/s+n}</span>function <span class="fstat-no" title="function not covered" >we(</span>t,e){<span class="cstat-no" title="statement not covered" >(e=e||t.getContext("2d")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore()}</span>function <span class="fstat-no" title="function not covered" >Me(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >ke(t,e,i,s,null)}</span>function <span class="fstat-no" title="function not covered" >ke(</span>t,e,i,s,n){let o,a,r,l,h,c;const d=<span class="cstat-no" title="statement not covered" >e.pointStyle,</span>u=<span class="cstat-no" title="statement not covered" >e.rotation,</span>f=<span class="cstat-no" title="statement not covered" >e.radius;</span>let g=<span class="cstat-no" title="statement not covered" >(u||0)*T;<span class="cstat-no" title="statement not covered" ></span>if(d&amp;&amp;"object"==typeof d&amp;&amp;(o=d.toString(),"[object HTMLImageElement]"===o||"[object HTMLCanvasElement]"===o))<span class="cstat-no" title="statement not covered" >return t.save(),t.translate(i,s),t.rotate(g),t.drawImage(d,-d.width/2,-d.height/2,d.width,d.height),void t.restore();<span class="cstat-no" title="statement not covered" >i</span></span>f(!(isNaN(f)||f&lt;=0)){<span class="cstat-no" title="statement not covered" >switch(t.beginPath(),d){default:<span class="cstat-no" title="statement not covered" >n?t.ellipse(i,s,n/2,f,0,0,O):t.arc(i,s,f,0,O),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"triangle":<span class="cstat-no" title="statement not covered" >t.moveTo(i+Math.sin(g)*f,s-Math.cos(g)*f),g+=R,t.lineTo(i+Math.sin(g)*f,s-Math.cos(g)*f),g+=R,t.lineTo(i+Math.sin(g)*f,s-Math.cos(g)*f),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rectRounded":<span class="cstat-no" title="statement not covered" >h=.516*f,l=f-h,a=Math.cos(g+E)*l,r=Math.sin(g+E)*l,t.arc(i-a,s-r,h,g-D,g-L),t.arc(i+r,s-a,h,g-L,g),t.arc(i+a,s+r,h,g,g+L),t.arc(i-r,s+a,h,g+L,g+D),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rect":<span class="cstat-no" title="statement not covered" >if(!u){<span class="cstat-no" title="statement not covered" >l=Math.SQRT1_2*f,c=n?n/2:l,t.rect(i-c,s-l,2*c,2*l);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>g</span>+=E;c</span>ase"rectRot":<span class="cstat-no" title="statement not covered" >a=Math.cos(g)*f,r=Math.sin(g)*f,t.moveTo(i-a,s-r),t.lineTo(i+r,s-a),t.lineTo(i+a,s+r),t.lineTo(i-r,s+a),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"crossRot":<span class="cstat-no" title="statement not covered" >g+=E;c</span>ase"cross":<span class="cstat-no" title="statement not covered" >a=Math.cos(g)*f,r=Math.sin(g)*f,t.moveTo(i-a,s-r),t.lineTo(i+a,s+r),t.moveTo(i+r,s-a),t.lineTo(i-r,s+a);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"star":<span class="cstat-no" title="statement not covered" >a=Math.cos(g)*f,r=Math.sin(g)*f,t.moveTo(i-a,s-r),t.lineTo(i+a,s+r),t.moveTo(i+r,s-a),t.lineTo(i-r,s+a),g+=E,a=Math.cos(g)*f,r=Math.sin(g)*f,t.moveTo(i-a,s-r),t.lineTo(i+a,s+r),t.moveTo(i+r,s-a),t.lineTo(i-r,s+a);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"line":<span class="cstat-no" title="statement not covered" >a=n?n/2:Math.cos(g)*f,r=Math.sin(g)*f,t.moveTo(i-a,s-r),t.lineTo(i+a,s+r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"dash":<span class="cstat-no" title="statement not covered" >t.moveTo(i,s),t.lineTo(i+Math.cos(g)*f,s+Math.sin(g)*f)}<span class="cstat-no" title="statement not covered" ></span>t</span>.fill(),e.borderWidth&gt;0&amp;&amp;t.stroke()}</span>}</span>function <span class="fstat-no" title="function not covered" >Se(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return i=i||.5,!e||t&amp;&amp;t.x&gt;e.left-i&amp;&amp;t.x&lt;e.right+i&amp;&amp;t.y&gt;e.top-i&amp;&amp;t.y&lt;e.bottom+i}</span>function <span class="fstat-no" title="function not covered" >Pe(</span>t,e){<span class="cstat-no" title="statement not covered" >t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()}</span>function <span class="fstat-no" title="function not covered" >De(</span>t){<span class="cstat-no" title="statement not covered" >t.restore()}</span>function <span class="fstat-no" title="function not covered" >Oe(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t.lineTo(i.x,i.y);<span class="cstat-no" title="statement not covered" >i</span></span>f("middle"===n){const s=<span class="cstat-no" title="statement not covered" >(e.x+i.x)/2;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(s,e.y),t.lineTo(s,i.y)}</span>else<span class="cstat-no" title="statement not covered" >"after"===n!=!!s?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y);<span class="cstat-no" title="statement not covered" >t</span></span>.lineTo(i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >Ce(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t.lineTo(i.x,i.y);<span class="cstat-no" title="statement not covered" >t</span></span>.bezierCurveTo(s?e.cp1x:e.cp2x,s?e.cp1y:e.cp2y,s?i.cp2x:i.cp1x,s?i.cp2y:i.cp1y,i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >Ae(</span>t,e,n,o,a,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const l=<span class="cstat-no" title="statement not covered" >s(e)?e:[e],</span>h=<span class="cstat-no" title="statement not covered" >r.strokeWidth&gt;0&amp;&amp;""!==r.strokeColor;</span>let c,d;<span class="cstat-no" title="statement not covered" >for(t.save(),t.font=a.string,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e.translation&amp;&amp;t.translate(e.translation[0],e.translation[1]);<span class="cstat-no" title="statement not covered" >i</span>(e.rotation)||t.rotate(e.rotation);<span class="cstat-no" title="statement not covered" >e</span>.color&amp;&amp;(t.fillStyle=e.color);<span class="cstat-no" title="statement not covered" >e</span>.textAlign&amp;&amp;(t.textAlign=e.textAlign);<span class="cstat-no" title="statement not covered" >e</span>.textBaseline&amp;&amp;(t.textBaseline=e.textBaseline)}</span>(t,r),c=0;c&lt;l.length;++c)<span class="cstat-no" title="statement not covered" >d=l[c],h&amp;&amp;(r.strokeColor&amp;&amp;(t.strokeStyle=r.strokeColor),i(r.strokeWidth)||(t.lineWidth=r.strokeWidth),t.strokeText(d,n,o,r.maxWidth)),t.fillText(d,n,o,r.maxWidth),Te(t,n,o,d,r),o+=a.lineHeight;<span class="cstat-no" title="statement not covered" >t</span></span>.restore()}</span>function <span class="fstat-no" title="function not covered" >Te(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >if(n.strikethrough||n.underline){const o=<span class="cstat-no" title="statement not covered" >t.measureText(s),</span>a=<span class="cstat-no" title="statement not covered" >e-o.actualBoundingBoxLeft,</span>r=<span class="cstat-no" title="statement not covered" >e+o.actualBoundingBoxRight,</span>l=<span class="cstat-no" title="statement not covered" >i-o.actualBoundingBoxAscent,</span>h=<span class="cstat-no" title="statement not covered" >i+o.actualBoundingBoxDescent,</span>c=<span class="cstat-no" title="statement not covered" >n.strikethrough?(l+h)/2:h;<span class="cstat-no" title="statement not covered" ></span>t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=n.decorationWidth||2,t.moveTo(a,c),t.lineTo(r,c),t.stroke()}</span>}</span>function <span class="fstat-no" title="function not covered" >Le(</span>t,e){const{x:i,y:s,w:n,h:o,radius:a}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>t.arc(i+a.topLeft,s+a.topLeft,a.topLeft,-L,D,!0),t.lineTo(i,s+o-a.bottomLeft),t.arc(i+a.bottomLeft,s+o-a.bottomLeft,a.bottomLeft,D,L,!0),t.lineTo(i+n-a.bottomRight,s+o),t.arc(i+n-a.bottomRight,s+o-a.bottomRight,a.bottomRight,L,0,!0),t.lineTo(i+n,s+a.topRight),t.arc(i+n-a.topRight,s+a.topRight,a.topRight,0,-L,!0),t.lineTo(i+a.topLeft,s)}</span>function <span class="fstat-no" title="function not covered" >Ee(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >[""],</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >t,</span>s,n=(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t[0])</span></span>){<span class="cstat-no" title="statement not covered" >M(s)||(s=$e("_fallback",t));c</span>onst o=<span class="cstat-no" title="statement not covered" >{[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:t,_rootScopes:i,_fallback:s,_getTarget:n,override:<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Ee([n,...t],e,i,s)}</span>;<span class="cstat-no" title="statement not covered" ></span>return new Proxy(o,{deleteProperty:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;(<span class="cstat-no" title="statement not covered" >delete e[i],delete e._keys,delete t[0][i],!0)</span>,get:<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >Ve(i,s,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n;<span class="cstat-no" title="statement not covered" >for(const o of e)<span class="cstat-no" title="statement not covered" >if(n=$e(ze(o,t),i),M(n))<span class="cstat-no" title="statement not covered" >return Fe(t,n)?je(i,s,t,n):n}</span></span></span>(s,e,t,i))</span>),</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Reflect.getOwnPropertyDescriptor(t._scopes[0],e),</span>getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Reflect.getPrototypeOf(t[0]),</span>has:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Ye(t).includes(e),</span>ownKeys:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ye(t),<span class="fstat-no" title="function not covered" ></span>se</span>t(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t._storage||(t._storage=n());<span class="cstat-no" title="statement not covered" ></span>return t[e]=s[e]=i,delete t._keys,!0}</span>})}</span>function <span class="fstat-no" title="function not covered" >Re(</span>t,e,i,o){const a=<span class="cstat-no" title="statement not covered" >{_cacheable:!1,_proxy:t,_context:e,_subProxy:i,_stack:new Set,_descriptors:Ie(t,o),setContext:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Re(t,e,i,o),</span>override:<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >Re(t.override(s),e,i,o)}</span>;<span class="cstat-no" title="statement not covered" ></span>return new Proxy(a,{deleteProperty:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;(<span class="cstat-no" title="statement not covered" >delete e[i],delete t[i],!0)</span>,get:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >Ve(t,e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{_proxy:o,_context:a,_subProxy:r,_descriptors:l}=<span class="cstat-no" title="statement not covered" >t;</span>let h=<span class="cstat-no" title="statement not covered" >o[e];<span class="cstat-no" title="statement not covered" ></span>k(h)&amp;&amp;l.isScriptable(e)&amp;&amp;(h=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{_proxy:n,_context:o,_subProxy:a,_stack:r}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(r.has(t))<span class="cstat-no" title="statement not covered" >throw new Error("Recursion detected: "+Array.from(r).join("-&gt;")+"-&gt;"+t);<span class="cstat-no" title="statement not covered" >r</span></span>.add(t),e=e(o,a||s),r.delete(t),Fe(t,e)&amp;&amp;(e=je(n._scopes,n,t,e));<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>(e,h,t,i));<span class="cstat-no" title="statement not covered" >s</span>(h)&amp;&amp;h.length&amp;&amp;(h=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{_proxy:o,_context:a,_subProxy:r,_descriptors:l}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(M(a.index)&amp;&amp;s(t))<span class="cstat-no" title="statement not covered" >e=e[a.index%e.length];e</span>lse <span class="cstat-no" title="statement not covered" >if(n(e[0])){const i=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >o._scopes.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t!==i)</span>);<span class="cstat-no" title="statement not covered" ></span>e=[];<span class="cstat-no" title="statement not covered" >f</span>or(const n of i){const i=<span class="cstat-no" title="statement not covered" >je(s,o,t,n);<span class="cstat-no" title="statement not covered" ></span>e.push(Re(i,a,r&amp;&amp;r[t],l))}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>(e,h,t,l.isIndexable));<span class="cstat-no" title="statement not covered" >F</span>e(e,h)&amp;&amp;(h=Re(h,a,r&amp;&amp;r[e],l));<span class="cstat-no" title="statement not covered" >r</span>eturn h}</span>(t,e,i))</span>),</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >e._descriptors.allKeys?Reflect.has(t,i)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,i),</span>getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Reflect.getPrototypeOf(t),</span>has:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >Reflect.has(t,i),</span>ownKeys:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Reflect.ownKeys(t),</span>set:<span class="fstat-no" title="function not covered" >(e</span>,i,s)=&gt;(<span class="cstat-no" title="statement not covered" >t[i]=s,delete e[i],!0)</span>})}</span>function <span class="fstat-no" title="function not covered" >Ie(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{scriptable:!0,indexable:!0})</span>{const{_scriptable:i=<span class="branch-0 cbranch-no" title="branch not covered" >e.scriptable,</span>_indexable:s=<span class="branch-0 cbranch-no" title="branch not covered" >e.indexable,</span>_allKeys:n=<span class="branch-0 cbranch-no" title="branch not covered" >e.allKeys}</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return{allKeys:n,scriptable:i,indexable:s,isScriptable:k(i)?i:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i,</span>isIndexable:k(s)?s:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s}</span>}</span>const ze=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t?t+w(e):e,</span></span>Fe=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >n(e)&amp;&amp;"adapters"!==t&amp;&amp;(null===Object.getPrototypeOf(e)||e.constructor===Object);</span></span>function <span class="fstat-no" title="function not covered" >Ve(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(Object.prototype.hasOwnProperty.call(t,e))<span class="cstat-no" title="statement not covered" >return t[e];c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i();<span class="cstat-no" title="statement not covered" ></span>return t[e]=s,s}</span>function <span class="fstat-no" title="function not covered" >Be(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return k(t)?t(e,i):t}</span>const Ne=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >!0===t?e:"string"==typeof t?y(e,t):void 0;</span></span>function <span class="fstat-no" title="function not covered" >We(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >for(const o of e){const e=<span class="cstat-no" title="statement not covered" >Ne(i,o);<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >t.add(e);c</span>onst o=<span class="cstat-no" title="statement not covered" >Be(e._fallback,i,n);<span class="cstat-no" title="statement not covered" ></span>if(M(o)&amp;&amp;o!==i&amp;&amp;o!==s)<span class="cstat-no" title="statement not covered" >return o}</span></span>else <span class="cstat-no" title="statement not covered" >if(!1===e&amp;&amp;M(s)&amp;&amp;i!==s)<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >je(</span>t,e,i,o){const a=<span class="cstat-no" title="statement not covered" >e._rootScopes,</span>r=<span class="cstat-no" title="statement not covered" >Be(e._fallback,i,o),</span>l=<span class="cstat-no" title="statement not covered" >[...t,...a],</span>h=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>h.add(o);l</span>et c=<span class="cstat-no" title="statement not covered" >He(h,l,i,r||i,o);<span class="cstat-no" title="statement not covered" ></span>return null!==c&amp;&amp;((!M(r)||r===i||(c=He(h,l,r,c,o),null!==c))&amp;&amp;Ee(Array.from(h),[""],a,r,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const o=<span class="cstat-no" title="statement not covered" >t._getTarget();<span class="cstat-no" title="statement not covered" ></span>e in o||(o[e]={});c</span>onst a=<span class="cstat-no" title="statement not covered" >o[e];<span class="cstat-no" title="statement not covered" ></span>if(s(a)&amp;&amp;n(i))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>(e,i,o))</span>))}</span>function <span class="fstat-no" title="function not covered" >He(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >for(;i;)<span class="cstat-no" title="statement not covered" >i=We(t,e,i,s,n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >$e(</span>t,e){<span class="cstat-no" title="statement not covered" >for(const i of e){<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>if(M(e))<span class="cstat-no" title="statement not covered" >return e}</span></span>}</span>function <span class="fstat-no" title="function not covered" >Ye(</span>t){let e=<span class="cstat-no" title="statement not covered" >t._keys;<span class="cstat-no" title="statement not covered" ></span>return e||(e=t._keys=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >for(const t of Object.keys(i).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("_"))</span>))<span class="cstat-no" title="statement not covered" >e.add(t);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn Array.from(e)}</span>(t._scopes)),e}</span>function <span class="fstat-no" title="function not covered" >Ue(</span>t,e,i,s){const{iScale:n}=<span class="cstat-no" title="statement not covered" >t,</span>{key:o=<span class="branch-0 cbranch-no" title="branch not covered" >"r"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>a=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let r,l,h,c;<span class="cstat-no" title="statement not covered" >for(r=0,l=s;r&lt;l;++r)<span class="cstat-no" title="statement not covered" >h=r+i,c=e[h],a[r]={r:n.parse(y(c,o),h)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>const Xe=<span class="cstat-no" title="statement not covered" >Number.EPSILON||1e-14,</span>qe=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;t.length&amp;&amp;!t[e].skip&amp;&amp;t[e],</span></span>Ke=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"x"===t?"y":"x";</span></span>function <span class="fstat-no" title="function not covered" >Ge(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.skip?e:t,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >i.skip?e:i,</span>r=<span class="cstat-no" title="statement not covered" >X(o,n),</span>l=<span class="cstat-no" title="statement not covered" >X(a,o);</span>let h=<span class="cstat-no" title="statement not covered" >r/(r+l),</span>c=<span class="cstat-no" title="statement not covered" >l/(r+l);<span class="cstat-no" title="statement not covered" ></span>h=isNaN(h)?0:h,c=isNaN(c)?0:c;c</span>onst d=<span class="cstat-no" title="statement not covered" >s*h,</span>u=<span class="cstat-no" title="statement not covered" >s*c;<span class="cstat-no" title="statement not covered" ></span>return{previous:{x:o.x-d*(a.x-n.x),y:o.y-d*(a.y-n.y)},next:{x:o.x+u*(a.x-n.x),y:o.y+u*(a.y-n.y)}}}</span>function <span class="fstat-no" title="function not covered" >Ze(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"x")</span>{const i=<span class="cstat-no" title="statement not covered" >Ke(e),</span>s=<span class="cstat-no" title="statement not covered" >t.length,</span>n=<span class="cstat-no" title="statement not covered" >Array(s).fill(0),</span>o=<span class="cstat-no" title="statement not covered" >Array(s);</span>let a,r,l,h=<span class="cstat-no" title="statement not covered" >qe(t,0);<span class="cstat-no" title="statement not covered" ></span>for(a=0;a&lt;s;++a)<span class="cstat-no" title="statement not covered" >if(r=l,l=h,h=qe(t,a+1),l){<span class="cstat-no" title="statement not covered" >if(h){const t=<span class="cstat-no" title="statement not covered" >h[e]-l[e];<span class="cstat-no" title="statement not covered" ></span>n[a]=0!==t?(h[i]-l[i])/t:0}<span class="cstat-no" title="statement not covered" ></span>o</span>[a]=r?h?z(n[a-1])!==z(n[a])?0:(n[a-1]+n[a])/2:n[a-1]:n[a]}<span class="cstat-no" title="statement not covered" ></span>!<span class="fstat-no" title="function not covered" ></span></span>fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.length;</span>let n,o,a,r,l,h=<span class="cstat-no" title="statement not covered" >qe(t,0);<span class="cstat-no" title="statement not covered" ></span>for(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;s-1;++c)<span class="cstat-no" title="statement not covered" >l=h,h=qe(t,c+1),l&amp;&amp;h&amp;&amp;(N(e[c],0,Xe)?i[c]=i[c+1]=0:(n=i[c]/e[c],o=i[c+1]/e[c],r=Math.pow(n,2)+Math.pow(o,2),r&lt;=9||(a=3/Math.sqrt(r),i[c]=n*a*e[c],i[c+1]=o*a*e[c])))}</span></span>(t,n,o),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >"x")</span>{const s=<span class="cstat-no" title="statement not covered" >Ke(i),</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>let o,a,r,l=<span class="cstat-no" title="statement not covered" >qe(t,0);<span class="cstat-no" title="statement not covered" ></span>for(let h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;n;++h){<span class="cstat-no" title="statement not covered" >if(a=r,r=l,l=qe(t,h+1),!r)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >r[i],</span>c=<span class="cstat-no" title="statement not covered" >r[s];<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;(o=(n-a[i])/3,r[`cp1${i}`]=n-o,r[`cp1${s}`]=c-o*e[h]),l&amp;&amp;(o=(l[i]-n)/3,r[`cp2${i}`]=n+o,r[`cp2${s}`]=c+o*e[h])}</span>}</span>(t,o,e)}</span>function <span class="fstat-no" title="function not covered" >Je(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Math.max(Math.min(t,i),e)}</span>function <span class="fstat-no" title="function not covered" >Qe(</span>t,e,i,s,n){let o,a,r,l;<span class="cstat-no" title="statement not covered" >if(e.spanGaps&amp;&amp;(t=t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.skip)</span>)),"monotone"===e.cubicInterpolationMode)<span class="cstat-no" title="statement not covered" >Ze(t,n);e</span>lse{let i=<span class="cstat-no" title="statement not covered" >s?t[t.length-1]:t[0];<span class="cstat-no" title="statement not covered" ></span>for(o=0,a=t.length;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >r=t[o],l=Ge(i,r,t[Math.min(o+1,a-(s?0:1))%a],e.tension),r.cp1x=l.previous.x,r.cp1y=l.previous.y,r.cp2x=l.next.x,r.cp2y=l.next.y,i=r}<span class="cstat-no" title="statement not covered" ></span></span>e</span>.capBezierPoints&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i,s,n,o,a,r=<span class="cstat-no" title="statement not covered" >Se(t[0],e);<span class="cstat-no" title="statement not covered" ></span>for(i=0,s=t.length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >a=o,o=r,r=i&lt;s-1&amp;&amp;Se(t[i+1],e),o&amp;&amp;(n=t[i],a&amp;&amp;(n.cp1x=Je(n.cp1x,e.left,e.right),n.cp1y=Je(n.cp1y,e.top,e.bottom)),r&amp;&amp;(n.cp2x=Je(n.cp2x,e.left,e.right),n.cp2y=Je(n.cp2y,e.top,e.bottom)))}</span></span>(t,i)}</span>const ti=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0===t||1===t,</span></span>ei=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >-Math.pow(2,10*(t-=1))*Math.sin((t-e)*O/i),</span></span>ii=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >Math.pow(2,-10*t)*Math.sin((t-e)*O/i)+1,</span></span>si=<span class="cstat-no" title="statement not covered" >{linear:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>easeInQuad:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t,</span>easeOutQuad:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-t*(t-2),</span>easeInOutQuad:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t:-.5*(--t*(t-2)-1),</span>easeInCubic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t*t,</span>easeOutCubic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t-=1)*t*t+1,</span>easeInOutCubic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t*t:.5*((t-=2)*t*t+2),</span>easeInQuart:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t*t*t,</span>easeOutQuart:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-((t-=1)*t*t*t-1),</span>easeInOutQuart:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),</span>easeInQuint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t*t*t*t,</span>easeOutQuint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t-=1)*t*t*t*t+1,</span>easeInOutQuint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),</span>easeInSine:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1-Math.cos(t*L),</span>easeOutSine:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.sin(t*L),</span>easeInOutSine:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-.5*(Math.cos(D*t)-1),</span>easeInExpo:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0===t?0:Math.pow(2,10*(t-1)),</span>easeOutExpo:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1===t?1:1-Math.pow(2,-10*t),</span>easeInOutExpo:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >ti(t)?t:t&lt;.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2,-10*(2*t-1))),</span>easeInCirc:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&gt;=1?t:-(Math.sqrt(1-t*t)-1),</span>easeOutCirc:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.sqrt(1-(t-=1)*t),</span>easeInOutCirc:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),</span>easeInElastic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >ti(t)?t:ei(t,.075,.3),</span>easeOutElastic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >ti(t)?t:ii(t,.075,.3),<span class="fstat-no" title="function not covered" ></span>ea</span>seInOutElastic(t){const e=<span class="cstat-no" title="statement not covered" >.1125;<span class="cstat-no" title="statement not covered" ></span>return ti(t)?t:t&lt;.5?.5*ei(2*t,e,.45):.5+.5*ii(2*t-1,e,.45)}</span>,<span class="fstat-no" title="function not covered" >ea</span>seInBack(t){const e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return t*t*((e+1)*t-e)}</span>,<span class="fstat-no" title="function not covered" >ea</span>seOutBack(t){const e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return(t-=1)*t*((e+1)*t+e)+1}</span>,<span class="fstat-no" title="function not covered" >ea</span>seInOutBack(t){let e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return(t/=.5)&lt;1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)}</span>,easeInBounce:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1-si.easeOutBounce(1-t),<span class="fstat-no" title="function not covered" ></span>ea</span>seOutBounce(t){const e=<span class="cstat-no" title="statement not covered" >7.5625,</span>i=<span class="cstat-no" title="statement not covered" >2.75;<span class="cstat-no" title="statement not covered" ></span>return t&lt;1/i?e*t*t:t&lt;2/i?e*(t-=1.5/i)*t+.75:t&lt;2.5/i?e*(t-=2.25/i)*t+.9375:e*(t-=2.625/i)*t+.984375}</span>,easeInOutBounce:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&lt;.5?.5*si.easeInBounce(2*t):.5*si.easeOutBounce(2*t-1)+.5}</span>;</span>function <span class="fstat-no" title="function not covered" >ni(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:t.x+i*(e.x-t.x),y:t.y+i*(e.y-t.y)}}</span>function <span class="fstat-no" title="function not covered" >oi(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:t.x+i*(e.x-t.x),y:"middle"===s?i&lt;.5?t.y:e.y:"after"===s?i&lt;1?t.y:e.y:i&gt;0?e.y:t.y}}</span>function <span class="fstat-no" title="function not covered" >ai(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >{x:t.cp2x,y:t.cp2y},</span>o=<span class="cstat-no" title="statement not covered" >{x:e.cp1x,y:e.cp1y},</span>a=<span class="cstat-no" title="statement not covered" >ni(t,n,i),</span>r=<span class="cstat-no" title="statement not covered" >ni(n,o,i),</span>l=<span class="cstat-no" title="statement not covered" >ni(o,e,i),</span>h=<span class="cstat-no" title="statement not covered" >ni(a,r,i),</span>c=<span class="cstat-no" title="statement not covered" >ni(r,l,i);<span class="cstat-no" title="statement not covered" ></span>return ni(h,c,i)}</span>const ri=<span class="cstat-no" title="statement not covered" >new Map;</span>function <span class="fstat-no" title="function not covered" >li(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e=e||{};c</span>onst i=<span class="cstat-no" title="statement not covered" >t+JSON.stringify(e);</span>let s=<span class="cstat-no" title="statement not covered" >ri.get(i);<span class="cstat-no" title="statement not covered" ></span>return s||(s=new Intl.NumberFormat(t,e),ri.set(i,s)),s}</span>(e,i).format(t)}</span>const hi=<span class="cstat-no" title="statement not covered" >new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/),</span>ci=<span class="cstat-no" title="statement not covered" >new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);</span>function <span class="fstat-no" title="function not covered" >di(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >(""+t).match(hi);<span class="cstat-no" title="statement not covered" ></span>if(!i||"normal"===i[1])<span class="cstat-no" title="statement not covered" >return 1.2*e;<span class="cstat-no" title="statement not covered" >s</span></span>witch(t=+i[2],i[3]){case"px":<span class="cstat-no" title="statement not covered" >return t;c</span>ase"%":<span class="cstat-no" title="statement not covered" >t/=100}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e*t}</span>function <span class="fstat-no" title="function not covered" >ui(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >n(e),</span>o=<span class="cstat-no" title="statement not covered" >s?Object.keys(e):e,</span>a=<span class="cstat-no" title="statement not covered" >n(t)?s?<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >r(t[i],t[e[i]]):<span class="fstat-no" title="function not covered" ></span>e=</span>&gt;<span class="cstat-no" title="statement not covered" >t[e]:<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span></span>for(const t of o)<span class="cstat-no" title="statement not covered" >i[t]=+a(t)||0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >fi(</span>t){<span class="cstat-no" title="statement not covered" >return ui(t,{top:"y",right:"x",bottom:"y",left:"x"})}</span>function <span class="fstat-no" title="function not covered" >gi(</span>t){<span class="cstat-no" title="statement not covered" >return ui(t,["topLeft","topRight","bottomLeft","bottomRight"])}</span>function <span class="fstat-no" title="function not covered" >pi(</span>t){const e=<span class="cstat-no" title="statement not covered" >fi(t);<span class="cstat-no" title="statement not covered" ></span>return e.width=e.left+e.right,e.height=e.top+e.bottom,e}</span>function <span class="fstat-no" title="function not covered" >mi(</span>t,e){<span class="cstat-no" title="statement not covered" >t=t||{},e=e||ne.font;l</span>et i=<span class="cstat-no" title="statement not covered" >r(t.size,e.size);<span class="cstat-no" title="statement not covered" ></span>"string"==typeof i&amp;&amp;(i=parseInt(i,10));l</span>et s=<span class="cstat-no" title="statement not covered" >r(t.style,e.style);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;!(""+s).match(ci)&amp;&amp;(console.warn('Invalid font style specified: "'+s+'"'),s="");c</span>onst n=<span class="cstat-no" title="statement not covered" >{family:r(t.family,e.family),lineHeight:di(r(t.lineHeight,e.lineHeight),i),size:i,style:s,weight:r(t.weight,e.weight),string:""};<span class="cstat-no" title="statement not covered" ></span>return n.string=xe(n),n}</span>function <span class="fstat-no" title="function not covered" >bi(</span>t,e,i,n){let o,a,r,l=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>for(o=0,a=t.length;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >if(r=t[o],void 0!==r&amp;&amp;(void 0!==e&amp;&amp;"function"==typeof r&amp;&amp;(r=r(e),l=!1),void 0!==i&amp;&amp;s(r)&amp;&amp;(r=r[i%r.length],l=!1),void 0!==r))<span class="cstat-no" title="statement not covered" >return n&amp;&amp;!l&amp;&amp;(n.cacheable=!1),r}</span></span></span>function <span class="fstat-no" title="function not covered" >xi(</span>t,e,i){const{min:s,max:n}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >h(e,(n-s)/2),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >i&amp;&amp;0===t?0:t+e;<span class="cstat-no" title="statement not covered" ></span></span>return{min:a(s,-Math.abs(o)),max:a(n,o)}}</span>function <span class="fstat-no" title="function not covered" >_i(</span>t,e){<span class="cstat-no" title="statement not covered" >return Object.assign(Object.create(t),e)}</span>function <span class="fstat-no" title="function not covered" >yi(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return t?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return{x:<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t+t+e-i,<span class="fstat-no" title="function not covered" ></span>se</span>tWidth(t){<span class="cstat-no" title="statement not covered" >e=t}</span>,textAlign:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"center"===t?t:"right"===t?"left":"right",</span>xPlus:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e,</span>leftForLtr:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e}</span>}</span>(e,i):{x:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,<span class="fstat-no" title="function not covered" ></span>se</span>tWidth(t){},textAlign:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>xPlus:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e,</span>leftForLtr:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t}</span>}</span>function <span class="fstat-no" title="function not covered" >vi(</span>t,e){let i,s;<span class="cstat-no" title="statement not covered" >"ltr"!==e&amp;&amp;"rtl"!==e||(i=t.canvas.style,s=[i.getPropertyValue("direction"),i.getPropertyPriority("direction")],i.setProperty("direction",e,"important"),t.prevTextDirection=s)}</span>function <span class="fstat-no" title="function not covered" >wi(</span>t,e){<span class="cstat-no" title="statement not covered" >void 0!==e&amp;&amp;(delete t.prevTextDirection,t.canvas.style.setProperty("direction",e[0],e[1]))}</span>function <span class="fstat-no" title="function not covered" >Mi(</span>t){<span class="cstat-no" title="statement not covered" >return"angle"===t?{between:G,compare:q,normalize:K}:{between:Q,compare:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e,</span>normalize:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t}</span>}</span>function <span class="fstat-no" title="function not covered" >ki(</span>{start:t,end:e,count:i,loop:s,style:n}){<span class="cstat-no" title="statement not covered" >return{start:t%i,end:e%i,loop:s&amp;&amp;(e-t+1)%i==0,style:n}}</span>function <span class="fstat-no" title="function not covered" >Si(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >return[t];c</span></span>onst{property:s,start:n,end:o}=<span class="cstat-no" title="statement not covered" >i,</span>a=<span class="cstat-no" title="statement not covered" >e.length,</span>{compare:r,between:l,normalize:h}=<span class="cstat-no" title="statement not covered" >Mi(s),</span>{start:c,end:d,loop:u,style:f}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{property:s,start:n,end:o}=<span class="cstat-no" title="statement not covered" >i,</span>{between:a,normalize:r}=<span class="cstat-no" title="statement not covered" >Mi(s),</span>l=<span class="cstat-no" title="statement not covered" >e.length;</span>let h,c,{start:d,end:u,loop:f}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(f){<span class="cstat-no" title="statement not covered" >for(d+=l,u+=l,h=0,c=l;h&lt;c&amp;&amp;a(r(e[d%l][s]),n,o);++h)<span class="cstat-no" title="statement not covered" >d--,u--;<span class="cstat-no" title="statement not covered" >d</span></span>%=l,u%=l}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn u&lt;d&amp;&amp;(u+=l),{start:d,end:u,loop:f,style:t.style}}</span>(t,e,i),</span>g=<span class="cstat-no" title="statement not covered" >[];</span>let p,m,b,x=<span class="cstat-no" title="statement not covered" >!1,</span>_=<span class="cstat-no" title="statement not covered" >null;</span>const y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >x||l(n,b,p)&amp;&amp;0!==r(n,b),</span></span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!x||0===r(o,p)||l(o,b,p);<span class="cstat-no" title="statement not covered" ></span></span>for(let t=<span class="cstat-no" title="statement not covered" >c,</span>i=<span class="cstat-no" title="statement not covered" >c;</span>t&lt;=d;++t)<span class="cstat-no" title="statement not covered" >m=e[t%a],m.skip||(p=h(m[s]),p!==b&amp;&amp;(x=l(p,n,o),null===_&amp;&amp;y()&amp;&amp;(_=0===r(p,n)?t:i),null!==_&amp;&amp;v()&amp;&amp;(g.push(ki({start:_,end:t,loop:u,count:a,style:f})),_=null),i=t,b=p));<span class="cstat-no" title="statement not covered" >r</span></span>eturn null!==_&amp;&amp;g.push(ki({start:_,end:d,loop:u,count:a,style:f})),g}</span>function <span class="fstat-no" title="function not covered" >Pi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.segments;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++){const o=<span class="cstat-no" title="statement not covered" >Si(s[n],t.points,e);<span class="cstat-no" title="statement not covered" ></span>o.length&amp;&amp;i.push(...o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Di(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.points,</span>s=<span class="cstat-no" title="statement not covered" >t.options.spanGaps,</span>n=<span class="cstat-no" title="statement not covered" >i.length;<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst o=<span class="cstat-no" title="statement not covered" >!!t._loop,</span>{start:a,end:r}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >e-1;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;!s)<span class="cstat-no" title="statement not covered" >for(;n&lt;e&amp;&amp;!t[n].skip;)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;n&lt;e&amp;&amp;t[n].skip;)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >f</span></span>or(n%=e,i&amp;&amp;(o+=n);o&gt;n&amp;&amp;t[o%e].skip;)<span class="cstat-no" title="statement not covered" >o--;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o%=e,{start:n,end:o}}</span>(i,n,o,s);<span class="cstat-no" title="statement not covered" ></span>if(!0===s)<span class="cstat-no" title="statement not covered" >return Oi(t,[{start:a,end:r,loop:o}],i,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Oi(t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.length,</span>o=<span class="cstat-no" title="statement not covered" >[];</span>let a,r=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>for(a=e+1;a&lt;=i;++a){const i=<span class="cstat-no" title="statement not covered" >t[a%n];<span class="cstat-no" title="statement not covered" ></span>i.skip||i.stop?l.skip||(s=!1,o.push({start:e%n,end:(a-1)%n,loop:s}),e=r=i.stop?a:null):(r=a,l.skip&amp;&amp;(e=a)),l=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null!==r&amp;&amp;o.push({start:e%n,end:r%n,loop:s}),o}</span>(i,a,r&lt;a?r+n:r,!!t._fullLoop&amp;&amp;0===a&amp;&amp;r===n-1),i,e)}</span>function <span class="fstat-no" title="function not covered" >Oi(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return s&amp;&amp;s.setContext&amp;&amp;i?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t._chart.getContext(),</span>o=<span class="cstat-no" title="statement not covered" >Ci(t.options),</span>{_datasetIndex:a,options:{spanGaps:r}}=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >i.length,</span>h=<span class="cstat-no" title="statement not covered" >[];</span>let c=<span class="cstat-no" title="statement not covered" >o,</span>d=<span class="cstat-no" title="statement not covered" >e[0].start,</span>u=<span class="cstat-no" title="statement not covered" >d;</span>function <span class="fstat-no" title="function not covered" >f(</span>t,e,s,n){const o=<span class="cstat-no" title="statement not covered" >r?-1:1;<span class="cstat-no" title="statement not covered" ></span>if(t!==e){<span class="cstat-no" title="statement not covered" >for(t+=l;i[t%l].skip;)<span class="cstat-no" title="statement not covered" >t-=o;<span class="cstat-no" title="statement not covered" >f</span></span>or(;i[e%l].skip;)<span class="cstat-no" title="statement not covered" >e+=o;<span class="cstat-no" title="statement not covered" >t</span></span>%l!=e%l&amp;&amp;(h.push({start:t%l,end:e%l,loop:s,style:n}),c=n,d=e%l)}</span>}<span class="cstat-no" title="statement not covered" ></span>for(const t of e){<span class="cstat-no" title="statement not covered" >d=r?d:t.start;l</span>et e,o=<span class="cstat-no" title="statement not covered" >i[d%l];<span class="cstat-no" title="statement not covered" ></span>for(u=d+1;u&lt;=t.end;u++){const r=<span class="cstat-no" title="statement not covered" >i[u%l];<span class="cstat-no" title="statement not covered" ></span>e=Ci(s.setContext(_i(n,{type:"segment",p0:o,p1:r,p0DataIndex:(u-1)%l,p1DataIndex:u%l,datasetIndex:a}))),Ai(e,c)&amp;&amp;f(d,u-1,t.loop,c),o=r,c=e}<span class="cstat-no" title="statement not covered" ></span>d</span>&lt;u-1&amp;&amp;f(d,u-1,t.loop,c)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn h}</span>(t,e,i,s):e}</span>function <span class="fstat-no" title="function not covered" >Ci(</span>t){<span class="cstat-no" title="statement not covered" >return{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}</span>function <span class="fstat-no" title="function not covered" >Ai(</span>t,e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;JSON.stringify(t)!==JSON.stringify(e)}</span>var Ti=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,easingEffects:si,isPatternOrGradient:Zt,color:Jt,getHoverColor:Qt,noop:t,uid:e,isNullOrUndef:i,isArray:s,isObject:n,isFinite:o,finiteOrDefault:a,valueOrDefault:r,toPercentage:l,toDimension:h,callback:c,each:d,_elementsEqual:u,clone:f,_merger:p,merge:m,mergeIf:b,_mergerIf:x,_deprecated:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >void 0!==e&amp;&amp;console.warn(t+': "'+i+'" is deprecated. Please use "'+s+'" instead')}</span>,resolveObjectKey:y,_splitKey:v,_capitalize:w,defined:M,isFunction:k,setsEqual:S,_isClickEvent:P,toFontString:xe,_measureText:_e,_longestText:ye,_alignPixel:ve,clearCanvas:we,drawPoint:Me,drawPointLegend:ke,_isPointInArea:Se,clipArea:Pe,unclipArea:De,_steppedLineTo:Oe,_bezierCurveTo:Ce,renderText:Ae,addRoundedRectPath:Le,_lookup:tt,_lookupByKey:et,_rlookupByKey:it,_filterBetween:st,listenArrayEvents:ot,unlistenArrayEvents:at,_arrayUnique:rt,_createResolver:Ee,_attachContext:Re,_descriptors:Ie,_parseObjectDataRadialScale:Ue,splineCurve:Ge,splineCurveMonotone:Ze,_updateBezierControlPoints:Qe,_isDomSupported:oe,_getParentNode:ae,getStyle:he,getRelativePosition:ue,getMaximumSize:ge,retinaScale:pe,supportsEventListenerOptions:me,readUsedSize:be,fontString:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return e+" "+t+"px "+i}</span>,requestAnimFrame:lt,throttled:ht,debounce:ct,_toLeftRightCenter:dt,_alignStartEnd:ut,_textX:ft,_getStartAndCountOfVisiblePoints:gt,_scaleRangesChanged:pt,_pointInLine:ni,_steppedInterpolation:oi,_bezierInterpolation:ai,formatNumber:li,toLineHeight:di,_readValueToProps:ui,toTRBL:fi,toTRBLCorners:gi,toPadding:pi,toFont:mi,resolve:bi,_addGrace:xi,createContext:_i,PI:D,TAU:O,PITAU:C,INFINITY:A,RAD_PER_DEG:T,HALF_PI:L,QUARTER_PI:E,TWO_THIRDS_PI:R,log10:I,sign:z,niceNum:F,_factorize:V,isNumber:B,almostEquals:N,almostWhole:W,_setMinAndMaxByKey:j,toRadians:H,toDegrees:$,_decimalPlaces:Y,getAngleFromPoint:U,distanceBetweenPoints:X,_angleDiff:q,_normalizeAngle:K,_angleBetween:G,_limitValue:Z,_int16Range:J,_isBetween:Q,getRtlAdapter:yi,overrideTextDirection:vi,restoreTextDirection:wi,_boundSegment:Si,_boundSegments:Pi,_computeSegments:Di});</span>function <span class="fstat-no" title="function not covered" >Li(</span>t,e,i,s){const{controller:n,data:o,_sorted:a}=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" >n._cachedMeta.iScale;<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;e===r.axis&amp;&amp;"r"!==e&amp;&amp;a&amp;&amp;o.length){const t=<span class="cstat-no" title="statement not covered" >r._reversePixels?it:et;<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return t(o,e,i);<span class="cstat-no" title="statement not covered" >i</span></span>f(n._sharedOptions){const s=<span class="cstat-no" title="statement not covered" >o[0],</span>n=<span class="cstat-no" title="statement not covered" >"function"==typeof s.getRange&amp;&amp;s.getRange(e);<span class="cstat-no" title="statement not covered" ></span>if(n){const s=<span class="cstat-no" title="statement not covered" >t(o,e,i-n),</span>a=<span class="cstat-no" title="statement not covered" >t(o,e,i+n);<span class="cstat-no" title="statement not covered" ></span>return{lo:s.lo,hi:a.hi}}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{lo:0,hi:o.length-1}}</span>function <span class="fstat-no" title="function not covered" >Ei(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas(),</span>a=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >o.length;</span>t&lt;i;++t){const{index:i,data:r}=<span class="cstat-no" title="statement not covered" >o[t],</span>{lo:l,hi:h}=<span class="cstat-no" title="statement not covered" >Li(o[t],e,a,n);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >l;</span>t&lt;=h;++t){const e=<span class="cstat-no" title="statement not covered" >r[t];<span class="cstat-no" title="statement not covered" ></span>e.skip||s(e,i,t)}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >Ri(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(!n&amp;&amp;!t.isPointInArea(e))<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn Ei(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(i,a,r){<span class="cstat-no" title="statement not covered" >(n||Se(i,t.chartArea,0))&amp;&amp;i.inRange(e.x,e.y,s)&amp;&amp;o.push({element:i,datasetIndex:a,index:r})}</span>),!0),o}</span>function <span class="fstat-no" title="function not covered" >Ii(</span>t,e,i,s,n,o){let a=<span class="cstat-no" title="statement not covered" >[];</span>const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >-1!==t.indexOf("x"),</span>i=<span class="cstat-no" title="statement not covered" >-1!==t.indexOf("y");<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,s){const n=<span class="cstat-no" title="statement not covered" >e?Math.abs(t.x-s.x):0,</span>o=<span class="cstat-no" title="statement not covered" >i?Math.abs(t.y-s.y):0;<span class="cstat-no" title="statement not covered" ></span>return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}</span>}</span>(i);</span>let l=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>return Ei(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(i,h,c){const d=<span class="cstat-no" title="statement not covered" >i.inRange(e.x,e.y,n);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;!d)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst u=<span class="cstat-no" title="statement not covered" >i.getCenterPoint(n);<span class="cstat-no" title="statement not covered" ></span>if(!(!!o||t.isPointInArea(u))&amp;&amp;!d)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst f=<span class="cstat-no" title="statement not covered" >r(e,u);<span class="cstat-no" title="statement not covered" ></span>f&lt;l?(a=[{element:i,datasetIndex:h,index:c}],l=f):f===l&amp;&amp;a.push({element:i,datasetIndex:h,index:c})}</span>)),a}</span>function <span class="fstat-no" title="function not covered" >zi(</span>t,e,i,s,n,o){<span class="cstat-no" title="statement not covered" >return o||t.isPointInArea(e)?"r"!==i||s?Ii(t,e,i,s,n,o):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return Ei(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,o){const{startAngle:a,endAngle:r}=<span class="cstat-no" title="statement not covered" >t.getProps(["startAngle","endAngle"],s),</span>{angle:l}=<span class="cstat-no" title="statement not covered" >U(t,{x:e.x,y:e.y});<span class="cstat-no" title="statement not covered" ></span>G(l,a,r)&amp;&amp;n.push({element:t,datasetIndex:i,index:o})}</span>)),n}</span>(t,e,i,n):[]}</span>function <span class="fstat-no" title="function not covered" >Fi(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >"x"===i?"inXRange":"inYRange";</span>let r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return Ei(t,i,e,(<span class="fstat-no" title="function not covered" >(t</span>,s,l)=&gt;{<span class="cstat-no" title="statement not covered" >t[a](e[i],n)&amp;&amp;(o.push({element:t,datasetIndex:s,index:l}),r=r||t.inRange(e.x,e.y,n))}</span>)),s&amp;&amp;!r?[]:o}</span>var Vi=<span class="cstat-no" title="statement not covered" >{evaluateInteractionItems:Ei,modes:{<span class="fstat-no" title="function not covered" >in</span>dex(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ue(e,t),</span>o=<span class="cstat-no" title="statement not covered" >i.axis||"x",</span>a=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1,</span>r=<span class="cstat-no" title="statement not covered" >i.intersect?Ri(t,n,o,s,a):zi(t,n,o,!1,s,a),</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return r.length?(t.getSortedVisibleDatasetMetas().forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >r[0].index,</span>i=<span class="cstat-no" title="statement not covered" >t.data[e];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;!i.skip&amp;&amp;l.push({element:i,datasetIndex:t.index,index:e})}</span>)),l):[]}</span>,<span class="fstat-no" title="function not covered" >da</span>taset(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ue(e,t),</span>o=<span class="cstat-no" title="statement not covered" >i.axis||"xy",</span>a=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1;</span>let r=<span class="cstat-no" title="statement not covered" >i.intersect?Ri(t,n,o,s,a):zi(t,n,o,!1,s,a);<span class="cstat-no" title="statement not covered" ></span>if(r.length&gt;0){const e=<span class="cstat-no" title="statement not covered" >r[0].datasetIndex,</span>i=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(e).data;<span class="cstat-no" title="statement not covered" ></span>r=[];<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;i.length;++t)<span class="cstat-no" title="statement not covered" >r.push({element:i[t],datasetIndex:e,index:t})}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r}</span>,point:<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >Ri(t,ue(e,t),i.axis||"xy",s,i.includeInvisible||!1),<span class="fstat-no" title="function not covered" ></span>ne</span>arest(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ue(e,t),</span>o=<span class="cstat-no" title="statement not covered" >i.axis||"xy",</span>a=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1;<span class="cstat-no" title="statement not covered" ></span>return zi(t,n,o,i.intersect,s,a)}</span>,x:<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >Fi(t,ue(e,t),"x",i.intersect,s),</span>y:<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >Fi(t,ue(e,t),"y",i.intersect,s)}</span>};</span>const Bi=<span class="cstat-no" title="statement not covered" >["left","top","right","bottom"];</span>function <span class="fstat-no" title="function not covered" >Ni(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.pos===e)</span>)}</span>function <span class="fstat-no" title="function not covered" >Wi(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-1===Bi.indexOf(t.pos)&amp;&amp;t.box.axis===e)</span>)}</span>function <span class="fstat-no" title="function not covered" >ji(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.sort((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >e?i:t,</span>n=<span class="cstat-no" title="statement not covered" >e?t:i;<span class="cstat-no" title="statement not covered" ></span>return s.weight===n.weight?s.index-n.index:s.weight-n.weight}</span>))}</span>function <span class="fstat-no" title="function not covered" >Hi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const i of t){const{stack:t,pos:s,stackWeight:n}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(!t||!Bi.includes(s))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >e[t]||(e[t]={count:0,placed:0,weight:0,size:0});<span class="cstat-no" title="statement not covered" ></span>o.count++,o.weight+=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>(t),</span>{vBoxMaxWidth:s,hBoxMaxHeight:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o,a,r;<span class="cstat-no" title="statement not covered" >for(o=0,a=t.length;o&lt;a;++o){<span class="cstat-no" title="statement not covered" >r=t[o];c</span>onst{fullSize:a}=<span class="cstat-no" title="statement not covered" >r.box,</span>l=<span class="cstat-no" title="statement not covered" >i[r.stack],</span>h=<span class="cstat-no" title="statement not covered" >l&amp;&amp;r.stackWeight/l.weight;<span class="cstat-no" title="statement not covered" ></span>r.horizontal?(r.width=h?h*s:a&amp;&amp;e.availableWidth,r.height=n):(r.width=s,r.height=h?h*n:a&amp;&amp;e.availableHeight)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >$i(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return Math.max(t[i],e[i])+Math.max(t[s],e[s])}</span>function <span class="fstat-no" title="function not covered" >Yi(</span>t,e){<span class="cstat-no" title="statement not covered" >t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}</span>function <span class="fstat-no" title="function not covered" >Ui(</span>t,e,i,s){const{pos:o,box:a}=<span class="cstat-no" title="statement not covered" >i,</span>r=<span class="cstat-no" title="statement not covered" >t.maxPadding;<span class="cstat-no" title="statement not covered" ></span>if(!n(o)){<span class="cstat-no" title="statement not covered" >i.size&amp;&amp;(t[o]-=i.size);c</span>onst e=<span class="cstat-no" title="statement not covered" >s[i.stack]||{size:0,count:1};<span class="cstat-no" title="statement not covered" ></span>e.size=Math.max(e.size,i.horizontal?a.height:a.width),i.size=e.size/e.count,t[o]+=i.size}<span class="cstat-no" title="statement not covered" ></span>a</span>.getPadding&amp;&amp;Yi(r,a.getPadding());c</span>onst l=<span class="cstat-no" title="statement not covered" >Math.max(0,e.outerWidth-$i(r,t,"left","right")),</span>h=<span class="cstat-no" title="statement not covered" >Math.max(0,e.outerHeight-$i(r,t,"top","bottom")),</span>c=<span class="cstat-no" title="statement not covered" >l!==t.w,</span>d=<span class="cstat-no" title="statement not covered" >h!==t.h;<span class="cstat-no" title="statement not covered" ></span>return t.w=l,t.h=h,i.horizontal?{same:c,other:d}:{same:d,other:c}}</span>function <span class="fstat-no" title="function not covered" >Xi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e.maxPadding;</span>function <span class="fstat-no" title="function not covered" >s(</span>t){const s=<span class="cstat-no" title="statement not covered" >{left:0,top:0,right:0,bottom:0};<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s[t]=Math.max(e[t],i[t])}</span>)),s}<span class="cstat-no" title="statement not covered" ></span>return s(t?["left","right"]:["top","bottom"])}</span>function <span class="fstat-no" title="function not covered" >qi(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >[];</span>let o,a,r,l,h,c;<span class="cstat-no" title="statement not covered" >for(o=0,a=t.length,h=0;o&lt;a;++o){<span class="cstat-no" title="statement not covered" >r=t[o],l=r.box,l.update(r.width||e.w,r.height||e.h,Xi(r.horizontal,e));c</span>onst{same:a,other:d}=<span class="cstat-no" title="statement not covered" >Ui(e,i,r,s);<span class="cstat-no" title="statement not covered" ></span>h|=a&amp;&amp;n.length,c=c||d,l.fullSize||n.push(r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn h&amp;&amp;qi(n,e,i,s)||c}</span>function <span class="fstat-no" title="function not covered" >Ki(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >t.top=i,t.left=e,t.right=e+s,t.bottom=i+n,t.width=s,t.height=n}</span>function <span class="fstat-no" title="function not covered" >Gi(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i.padding;</span>let{x:o,y:a}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(const r of t){const t=<span class="cstat-no" title="statement not covered" >r.box,</span>l=<span class="cstat-no" title="statement not covered" >s[r.stack]||{count:1,placed:0,weight:1},</span>h=<span class="cstat-no" title="statement not covered" >r.stackWeight/l.weight||1;<span class="cstat-no" title="statement not covered" ></span>if(r.horizontal){const s=<span class="cstat-no" title="statement not covered" >e.w*h,</span>o=<span class="cstat-no" title="statement not covered" >l.size||t.height;<span class="cstat-no" title="statement not covered" ></span>M(l.start)&amp;&amp;(a=l.start),t.fullSize?Ki(t,n.left,a,i.outerWidth-n.right-n.left,o):Ki(t,e.left+l.placed,a,s,o),l.start=a,l.placed+=s,a=t.bottom}</span>else{const s=<span class="cstat-no" title="statement not covered" >e.h*h,</span>a=<span class="cstat-no" title="statement not covered" >l.size||t.width;<span class="cstat-no" title="statement not covered" ></span>M(l.start)&amp;&amp;(o=l.start),t.fullSize?Ki(t,o,n.top,a,i.outerHeight-n.bottom-n.top):Ki(t,o,e.top+l.placed,a,s),l.start=o,l.placed+=s,o=t.right}</span>}<span class="cstat-no" title="statement not covered" ></span>e</span>.x=o,e.y=a}<span class="cstat-no" title="statement not covered" ></span>ne.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}});v</span>ar Zi=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >ad</span>dBox(t,e){<span class="cstat-no" title="statement not covered" >t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[{z:0,<span class="fstat-no" title="function not covered" >dr</span>aw(t){<span class="cstat-no" title="statement not covered" >e.draw(t)}</span>}]}</span>,t.boxes.push(e)}</span>,<span class="fstat-no" title="function not covered" >re</span>moveBox(t,e){const i=<span class="cstat-no" title="statement not covered" >t.boxes?t.boxes.indexOf(e):-1;<span class="cstat-no" title="statement not covered" ></span>-1!==i&amp;&amp;t.boxes.splice(i,1)}</span>,<span class="fstat-no" title="function not covered" >co</span>nfigure(t,e,i){<span class="cstat-no" title="statement not covered" >e.fullSize=i.fullSize,e.position=i.position,e.weight=i.weight}</span>,<span class="fstat-no" title="function not covered" >up</span>date(t,e,i,s){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >pi(t.options.layout.padding),</span>o=<span class="cstat-no" title="statement not covered" >Math.max(e-n.width,0),</span>a=<span class="cstat-no" title="statement not covered" >Math.max(i-n.height,0),</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let i,s,n,o,a,r;<span class="cstat-no" title="statement not covered" >for(i=0,s=(t||[]).length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >n=t[i],({position:o,options:{stack:a,stackWeight:r=<span class="branch-0 cbranch-no" title="branch not covered" >1}</span>}=n),e.push({index:i,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:a&amp;&amp;o+a,stackWeight:r});<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(t),</span>i=<span class="cstat-no" title="statement not covered" >ji(e.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.box.fullSize)</span>),!0),</span>s=<span class="cstat-no" title="statement not covered" >ji(Ni(e,"left"),!0),</span>n=<span class="cstat-no" title="statement not covered" >ji(Ni(e,"right")),</span>o=<span class="cstat-no" title="statement not covered" >ji(Ni(e,"top"),!0),</span>a=<span class="cstat-no" title="statement not covered" >ji(Ni(e,"bottom")),</span>r=<span class="cstat-no" title="statement not covered" >Wi(e,"x"),</span>l=<span class="cstat-no" title="statement not covered" >Wi(e,"y");<span class="cstat-no" title="statement not covered" ></span>return{fullSize:i,leftAndTop:s.concat(o),rightAndBottom:n.concat(l).concat(a).concat(r),chartArea:Ni(e,"chartArea"),vertical:s.concat(n).concat(l),horizontal:o.concat(a).concat(r)}}</span>(t.boxes),</span>l=<span class="cstat-no" title="statement not covered" >r.vertical,</span>h=<span class="cstat-no" title="statement not covered" >r.horizontal;<span class="cstat-no" title="statement not covered" ></span>d(t.boxes,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >"function"==typeof t.beforeLayout&amp;&amp;t.beforeLayout()}</span>));c</span>onst c=<span class="cstat-no" title="statement not covered" >l.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.box.options&amp;&amp;!1===e.box.options.display?t:t+1)</span>,0)||1,</span>u=<span class="cstat-no" title="statement not covered" >Object.freeze({outerWidth:e,outerHeight:i,padding:n,availableWidth:o,availableHeight:a,vBoxMaxWidth:o/2/c,hBoxMaxHeight:a/2}),</span>f=<span class="cstat-no" title="statement not covered" >Object.assign({},n);<span class="cstat-no" title="statement not covered" ></span>Yi(f,pi(s));c</span>onst g=<span class="cstat-no" title="statement not covered" >Object.assign({maxPadding:f,w:o,h:a,x:n.left,y:n.top},n),</span>p=<span class="cstat-no" title="statement not covered" >Hi(l.concat(h),u);<span class="cstat-no" title="statement not covered" ></span>qi(r.fullSize,g,u,p),qi(l,g,u,p),qi(h,g,u,p)&amp;&amp;qi(l,g,u,p),<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.maxPadding;</span>function <span class="fstat-no" title="function not covered" >i(</span>i){const s=<span class="cstat-no" title="statement not covered" >Math.max(e[i]-t[i],0);<span class="cstat-no" title="statement not covered" ></span>return t[i]+=s,s}<span class="cstat-no" title="statement not covered" ></span>t.y+=i("top"),t.x+=i("left"),i("right"),i("bottom")}</span>(g),Gi(r.leftAndTop,g,u,p),g.x+=g.w,g.y+=g.h,Gi(r.rightAndBottom,g,u,p),t.chartArea={left:g.left,top:g.top,right:g.left+g.w,bottom:g.top+g.h,height:g.h,width:g.w},d(r.chartArea,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e.box;<span class="cstat-no" title="statement not covered" ></span>Object.assign(i,t.chartArea),i.update(g.w,g.h,{left:0,top:0,right:0,bottom:0})}</span>))}</span>};</span>class Ji{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t,e){}<span class="fstat-no" title="function not covered" >re</span>leaseContext(t){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e,i){}<span class="fstat-no" title="function not covered" >re</span>moveEventListener(t,e,i){}<span class="fstat-no" title="function not covered" >ge</span>tDevicePixelRatio(){<span class="cstat-no" title="statement not covered" >return 1}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaximumSize(t,e,i,s){<span class="cstat-no" title="statement not covered" >return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,s?Math.floor(e/s):i)}}<span class="fstat-no" title="function not covered" ></span>is</span>Attached(t){<span class="cstat-no" title="statement not covered" >return!0}<span class="fstat-no" title="function not covered" ></span>up</span>dateConfig(t){}}class Qi extends Ji{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;t.getContext&amp;&amp;t.getContext("2d")||null}<span class="fstat-no" title="function not covered" ></span>up</span>dateConfig(t){<span class="cstat-no" title="statement not covered" >t.options.animation=!1}</span>}const ts=<span class="cstat-no" title="statement not covered" >{touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},</span>es=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >null===t||""===t;</span></span>const is=<span class="cstat-no" title="statement not covered" >!!me&amp;&amp;{passive:!0};</span>function <span class="fstat-no" title="function not covered" >ss(</span>t,e,i){<span class="cstat-no" title="statement not covered" >t.canvas.removeEventListener(e,i,is)}</span>function <span class="fstat-no" title="function not covered" >ns(</span>t,e){<span class="cstat-no" title="statement not covered" >for(const i of t)<span class="cstat-no" title="statement not covered" >if(i===e||i.contains(e))<span class="cstat-no" title="statement not covered" >return!0}</span></span></span>function <span class="fstat-no" title="function not covered" >os(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >new MutationObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >e=e||ns(i.addedNodes,s),e=e&amp;&amp;!ns(i.removedNodes,s);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;i()}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.observe(document,{childList:!0,subtree:!0}),n}</span>function <span class="fstat-no" title="function not covered" >as(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >new MutationObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >e=e||ns(i.removedNodes,s),e=e&amp;&amp;!ns(i.addedNodes,s);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;i()}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.observe(document,{childList:!0,subtree:!0}),n}</span>const rs=<span class="cstat-no" title="statement not covered" >new Map;</span>let ls=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >hs(</span>){const t=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>t!==ls&amp;&amp;(ls=t,rs.forEach((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >i.currentDevicePixelRatio!==t&amp;&amp;e()}</span>)))}</span>function <span class="fstat-no" title="function not covered" >cs(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >s&amp;&amp;ae(s);<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >ht((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const s=<span class="cstat-no" title="statement not covered" >n.clientWidth;<span class="cstat-no" title="statement not covered" ></span>i(t,e),s&lt;n.clientWidth&amp;&amp;i()}</span>),window),</span>a=<span class="cstat-no" title="statement not covered" >new ResizeObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t[0],</span>i=<span class="cstat-no" title="statement not covered" >e.contentRect.width,</span>s=<span class="cstat-no" title="statement not covered" >e.contentRect.height;<span class="cstat-no" title="statement not covered" ></span>0===i&amp;&amp;0===s||o(i,s)}</span>));<span class="cstat-no" title="statement not covered" ></span>return a.observe(n),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >rs.size||window.addEventListener("resize",hs),rs.set(t,e)}</span>(t,o),a}</span>function <span class="fstat-no" title="function not covered" >ds(</span>t,e,i){<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.disconnect(),"resize"===e&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >rs.delete(t),rs.size||window.removeEventListener("resize",hs)}</span>(t)}</span>function <span class="fstat-no" title="function not covered" >us(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >ht((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >null!==t.ctx&amp;&amp;i(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >ts[t.type]||t.type,</span>{x:s,y:n}=<span class="cstat-no" title="statement not covered" >ue(t,e);<span class="cstat-no" title="statement not covered" ></span>return{type:i,chart:e,native:t,x:void 0!==s?s:null,y:void 0!==n?n:null}}</span>(e,t))}</span>),t,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>return[e,e.offsetX,e.offsetY]}</span>));<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >t.addEventListener(e,i,is)}</span>(s,e,n),n}</span>class fs extends Ji{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.getContext&amp;&amp;t.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;i.canvas===t?(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.style,</span>s=<span class="cstat-no" title="statement not covered" >t.getAttribute("height"),</span>n=<span class="cstat-no" title="statement not covered" >t.getAttribute("width");<span class="cstat-no" title="statement not covered" ></span>if(t.$chartjs={initial:{height:s,width:n,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||"block",i.boxSizing=i.boxSizing||"border-box",es(n)){const e=<span class="cstat-no" title="statement not covered" >be(t,"width");<span class="cstat-no" title="statement not covered" ></span>void 0!==e&amp;&amp;(t.width=e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(es(s))<span class="cstat-no" title="statement not covered" >if(""===t.style.height)<span class="cstat-no" title="statement not covered" >t.height=t.width/(e||2);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >be(t,"height");<span class="cstat-no" title="statement not covered" ></span>void 0!==e&amp;&amp;(t.height=e)}</span>}</span></span>(t,e),i):null}<span class="fstat-no" title="function not covered" ></span>re</span>leaseContext(t){const e=<span class="cstat-no" title="statement not covered" >t.canvas;<span class="cstat-no" title="statement not covered" ></span>if(!e.$chartjs)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >e.$chartjs.initial;<span class="cstat-no" title="statement not covered" ></span>["height","width"].forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>i(n)?e.removeAttribute(t):e.setAttribute(t,n)}</span>));c</span>onst n=<span class="cstat-no" title="statement not covered" >s.style||{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(n).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.style[t]=n[t]}</span>)),e.width=e.width,delete e.$chartjs,!0}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e,i){<span class="cstat-no" title="statement not covered" >this.removeEventListener(t,e);c</span>onst s=<span class="cstat-no" title="statement not covered" >t.$proxies||(t.$proxies={}),</span>n=<span class="cstat-no" title="statement not covered" >{attach:os,detach:as,resize:cs}[e]||us;<span class="cstat-no" title="statement not covered" ></span>s[e]=n(t,e,i)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEventListener(t,e){const i=<span class="cstat-no" title="statement not covered" >t.$proxies||(t.$proxies={}),</span>s=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >(</span></span>{attach:ds,detach:ds,resize:ds}[e]||ss)(t,e,s),i[e]=void 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tDevicePixelRatio(){<span class="cstat-no" title="statement not covered" >return window.devicePixelRatio}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaximumSize(t,e,i,s){<span class="cstat-no" title="statement not covered" >return ge(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>is</span>Attached(t){const e=<span class="cstat-no" title="statement not covered" >ae(t);<span class="cstat-no" title="statement not covered" ></span>return!(!e||!e.isConnected)}</span>}function <span class="fstat-no" title="function not covered" >gs(</span>t){<span class="cstat-no" title="statement not covered" >return!oe()||"undefined"!=typeof OffscreenCanvas&amp;&amp;t instanceof OffscreenCanvas?Qi:fs}</span>var ps=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,_detectPlatform:gs,BasePlatform:Ji,BasicPlatform:Qi,DomPlatform:fs});</span>const ms=<span class="cstat-no" title="statement not covered" >"transparent",</span>bs=<span class="cstat-no" title="statement not covered" >{boolean:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >i&gt;.5?e:t,<span class="fstat-no" title="function not covered" ></span>co</span>lor(t,e,i){const s=<span class="cstat-no" title="statement not covered" >Jt(t||ms),</span>n=<span class="cstat-no" title="statement not covered" >s.valid&amp;&amp;Jt(e||ms);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;n.valid?n.mix(s,i).hexString():e}</span>,number:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >t+(e-t)*i}</span>;</span>class xs{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>s=bi([t.to,s,n,t.from]);c</span>onst o=<span class="cstat-no" title="statement not covered" >bi([t.from,n,s]);<span class="cstat-no" title="statement not covered" ></span>this._active=!0,this._fn=t.fn||bs[t.type||typeof o],this._easing=si[t.easing]||si.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=s,this._promises=void 0}<span class="fstat-no" title="function not covered" ></span>ac</span>tive(){<span class="cstat-no" title="statement not covered" >return this._active}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){<span class="cstat-no" title="statement not covered" >if(this._active){<span class="cstat-no" title="statement not covered" >this._notify(!1);c</span>onst s=<span class="cstat-no" title="statement not covered" >this._target[this._prop],</span>n=<span class="cstat-no" title="statement not covered" >i-this._start,</span>o=<span class="cstat-no" title="statement not covered" >this._duration-n;<span class="cstat-no" title="statement not covered" ></span>this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=n,this._loop=!!t.loop,this._to=bi([t.to,e,s,t.from]),this._from=bi([t.from,s,e])}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(){<span class="cstat-no" title="statement not covered" >this._active&amp;&amp;(this.tick(Date.now()),this._active=!1,this._notify(!1))}<span class="fstat-no" title="function not covered" ></span>ti</span>ck(t){const e=<span class="cstat-no" title="statement not covered" >t-this._start,</span>i=<span class="cstat-no" title="statement not covered" >this._duration,</span>s=<span class="cstat-no" title="statement not covered" >this._prop,</span>n=<span class="cstat-no" title="statement not covered" >this._from,</span>o=<span class="cstat-no" title="statement not covered" >this._loop,</span>a=<span class="cstat-no" title="statement not covered" >this._to;</span>let r;<span class="cstat-no" title="statement not covered" >if(this._active=n!==a&amp;&amp;(o||e&lt;i),!this._active)<span class="cstat-no" title="statement not covered" >return this._target[s]=a,void this._notify(!0);<span class="cstat-no" title="statement not covered" >e</span></span>&lt;0?this._target[s]=n:(r=e/i%2,r=o&amp;&amp;r&gt;1?2-r:r,r=this._easing(Math.min(1,Math.max(0,r))),this._target[s]=this._fn(n,a,r))}<span class="fstat-no" title="function not covered" ></span>wa</span>it(){const t=<span class="cstat-no" title="statement not covered" >this._promises||(this._promises=[]);<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >t.push({res:e,rej:i})}</span>))}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t){const e=<span class="cstat-no" title="statement not covered" >t?"res":"rej",</span>i=<span class="cstat-no" title="statement not covered" >this._promises||[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;i.length;t++)<span class="cstat-no" title="statement not covered" >i[t][e]()}</span></span>}<span class="cstat-no" title="statement not covered" >ne.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0});c</span>onst _s=<span class="cstat-no" title="statement not covered" >Object.keys(ne.animation);<span class="cstat-no" title="statement not covered" ></span>ne.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"onProgress"!==t&amp;&amp;"onComplete"!==t&amp;&amp;"fn"!==t}</span>),ne.set("animations",{colors:{type:"color",properties:["color","borderColor","backgroundColor"]},numbers:{type:"number",properties:["x","y","borderWidth","radius","tension"]}}),ne.describe("animations",{_fallback:"animation"}),ne.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0|t}</span>}}});c</span>lass ys{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this._chart=t,this._properties=new Map,this.configure(e)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(t){<span class="cstat-no" title="statement not covered" >if(!n(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._properties;<span class="cstat-no" title="statement not covered" ></span>Object.getOwnPropertyNames(t).forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const o=<span class="cstat-no" title="statement not covered" >t[i];<span class="cstat-no" title="statement not covered" ></span>if(!n(o))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const t of _s)<span class="cstat-no" title="statement not covered" >a[t]=o[t];<span class="cstat-no" title="statement not covered" >(</span></span>s(o.properties)&amp;&amp;o.properties||[i]).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t!==i&amp;&amp;e.has(t)||e.set(t,a)}</span>))}</span>))}<span class="fstat-no" title="function not covered" ></span>_a</span>nimateOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >e.options,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >t.options;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return void(t.options=e);<span class="cstat-no" title="statement not covered" >i</span></span>.$shared&amp;&amp;(t.options=i=Object.assign({},i,{$shared:!1,$animations:{}}));<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>(t,i);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._createAnimations(s,i);<span class="cstat-no" title="statement not covered" ></span>return i.$shared&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(e);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;s.length;e++){const n=<span class="cstat-no" title="statement not covered" >t[s[e]];<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.active()&amp;&amp;i.push(n.wait())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Promise.all(i)}</span>(t.options.$animations,i).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.options=i}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{})),n}<span class="fstat-no" title="function not covered" ></span>_c</span>reateAnimations(t,e){const i=<span class="cstat-no" title="statement not covered" >this._properties,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >t.$animations||(t.$animations={}),</span>o=<span class="cstat-no" title="statement not covered" >Object.keys(e),</span>a=<span class="cstat-no" title="statement not covered" >Date.now();</span>let r;<span class="cstat-no" title="statement not covered" >for(r=o.length-1;r&gt;=0;--r){const l=<span class="cstat-no" title="statement not covered" >o[r];<span class="cstat-no" title="statement not covered" ></span>if("$"===l.charAt(0))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f("options"===l){<span class="cstat-no" title="statement not covered" >s.push(...this._animateOptions(t,e));<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst h=<span class="cstat-no" title="statement not covered" >e[l];</span>let c=<span class="cstat-no" title="statement not covered" >n[l];</span>const d=<span class="cstat-no" title="statement not covered" >i.get(l);<span class="cstat-no" title="statement not covered" ></span>if(c){<span class="cstat-no" title="statement not covered" >if(d&amp;&amp;c.active()){<span class="cstat-no" title="statement not covered" >c.update(d,h,a);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>c</span>.cancel()}<span class="cstat-no" title="statement not covered" ></span>d</span>&amp;&amp;d.duration?(n[l]=c=new xs(d,t,l,h),s.push(c)):t[l]=h}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){<span class="cstat-no" title="statement not covered" >if(0===this._properties.size)<span class="cstat-no" title="statement not covered" >return void Object.assign(t,e);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._createAnimations(t,e);<span class="cstat-no" title="statement not covered" ></span>return i.length?(mt.add(this._chart,i),!0):void 0}</span>}function <span class="fstat-no" title="function not covered" >vs(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.options||{},</span>s=<span class="cstat-no" title="statement not covered" >i.reverse,</span>n=<span class="cstat-no" title="statement not covered" >void 0===i.min?e:0,</span>o=<span class="cstat-no" title="statement not covered" >void 0===i.max?e:0;<span class="cstat-no" title="statement not covered" ></span>return{start:s?o:n,end:s?n:o}}</span>function <span class="fstat-no" title="function not covered" >ws(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t._getSortedDatasetMetas(e);</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=s.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >i.push(s[n].index);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Ms(</span>t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const n=<span class="cstat-no" title="statement not covered" >t.keys,</span>a=<span class="cstat-no" title="statement not covered" >"single"===s.mode;</span>let r,l,h,c;<span class="cstat-no" title="statement not covered" >if(null!==e){<span class="cstat-no" title="statement not covered" >for(r=0,l=n.length;r&lt;l;++r){<span class="cstat-no" title="statement not covered" >if(h=+n[r],h===i){<span class="cstat-no" title="statement not covered" >if(s.all)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>c</span>=t.values[h],o(c)&amp;&amp;(a||0===e||z(e)===z(c))&amp;&amp;(e+=c)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>}</span>function <span class="fstat-no" title="function not covered" >ks(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.options.stacked;<span class="cstat-no" title="statement not covered" ></span>return i||void 0===i&amp;&amp;void 0!==e.stack}</span>function <span class="fstat-no" title="function not covered" >Ss(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t[e]||(t[e]={});<span class="cstat-no" title="statement not covered" ></span>return s[i]||(s[i]={})}</span>function <span class="fstat-no" title="function not covered" >Ps(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >for(const n of e.getMatchingVisibleMetas(s).reverse()){const e=<span class="cstat-no" title="statement not covered" >t[n.index];<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;e&gt;0||!i&amp;&amp;e&lt;0)<span class="cstat-no" title="statement not covered" >return n.index}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>function <span class="fstat-no" title="function not covered" >Ds(</span>t,e){const{chart:i,_cachedMeta:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >i._stacks||(i._stacks={}),</span>{iScale:o,vScale:a,index:r}=<span class="cstat-no" title="statement not covered" >s,</span>l=<span class="cstat-no" title="statement not covered" >o.axis,</span>h=<span class="cstat-no" title="statement not covered" >a.axis,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return`${t.id}.${e.id}.${i.stack||i.type}`}</span>(o,a,s),</span>d=<span class="cstat-no" title="statement not covered" >e.length;</span>let u;<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;d;++t){const i=<span class="cstat-no" title="statement not covered" >e[t],</span>{[l]:o,[h]:d}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>u=(i._stacks||(i._stacks={}))[h]=Ss(n,c,o),u[r]=d,u._top=Ps(u,a,!0,s.type),u._bottom=Ps(u,a,!1,s.type)}</span>}</span>function <span class="fstat-no" title="function not covered" >Os(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.scales;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(i).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >i[t].axis===e)</span>).shift()}</span>function <span class="fstat-no" title="function not covered" >Cs(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.controller.index,</span>s=<span class="cstat-no" title="statement not covered" >t.vScale&amp;&amp;t.vScale.axis;<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >e=e||t._parsed;<span class="cstat-no" title="statement not covered" >f</span>or(const t of e){const e=<span class="cstat-no" title="statement not covered" >t._stacks;<span class="cstat-no" title="statement not covered" ></span>if(!e||void 0===e[s]||void 0===e[s][i])<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >d</span></span>elete e[s][i]}</span>}</span>}</span>const As=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"reset"===t||"none"===t,</span></span>Ts=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e?t:Object.assign({},t);</span></span>class Ls{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.initialize()}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.configure(),this.linkScales(),t._stacked=ks(t.vScale,t),this.addElements()}<span class="fstat-no" title="function not covered" ></span>up</span>dateIndex(t){<span class="cstat-no" title="statement not covered" >this.index!==t&amp;&amp;Cs(this._cachedMeta),this.index=t}<span class="fstat-no" title="function not covered" ></span>li</span>nkScales(){const t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.getDataset(),</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >"x"===t?e:"r"===t?s:i,</span></span>n=<span class="cstat-no" title="statement not covered" >e.xAxisID=r(i.xAxisID,Os(t,"x")),</span>o=<span class="cstat-no" title="statement not covered" >e.yAxisID=r(i.yAxisID,Os(t,"y")),</span>a=<span class="cstat-no" title="statement not covered" >e.rAxisID=r(i.rAxisID,Os(t,"r")),</span>l=<span class="cstat-no" title="statement not covered" >e.indexAxis,</span>h=<span class="cstat-no" title="statement not covered" >e.iAxisID=s(l,n,o,a),</span>c=<span class="cstat-no" title="statement not covered" >e.vAxisID=s(l,o,n,a);<span class="cstat-no" title="statement not covered" ></span>e.xScale=this.getScaleForId(n),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(h),e.vScale=this.getScaleForId(c)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataset(){<span class="cstat-no" title="statement not covered" >return this.chart.data.datasets[this.index]}<span class="fstat-no" title="function not covered" ></span>ge</span>tMeta(){<span class="cstat-no" title="statement not covered" >return this.chart.getDatasetMeta(this.index)}<span class="fstat-no" title="function not covered" ></span>ge</span>tScaleForId(t){<span class="cstat-no" title="statement not covered" >return this.chart.scales[t]}<span class="fstat-no" title="function not covered" ></span>_g</span>etOtherScale(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>return t===e.iScale?e.vScale:e.iScale}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._update("reset")}<span class="fstat-no" title="function not covered" ></span>_d</span>estroy(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._data&amp;&amp;at(this._data,this),t._stacked&amp;&amp;Cs(t)}<span class="fstat-no" title="function not covered" ></span>_d</span>ataCheck(){const t=<span class="cstat-no" title="statement not covered" >this.getDataset(),</span>e=<span class="cstat-no" title="statement not covered" >t.data||(t.data=[]),</span>i=<span class="cstat-no" title="statement not covered" >this._data;<span class="cstat-no" title="statement not covered" ></span>if(n(e))<span class="cstat-no" title="statement not covered" >this._data=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >Object.keys(t),</span>i=<span class="cstat-no" title="statement not covered" >new Array(e.length);</span>let s,n,o;<span class="cstat-no" title="statement not covered" >for(s=0,n=e.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o=e[s],i[s]={x:o,y:t[o]};<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>(e);e</span>lse <span class="cstat-no" title="statement not covered" >if(i!==e){<span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >at(i,this);c</span>onst t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>Cs(t),t._parsed=[]}<span class="cstat-no" title="statement not covered" ></span>e</span>&amp;&amp;Object.isExtensible(e)&amp;&amp;ot(e,this),this._syncList=[],this._data=e}</span>}<span class="fstat-no" title="function not covered" ></span></span>ad</span>dElements(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._dataCheck(),this.datasetElementType&amp;&amp;(t.dataset=new this.datasetElementType)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateElements(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.getDataset();</span>let s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>this._dataCheck();c</span>onst n=<span class="cstat-no" title="statement not covered" >e._stacked;<span class="cstat-no" title="statement not covered" ></span>e._stacked=ks(e.vScale,e),e.stack!==i.stack&amp;&amp;(s=!0,Cs(e),e.stack=i.stack),this._resyncElements(t),(s||n!==e._stacked)&amp;&amp;Ds(this,e._parsed)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>e=<span class="cstat-no" title="statement not covered" >t.datasetScopeKeys(this._type),</span>i=<span class="cstat-no" title="statement not covered" >t.getOptionScopes(this.getDataset(),e,!0);<span class="cstat-no" title="statement not covered" ></span>this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){const{_cachedMeta:i,_data:o}=<span class="cstat-no" title="statement not covered" >this,</span>{iScale:a,_stacked:r}=<span class="cstat-no" title="statement not covered" >i,</span>l=<span class="cstat-no" title="statement not covered" >a.axis;</span>let h,c,d,u=<span class="cstat-no" title="statement not covered" >0===t&amp;&amp;e===o.length||i._sorted,</span>f=<span class="cstat-no" title="statement not covered" >t&gt;0&amp;&amp;i._parsed[t-1];<span class="cstat-no" title="statement not covered" ></span>if(!1===this._parsing)<span class="cstat-no" title="statement not covered" >i._parsed=o,i._sorted=!0,d=o;e</span>lse{<span class="cstat-no" title="statement not covered" >d=s(o[t])?this.parseArrayData(i,o,t,e):n(o[t])?this.parseObjectData(i,o,t,e):this.parsePrimitiveData(i,o,t,e);c</span>onst a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null===c[l]||f&amp;&amp;c[l]&lt;f[l];<span class="cstat-no" title="statement not covered" ></span></span>for(h=0;h&lt;e;++h)<span class="cstat-no" title="statement not covered" >i._parsed[h+t]=c=d[h],u&amp;&amp;(a()&amp;&amp;(u=!1),f=c);<span class="cstat-no" title="statement not covered" >i</span></span>._sorted=u}<span class="cstat-no" title="statement not covered" ></span>r</span>&amp;&amp;Ds(this,d)}<span class="fstat-no" title="function not covered" ></span>pa</span>rsePrimitiveData(t,e,i,s){const{iScale:n,vScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >n.axis,</span>r=<span class="cstat-no" title="statement not covered" >o.axis,</span>l=<span class="cstat-no" title="statement not covered" >n.getLabels(),</span>h=<span class="cstat-no" title="statement not covered" >n===o,</span>c=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let d,u,f;<span class="cstat-no" title="statement not covered" >for(d=0,u=s;d&lt;u;++d)<span class="cstat-no" title="statement not covered" >f=d+i,c[d]={[a]:h||n.parse(l[f],f),[r]:o.parse(e[f],f)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn c}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){const{xScale:n,yScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let r,l,h,c;<span class="cstat-no" title="statement not covered" >for(r=0,l=s;r&lt;l;++r)<span class="cstat-no" title="statement not covered" >h=r+i,c=e[h],a[r]={x:n.parse(c[0],h),y:o.parse(c[1],h)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){const{xScale:n,yScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>{xAxisKey:a=<span class="branch-0 cbranch-no" title="branch not covered" >"x",</span>yAxisKey:r=<span class="branch-0 cbranch-no" title="branch not covered" >"y"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>l=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let h,c,d,u;<span class="cstat-no" title="statement not covered" >for(h=0,c=s;h&lt;c;++h)<span class="cstat-no" title="statement not covered" >d=h+i,u=e[d],l[h]={x:n.parse(y(u,a),d),y:o.parse(y(u,r),d)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}<span class="fstat-no" title="function not covered" ></span>ge</span>tParsed(t){<span class="cstat-no" title="statement not covered" >return this._cachedMeta._parsed[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataElement(t){<span class="cstat-no" title="statement not covered" >return this._cachedMeta.data[t]}<span class="fstat-no" title="function not covered" ></span>ap</span>plyStack(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>o=<span class="cstat-no" title="statement not covered" >e[t.axis];<span class="cstat-no" title="statement not covered" ></span>return Ms({keys:ws(s,!0),values:e._stacks[t.axis]},o,n.index,{mode:i})}<span class="fstat-no" title="function not covered" ></span>up</span>dateRangeFromParsed(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i[e.axis];</span>let o=<span class="cstat-no" title="statement not covered" >null===n?NaN:n;</span>const a=<span class="cstat-no" title="statement not covered" >s&amp;&amp;i._stacks[e.axis];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;a&amp;&amp;(s.values=a,o=Ms(s,n,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(t,e){const i=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>s=<span class="cstat-no" title="statement not covered" >i._parsed,</span>n=<span class="cstat-no" title="statement not covered" >i._sorted&amp;&amp;t===i.iScale,</span>a=<span class="cstat-no" title="statement not covered" >s.length,</span>r=<span class="cstat-no" title="statement not covered" >this._getOtherScale(t),</span>l=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;!e.hidden&amp;&amp;e._stacked&amp;&amp;{keys:ws(i,!0),values:null})</span>(e,i,this.chart),</span>h=<span class="cstat-no" title="statement not covered" >{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},</span>{min:c,max:d}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const{min:e,max:i,minDefined:s,maxDefined:n}=<span class="cstat-no" title="statement not covered" >t.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>return{min:s?e:Number.NEGATIVE_INFINITY,max:n?i:Number.POSITIVE_INFINITY}}</span>(r);</span>let u,f;function <span class="fstat-no" title="function not covered" >g(</span>){<span class="cstat-no" title="statement not covered" >f=s[u];c</span>onst e=<span class="cstat-no" title="statement not covered" >f[r.axis];<span class="cstat-no" title="statement not covered" ></span>return!o(f[t.axis])||c&gt;e||d&lt;e}<span class="cstat-no" title="statement not covered" ></span>for(u=0;u&lt;a&amp;&amp;(g()||(this.updateRangeFromParsed(h,t,f,l),!n));++u);<span class="cstat-no" title="statement not covered" >i</span>f(n)<span class="cstat-no" title="statement not covered" >for(u=a-1;u&gt;=0;--u)<span class="cstat-no" title="statement not covered" >if(!g()){<span class="cstat-no" title="statement not covered" >this.updateRangeFromParsed(h,t,f,l);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn h}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllParsedValues(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta._parsed,</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s,n,a;<span class="cstat-no" title="statement not covered" >for(s=0,n=e.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >a=e[s][t.axis],o(a)&amp;&amp;i.push(a);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.iScale,</span>s=<span class="cstat-no" title="statement not covered" >e.vScale,</span>n=<span class="cstat-no" title="statement not covered" >this.getParsed(t);<span class="cstat-no" title="statement not covered" ></span>return{label:i?""+i.getLabelForValue(n[i.axis]):"",value:s?""+s.getLabelForValue(n[s.axis]):""}}<span class="fstat-no" title="function not covered" ></span>_u</span>pdate(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.update(t||"default"),e._clip=<span class="fstat-no" title="function not covered" >fu</span>nction(t){let e,i,s,o;<span class="cstat-no" title="statement not covered" >return n(t)?(e=t.top,i=t.right,s=t.bottom,o=t.left):e=i=s=o=t,{top:e,right:i,bottom:s,left:o,disabled:!1===t}}</span>(r(this.options.clip,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if(!1===i)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >vs(t,i),</span>n=<span class="cstat-no" title="statement not covered" >vs(e,i);<span class="cstat-no" title="statement not covered" ></span>return{top:n.end,right:s.end,bottom:n.start,left:s.start}}</span>(e.xScale,e.yScale,this.getMaxOverflow())))}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){}<span class="fstat-no" title="function not covered" >dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>s=<span class="cstat-no" title="statement not covered" >i.data||[],</span>n=<span class="cstat-no" title="statement not covered" >e.chartArea,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >this._drawStart||0,</span>r=<span class="cstat-no" title="statement not covered" >this._drawCount||s.length-a,</span>l=<span class="cstat-no" title="statement not covered" >this.options.drawActiveElementsOnTop;</span>let h;<span class="cstat-no" title="statement not covered" >for(i.dataset&amp;&amp;i.dataset.draw(t,n,a,r),h=a;h&lt;a+r;++h){const e=<span class="cstat-no" title="statement not covered" >s[h];<span class="cstat-no" title="statement not covered" ></span>e.hidden||(e.active&amp;&amp;l?o.push(e):e.draw(t,n))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(h=0;h&lt;o.length;++h)<span class="cstat-no" title="statement not covered" >o[h].draw(t,n)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tStyle(t,e){const i=<span class="cstat-no" title="statement not covered" >e?"active":"default";<span class="cstat-no" title="statement not covered" ></span>return void 0===t&amp;&amp;this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.getDataset();</span>let n;<span class="cstat-no" title="statement not covered" >if(t&gt;=0&amp;&amp;t&lt;this._cachedMeta.data.length){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data[t];<span class="cstat-no" title="statement not covered" ></span>n=e.$context||(e.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return _i(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:i,index:e,mode:"default",type:"data"})}</span>(this.getContext(),t,e)),n.parsed=this.getParsed(t),n.raw=s.data[t],n.index=n.dataIndex=t}</span>else <span class="cstat-no" title="statement not covered" >n=this.$context||(this.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return _i(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}</span>(this.chart.getContext(),this.index)),n.dataset=s,n.index=n.datasetIndex=this.index;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.active=!!e,n.mode=i,n}<span class="fstat-no" title="function not covered" ></span>re</span>solveDatasetElementOptions(t){<span class="cstat-no" title="statement not covered" >return this._resolveElementOptions(this.datasetElementType.id,t)}<span class="fstat-no" title="function not covered" ></span>re</span>solveDataElementOptions(t,e){<span class="cstat-no" title="statement not covered" >return this._resolveElementOptions(this.dataElementType.id,e,t)}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveElementOptions(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"default",</span>i){const s=<span class="cstat-no" title="statement not covered" >"active"===e,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedDataOpts,</span>o=<span class="cstat-no" title="statement not covered" >t+"-"+e,</span>a=<span class="cstat-no" title="statement not covered" >n[o],</span>r=<span class="cstat-no" title="statement not covered" >this.enableOptionSharing&amp;&amp;M(i);<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return Ts(a,r);c</span></span>onst l=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>h=<span class="cstat-no" title="statement not covered" >l.datasetElementScopeKeys(this._type,t),</span>c=<span class="cstat-no" title="statement not covered" >s?[`${t}Hover`,"hover",t,""]:[t,""],</span>d=<span class="cstat-no" title="statement not covered" >l.getOptionScopes(this.getDataset(),h),</span>u=<span class="cstat-no" title="statement not covered" >Object.keys(ne.elements[t]),</span>f=<span class="cstat-no" title="statement not covered" >l.resolveNamedOptions(d,u,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.getContext(i,s))</span>,c);<span class="cstat-no" title="statement not covered" ></span>return f.$shared&amp;&amp;(f.$shared=r,n[o]=Object.freeze(Ts(f,r))),f}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveAnimations(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedDataOpts,</span>o=<span class="cstat-no" title="statement not covered" >`animation-${e}`,</span>a=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return a;l</span></span>et r;<span class="cstat-no" title="statement not covered" >if(!1!==s.options.animation){const s=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>n=<span class="cstat-no" title="statement not covered" >s.datasetAnimationScopeKeys(this._type,e),</span>o=<span class="cstat-no" title="statement not covered" >s.getOptionScopes(this.getDataset(),n);<span class="cstat-no" title="statement not covered" ></span>r=s.createResolver(o,this.getContext(t,i,e))}</span>c</span>onst l=<span class="cstat-no" title="statement not covered" >new ys(s,r&amp;&amp;r.animations);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;r._cacheable&amp;&amp;(n[o]=Object.freeze(l)),l}<span class="fstat-no" title="function not covered" ></span>ge</span>tSharedOptions(t){<span class="cstat-no" title="statement not covered" >if(t.$shared)<span class="cstat-no" title="statement not covered" >return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}<span class="fstat-no" title="function not covered" ></span></span>in</span>cludeOptions(t,e){<span class="cstat-no" title="statement not covered" >return!e||As(t)||this.chart._animationsDisabled}<span class="fstat-no" title="function not covered" ></span>_g</span>etSharedOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(t,e),</span>s=<span class="cstat-no" title="statement not covered" >this._sharedOptions,</span>n=<span class="cstat-no" title="statement not covered" >this.getSharedOptions(i),</span>o=<span class="cstat-no" title="statement not covered" >this.includeOptions(e,n)||n!==s;<span class="cstat-no" title="statement not covered" ></span>return this.updateSharedOptions(n,e,i),{sharedOptions:n,includeOptions:o}}<span class="fstat-no" title="function not covered" ></span>up</span>dateElement(t,e,i,s){<span class="cstat-no" title="statement not covered" >As(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}<span class="fstat-no" title="function not covered" ></span>up</span>dateSharedOptions(t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;!As(e)&amp;&amp;this._resolveAnimations(void 0,e).update(t,i)}<span class="fstat-no" title="function not covered" ></span>_s</span>etStyle(t,e,i,s){<span class="cstat-no" title="statement not covered" >t.active=s;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.getStyle(e,s);<span class="cstat-no" title="statement not covered" ></span>this._resolveAnimations(e,i,s).update(t,{options:!s&amp;&amp;this.getSharedOptions(n)||n})}<span class="fstat-no" title="function not covered" ></span>re</span>moveHoverStyle(t,e,i){<span class="cstat-no" title="statement not covered" >this._setStyle(t,i,"active",!1)}<span class="fstat-no" title="function not covered" ></span>se</span>tHoverStyle(t,e,i){<span class="cstat-no" title="statement not covered" >this._setStyle(t,i,"active",!0)}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveDatasetHoverStyle(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.dataset;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;this._setStyle(t,void 0,"active",!1)}<span class="fstat-no" title="function not covered" ></span>_s</span>etDatasetHoverStyle(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.dataset;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;this._setStyle(t,void 0,"active",!0)}<span class="fstat-no" title="function not covered" ></span>_r</span>esyncElements(t){const e=<span class="cstat-no" title="statement not covered" >this._data,</span>i=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;<span class="cstat-no" title="statement not covered" ></span>for(const[t,e,i]of this._syncList)<span class="cstat-no" title="statement not covered" >this[t](e,i);<span class="cstat-no" title="statement not covered" >t</span></span>his._syncList=[];c</span>onst s=<span class="cstat-no" title="statement not covered" >i.length,</span>n=<span class="cstat-no" title="statement not covered" >e.length,</span>o=<span class="cstat-no" title="statement not covered" >Math.min(n,s);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;this.parse(0,o),n&gt;s?this._insertElements(s,n-s,t):n&lt;s&amp;&amp;this._removeElements(n,s-n)}<span class="fstat-no" title="function not covered" ></span>_i</span>nsertElements(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >s.data,</span>o=<span class="cstat-no" title="statement not covered" >t+e;</span>let a;const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(t.length+=e,a=t.length-1;a&gt;=o;a--)<span class="cstat-no" title="statement not covered" >t[a]=t[a-e]}</span></span>;<span class="cstat-no" title="statement not covered" ></span>for(r(n),a=t;a&lt;o;++a)<span class="cstat-no" title="statement not covered" >n[a]=new this.dataElementType;<span class="cstat-no" title="statement not covered" >t</span></span>his._parsing&amp;&amp;r(s._parsed),this.parse(t,e),i&amp;&amp;this.updateElements(n,t,e,"reset")}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){}<span class="fstat-no" title="function not covered" >_r</span>emoveElements(t,e){const i=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>if(this._parsing){const s=<span class="cstat-no" title="statement not covered" >i._parsed.splice(t,e);<span class="cstat-no" title="statement not covered" ></span>i._stacked&amp;&amp;Cs(i,s)}<span class="cstat-no" title="statement not covered" ></span>i</span>.data.splice(t,e)}<span class="fstat-no" title="function not covered" ></span>_s</span>ync(t){<span class="cstat-no" title="statement not covered" >if(this._parsing)<span class="cstat-no" title="statement not covered" >this._syncList.push(t);e</span>lse{const[e,i,s]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>this[e](i,s)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.chart._dataChanges.push([this.index,...t])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataPush(){const t=<span class="cstat-no" title="statement not covered" >arguments.length;<span class="cstat-no" title="statement not covered" ></span>this._sync(["_insertElements",this.getDataset().data.length-t,t])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataPop(){<span class="cstat-no" title="statement not covered" >this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataShift(){<span class="cstat-no" title="statement not covered" >this._sync(["_removeElements",0,1])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataSplice(t,e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;this._sync(["_removeElements",t,e]);c</span>onst i=<span class="cstat-no" title="statement not covered" >arguments.length-2;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;this._sync(["_insertElements",t,i])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataUnshift(){<span class="cstat-no" title="statement not covered" >this._sync(["_insertElements",0,arguments.length])}</span>}<span class="cstat-no" title="statement not covered" >Ls.defaults={},Ls.prototype.datasetElementType=null,Ls.prototype.dataElementType=null;c</span>lass Es{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.x=void 0,this.y=void 0,this.active=!1,this.options=void 0,this.$animations=void 0}<span class="fstat-no" title="function not covered" ></span>to</span>oltipPosition(t){const{x:e,y:i}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:e,y:i}}<span class="fstat-no" title="function not covered" ></span>ha</span>sValue(){<span class="cstat-no" title="statement not covered" >return B(this.x)&amp;&amp;B(this.y)}<span class="fstat-no" title="function not covered" ></span>ge</span>tProps(t,e){const i=<span class="cstat-no" title="statement not covered" >this.$animations;<span class="cstat-no" title="statement not covered" ></span>if(!e||!i)<span class="cstat-no" title="statement not covered" >return this;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s[t]=i[t]&amp;&amp;i[t].active()?i[t]._to:this[t]}</span>)),s}</span>}<span class="cstat-no" title="statement not covered" >Es.defaults={},Es.defaultRoutes=void 0;c</span>onst Rs=<span class="cstat-no" title="statement not covered" >{values:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >s(t)?t:""+t,<span class="fstat-no" title="function not covered" ></span>nu</span>meric(t,e,i){<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >return"0";c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.chart.options.locale;</span>let n,o=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(i.length&gt;1){const e=<span class="cstat-no" title="statement not covered" >Math.max(Math.abs(i[0].value),Math.abs(i[i.length-1].value));<span class="cstat-no" title="statement not covered" ></span>(e&lt;1e-4||e&gt;1e15)&amp;&amp;(n="scientific"),o=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >e.length&gt;3?e[2].value-e[1].value:e[1].value-e[0].value;<span class="cstat-no" title="statement not covered" ></span>Math.abs(i)&gt;=1&amp;&amp;t!==Math.floor(t)&amp;&amp;(i=t-Math.floor(t));<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>(t,i)}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >I(Math.abs(o)),</span>r=<span class="cstat-no" title="statement not covered" >Math.max(Math.min(-1*Math.floor(a),20),0),</span>l=<span class="cstat-no" title="statement not covered" >{notation:n,minimumFractionDigits:r,maximumFractionDigits:r};<span class="cstat-no" title="statement not covered" ></span>return Object.assign(l,this.options.ticks.format),li(t,s,l)}</span>,<span class="fstat-no" title="function not covered" >lo</span>garithmic(t,e,i){<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >return"0";c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t/Math.pow(10,Math.floor(I(t)));<span class="cstat-no" title="statement not covered" ></span>return 1===s||2===s||5===s?Rs.numeric.call(this,t,e,i):""}</span>};</span>var Is=<span class="cstat-no" title="statement not covered" >{formatters:Rs};</span>function <span class="fstat-no" title="function not covered" >zs(</span>t,e){const s=<span class="cstat-no" title="statement not covered" >t.options.ticks,</span>n=<span class="cstat-no" title="statement not covered" >s.maxTicksLimit||<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.options.offset,</span>i=<span class="cstat-no" title="statement not covered" >t._tickSize(),</span>s=<span class="cstat-no" title="statement not covered" >t._length/i+(e?0:1),</span>n=<span class="cstat-no" title="statement not covered" >t._maxLength/i;<span class="cstat-no" title="statement not covered" ></span>return Math.floor(Math.min(s,n))}</span>(t),</span>o=<span class="cstat-no" title="statement not covered" >s.major.enabled?<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let i,s;<span class="cstat-no" title="statement not covered" >for(i=0,s=t.length;i&lt;s;i++)<span class="cstat-no" title="statement not covered" >t[i].major&amp;&amp;e.push(i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(e):[],</span>a=<span class="cstat-no" title="statement not covered" >o.length,</span>r=<span class="cstat-no" title="statement not covered" >o[0],</span>l=<span class="cstat-no" title="statement not covered" >o[a-1],</span>h=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(a&gt;n)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n,o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >i[0];<span class="cstat-no" title="statement not covered" ></span>for(s=Math.ceil(s),n=0;n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >n===a&amp;&amp;(e.push(t[n]),o++,a=i[o*s])}</span></span>(e,h,o,a/n),h;c</span></span>onst c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.length;</span>let i,s;<span class="cstat-no" title="statement not covered" >if(e&lt;2)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=t[0],i=1;i&lt;e;++i)<span class="cstat-no" title="statement not covered" >if(t[i]-t[i-1]!==s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn s}</span>(t),</span>n=<span class="cstat-no" title="statement not covered" >e.length/i;<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return Math.max(n,1);c</span></span>onst o=<span class="cstat-no" title="statement not covered" >V(s);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >o.length-1;</span>t&lt;e;t++){const e=<span class="cstat-no" title="statement not covered" >o[t];<span class="cstat-no" title="statement not covered" ></span>if(e&gt;n)<span class="cstat-no" title="statement not covered" >return e}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn Math.max(n,1)}</span>(o,e,n);<span class="cstat-no" title="statement not covered" ></span>if(a&gt;0){let t,s;const n=<span class="cstat-no" title="statement not covered" >a&gt;1?Math.round((l-r)/(a-1)):null;<span class="cstat-no" title="statement not covered" ></span>for(Fs(e,h,c,i(n)?0:r-n,r),t=0,s=a-1;t&lt;s;t++)<span class="cstat-no" title="statement not covered" >Fs(e,h,c,o[t],o[t+1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Fs(e,h,c,l,i(n)?e.length:l+n),h}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Fs(e,h,c),h}</span>function <span class="fstat-no" title="function not covered" >Fs(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >r(s,0),</span>a=<span class="cstat-no" title="statement not covered" >Math.min(r(n,t.length),t.length);</span>let l,h,c,d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(i=Math.ceil(i),n&amp;&amp;(l=n-s,i=l/Math.floor(l/i)),c=o;c&lt;0;)<span class="cstat-no" title="statement not covered" >d++,c=Math.round(o+d*i);<span class="cstat-no" title="statement not covered" >f</span></span>or(h=Math.max(o,0);h&lt;a;h++)<span class="cstat-no" title="statement not covered" >h===c&amp;&amp;(e.push(t[h]),d++,c=Math.round(o+d*i))}<span class="cstat-no" title="statement not covered" ></span></span>ne.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",grace:0,grid:{display:!0,lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.lineWidth,</span>tickColor:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.color,</span>offset:!1,borderDash:[],borderDashOffset:0,borderWidth:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:Is.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),ne.route("scale.ticks","color","","color"),ne.route("scale.grid","color","","borderColor"),ne.route("scale.grid","borderColor","","borderColor"),ne.route("scale.title","color","","color"),ne.describe("scale",{_fallback:!1,_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("before")&amp;&amp;!t.startsWith("after")&amp;&amp;"callback"!==t&amp;&amp;"parser"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t&amp;&amp;"tickBorderDash"!==t}</span>),ne.describe("scales",{_fallback:"scale"}),ne.describe("scale.ticks",{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"backdropPadding"!==t&amp;&amp;"callback"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"backdropPadding"!==t}</span>);c</span>onst Vs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >"top"===e||"left"===e?t[e]+i:t[e]-i;</span></span>function <span class="fstat-no" title="function not covered" >Bs(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.length/e,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>let o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;o&lt;n;o+=s)<span class="cstat-no" title="statement not covered" >i.push(t[Math.floor(o)]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Ns(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.ticks.length,</span>n=<span class="cstat-no" title="statement not covered" >Math.min(e,s-1),</span>o=<span class="cstat-no" title="statement not covered" >t._startPixel,</span>a=<span class="cstat-no" title="statement not covered" >t._endPixel,</span>r=<span class="cstat-no" title="statement not covered" >1e-6;</span>let l,h=<span class="cstat-no" title="statement not covered" >t.getPixelForTick(n);<span class="cstat-no" title="statement not covered" ></span>if(!(i&amp;&amp;(l=1===s?Math.max(h-o,a-h):0===e?(t.getPixelForTick(1)-h)/2:(h-t.getPixelForTick(n-1))/2,h+=n&lt;e?l:-l,h&lt;o-r||h&gt;a+r)))<span class="cstat-no" title="statement not covered" >return h}</span></span>function <span class="fstat-no" title="function not covered" >Ws(</span>t){<span class="cstat-no" title="statement not covered" >return t.drawTicks?t.tickLength:0}</span>function <span class="fstat-no" title="function not covered" >js(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!t.display)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >mi(t.font,e),</span>n=<span class="cstat-no" title="statement not covered" >pi(t.padding);<span class="cstat-no" title="statement not covered" ></span>return(s(t.text)?t.text.length:1)*i.lineHeight+n.height}</span>function <span class="fstat-no" title="function not covered" >Hs(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >dt(t);<span class="cstat-no" title="statement not covered" ></span>return(i&amp;&amp;"right"!==e||!i&amp;&amp;"right"===e)&amp;&amp;(s=(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"left"===t?"right":"right"===t?"left":t)</span>(s)),s}</span>class $s extends Es{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>it(t){<span class="cstat-no" title="statement not covered" >this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return t}<span class="fstat-no" title="function not covered" ></span>ge</span>tUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t=a(t,Number.POSITIVE_INFINITY),e=a(e,Number.NEGATIVE_INFINITY),i=a(i,Number.POSITIVE_INFINITY),s=a(s,Number.NEGATIVE_INFINITY),{min:a(t,i),max:a(e,s),minDefined:o(t),maxDefined:o(e)}}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(t){let e,{min:i,max:s,minDefined:n,maxDefined:o}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;o)<span class="cstat-no" title="statement not covered" >return{min:i,max:s};c</span></span>onst r=<span class="cstat-no" title="statement not covered" >this.getMatchingVisibleMetas();<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >r.length;</span>a&lt;l;++a)<span class="cstat-no" title="statement not covered" >e=r[a].controller.getMinMax(this,t),n||(i=Math.min(i,e.min)),o||(s=Math.max(s,e.max));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i=o&amp;&amp;i&gt;s?s:i,s=n&amp;&amp;i&gt;s?i:s,{min:a(i,a(s,i)),max:a(s,a(i,s))}}<span class="fstat-no" title="function not covered" ></span>ge</span>tPadding(){<span class="cstat-no" title="statement not covered" >return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}<span class="fstat-no" title="function not covered" ></span>ge</span>tTicks(){<span class="cstat-no" title="statement not covered" >return this.ticks}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabels(){const t=<span class="cstat-no" title="statement not covered" >this.chart.data;<span class="cstat-no" title="statement not covered" ></span>return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}<span class="fstat-no" title="function not covered" ></span>be</span>foreLayout(){<span class="cstat-no" title="statement not covered" >this._cache={},this._dataLimitsCached=!1}<span class="fstat-no" title="function not covered" ></span>be</span>foreUpdate(){<span class="cstat-no" title="statement not covered" >c(this.options.beforeUpdate,[this])}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){const{beginAtZero:s,grace:n,ticks:o}=<span class="cstat-no" title="statement not covered" >this.options,</span>a=<span class="cstat-no" title="statement not covered" >o.sampleSize;<span class="cstat-no" title="statement not covered" ></span>this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=xi(this,n,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();c</span>onst r=<span class="cstat-no" title="statement not covered" >a&lt;this.ticks.length;<span class="cstat-no" title="statement not covered" ></span>this._convertTicksToLabels(r?Bs(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&amp;&amp;(o.autoSkip||"auto"===o.source)&amp;&amp;(this.ticks=zs(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),r&amp;&amp;this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){let t,e,i=<span class="cstat-no" title="statement not covered" >this.options.reverse;<span class="cstat-no" title="statement not covered" ></span>this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,i=!i),this._startPixel=t,this._endPixel=e,this._reversePixels=i,this._length=e-t,this._alignToPixels=this.options.alignToPixels}<span class="fstat-no" title="function not covered" ></span>af</span>terUpdate(){<span class="cstat-no" title="statement not covered" >c(this.options.afterUpdate,[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreSetDimensions(){<span class="cstat-no" title="statement not covered" >c(this.options.beforeSetDimensions,[this])}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}<span class="fstat-no" title="function not covered" ></span>af</span>terSetDimensions(){<span class="cstat-no" title="statement not covered" >c(this.options.afterSetDimensions,[this])}<span class="fstat-no" title="function not covered" ></span>_c</span>allHooks(t){<span class="cstat-no" title="statement not covered" >this.chart.notifyPlugins(t,this.getContext()),c(this.options[t],[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreDataLimits(){<span class="cstat-no" title="statement not covered" >this._callHooks("beforeDataLimits")}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){}<span class="fstat-no" title="function not covered" >af</span>terDataLimits(){<span class="cstat-no" title="statement not covered" >this._callHooks("afterDataLimits")}<span class="fstat-no" title="function not covered" ></span>be</span>foreBuildTicks(){<span class="cstat-no" title="statement not covered" >this._callHooks("beforeBuildTicks")}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){<span class="cstat-no" title="statement not covered" >return[]}<span class="fstat-no" title="function not covered" ></span>af</span>terBuildTicks(){<span class="cstat-no" title="statement not covered" >this._callHooks("afterBuildTicks")}<span class="fstat-no" title="function not covered" ></span>be</span>foreTickToLabelConversion(){<span class="cstat-no" title="statement not covered" >c(this.options.beforeTickToLabelConversion,[this])}<span class="fstat-no" title="function not covered" ></span>ge</span>nerateTickLabels(t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks;</span>let i,s,n;<span class="cstat-no" title="statement not covered" >for(i=0,s=t.length;i&lt;s;i++)<span class="cstat-no" title="statement not covered" >n=t[i],n.label=c(e.callback,[n.value,i,t],this)}<span class="fstat-no" title="function not covered" ></span></span>af</span>terTickToLabelConversion(){<span class="cstat-no" title="statement not covered" >c(this.options.afterTickToLabelConversion,[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreCalculateLabelRotation(){<span class="cstat-no" title="statement not covered" >c(this.options.beforeCalculateLabelRotation,[this])}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateLabelRotation(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks,</span>i=<span class="cstat-no" title="statement not covered" >this.ticks.length,</span>s=<span class="cstat-no" title="statement not covered" >e.minRotation||0,</span>n=<span class="cstat-no" title="statement not covered" >e.maxRotation;</span>let o,a,r,l=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(!this._isVisible()||!e.display||s&gt;=n||i&lt;=1||!this.isHorizontal())<span class="cstat-no" title="statement not covered" >return void(this.labelRotation=s);c</span></span>onst h=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>c=<span class="cstat-no" title="statement not covered" >h.widest.width,</span>d=<span class="cstat-no" title="statement not covered" >h.highest.height,</span>u=<span class="cstat-no" title="statement not covered" >Z(this.chart.width-c,0,this.maxWidth);<span class="cstat-no" title="statement not covered" ></span>o=t.offset?this.maxWidth/i:u/(i-1),c+6&gt;o&amp;&amp;(o=u/(i-(t.offset?.5:1)),a=this.maxHeight-Ws(t.grid)-e.padding-js(t.title,this.chart.options.font),r=Math.sqrt(c*c+d*d),l=$(Math.min(Math.asin(Z((h.highest.height+6)/o,-1,1)),Math.asin(Z(a/r,-1,1))-Math.asin(Z(d/r,-1,1)))),l=Math.max(s,Math.min(n,l))),this.labelRotation=l}<span class="fstat-no" title="function not covered" ></span>af</span>terCalculateLabelRotation(){<span class="cstat-no" title="statement not covered" >c(this.options.afterCalculateLabelRotation,[this])}<span class="fstat-no" title="function not covered" ></span>af</span>terAutoSkip(){}<span class="fstat-no" title="function not covered" >be</span>foreFit(){<span class="cstat-no" title="statement not covered" >c(this.options.beforeFit,[this])}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const t=<span class="cstat-no" title="statement not covered" >{width:0,height:0},</span>{chart:e,options:{ticks:i,title:s,grid:n}}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >this._isVisible(),</span>a=<span class="cstat-no" title="statement not covered" >this.isHorizontal();<span class="cstat-no" title="statement not covered" ></span>if(o){const o=<span class="cstat-no" title="statement not covered" >js(s,e.options.font);<span class="cstat-no" title="statement not covered" ></span>if(a?(t.width=this.maxWidth,t.height=Ws(n)+o):(t.height=this.maxHeight,t.width=Ws(n)+o),i.display&amp;&amp;this.ticks.length){const{first:e,last:s,widest:n,highest:o}=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>r=<span class="cstat-no" title="statement not covered" >2*i.padding,</span>l=<span class="cstat-no" title="statement not covered" >H(this.labelRotation),</span>h=<span class="cstat-no" title="statement not covered" >Math.cos(l),</span>c=<span class="cstat-no" title="statement not covered" >Math.sin(l);<span class="cstat-no" title="statement not covered" ></span>if(a){const e=<span class="cstat-no" title="statement not covered" >i.mirror?0:c*n.width+h*o.height;<span class="cstat-no" title="statement not covered" ></span>t.height=Math.min(this.maxHeight,t.height+e+r)}</span>else{const e=<span class="cstat-no" title="statement not covered" >i.mirror?0:h*n.width+c*o.height;<span class="cstat-no" title="statement not covered" ></span>t.width=Math.min(this.maxWidth,t.width+e+r)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._calculatePadding(e,s,c,h)}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}<span class="fstat-no" title="function not covered" ></span>_c</span>alculatePadding(t,e,i,s){const{ticks:{align:n,padding:o},position:a}=<span class="cstat-no" title="statement not covered" >this.options,</span>r=<span class="cstat-no" title="statement not covered" >0!==this.labelRotation,</span>l=<span class="cstat-no" title="statement not covered" >"top"!==a&amp;&amp;"x"===this.axis;<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal()){const a=<span class="cstat-no" title="statement not covered" >this.getPixelForTick(0)-this.left,</span>h=<span class="cstat-no" title="statement not covered" >this.right-this.getPixelForTick(this.ticks.length-1);</span>let c=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>r?l?(c=s*t.width,d=i*e.height):(c=i*t.height,d=s*e.width):"start"===n?d=e.width:"end"===n?c=t.width:"inner"!==n&amp;&amp;(c=t.width/2,d=e.width/2),this.paddingLeft=Math.max((c-a+o)*this.width/(this.width-a),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}</span>else{let i=<span class="cstat-no" title="statement not covered" >e.height/2,</span>s=<span class="cstat-no" title="statement not covered" >t.height/2;<span class="cstat-no" title="statement not covered" ></span>"start"===n?(i=0,s=t.height):"end"===n&amp;&amp;(i=e.height,s=0),this.paddingTop=i+o,this.paddingBottom=s+o}</span>}<span class="fstat-no" title="function not covered" ></span>_h</span>andleMargins(){<span class="cstat-no" title="statement not covered" >this._margins&amp;&amp;(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}<span class="fstat-no" title="function not covered" ></span>af</span>terFit(){<span class="cstat-no" title="statement not covered" >c(this.options.afterFit,[this])}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){const{axis:t,position:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>return"top"===e||"bottom"===e||"x"===t}<span class="fstat-no" title="function not covered" ></span>is</span>FullSize(){<span class="cstat-no" title="statement not covered" >return this.options.fullSize}<span class="fstat-no" title="function not covered" ></span>_c</span>onvertTicksToLabels(t){let e,s;<span class="cstat-no" title="statement not covered" >for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,s=t.length;e&lt;s;e++)<span class="cstat-no" title="statement not covered" >i(t[e].label)&amp;&amp;(t.splice(e,1),s--,e--);<span class="cstat-no" title="statement not covered" >t</span></span>his.afterTickToLabelConversion()}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelSizes(){let t=<span class="cstat-no" title="statement not covered" >this._labelSizes;<span class="cstat-no" title="statement not covered" ></span>if(!t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks.sampleSize;</span>let i=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>e&lt;i.length&amp;&amp;(i=Bs(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelSizes(t,e){const{ctx:n,_longestTextCache:o}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >[];</span>let l,h,c,u,f,g,p,m,b,x,_,y=<span class="cstat-no" title="statement not covered" >0,</span>v=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(l=0;l&lt;e;++l){<span class="cstat-no" title="statement not covered" >if(u=t[l].label,f=this._resolveTickFontOptions(l),n.font=g=f.string,p=o[g]=o[g]||{data:{},gc:[]},m=f.lineHeight,b=x=0,i(u)||s(u)){<span class="cstat-no" title="statement not covered" >if(s(u))<span class="cstat-no" title="statement not covered" >for(h=0,c=u.length;h&lt;c;++h)<span class="cstat-no" title="statement not covered" >_=u[h],i(_)||s(_)||(b=_e(n,p.data,p.gc,b,_),x+=m)}</span></span></span>else <span class="cstat-no" title="statement not covered" >b=_e(n,p.data,p.gc,b,u),x=m;<span class="cstat-no" title="statement not covered" >a</span></span>.push(b),r.push(x),y=Math.max(b,y),v=Math.max(x,v)}<span class="cstat-no" title="statement not covered" ></span>!<span class="fstat-no" title="function not covered" ></span>fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >d(t,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >t.gc,</span>s=<span class="cstat-no" title="statement not covered" >i.length/2;</span>let n;<span class="cstat-no" title="statement not covered" >if(s&gt;e){<span class="cstat-no" title="statement not covered" >for(n=0;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >delete t.data[i[n]];<span class="cstat-no" title="statement not covered" >i</span></span>.splice(0,s)}</span>}</span>))}</span>(o,e);c</span>onst w=<span class="cstat-no" title="statement not covered" >a.indexOf(y),</span>M=<span class="cstat-no" title="statement not covered" >r.indexOf(v),</span>k=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{width:a[t]||0,height:r[t]||0})</span>;<span class="cstat-no" title="statement not covered" ></span>return{first:k(0),last:k(e-1),widest:k(w),highest:k(M),widths:a,heights:r}}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return t}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t,e){<span class="cstat-no" title="statement not covered" >return NaN}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){}<span class="fstat-no" title="function not covered" >ge</span>tPixelForTick(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0||t&gt;e.length-1?null:this.getPixelForValue(e[t].value)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForDecimal(t){<span class="cstat-no" title="statement not covered" >this._reversePixels&amp;&amp;(t=1-t);c</span>onst e=<span class="cstat-no" title="statement not covered" >this._startPixel+t*this._length;<span class="cstat-no" title="statement not covered" ></span>return J(this._alignToPixels?ve(this.chart,e,0):e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDecimalForPixel(t){const e=<span class="cstat-no" title="statement not covered" >(t-this._startPixel)/this._length;<span class="cstat-no" title="statement not covered" ></span>return this._reversePixels?1-e:e}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePixel(){<span class="cstat-no" title="statement not covered" >return this.getPixelForValue(this.getBaseValue())}<span class="fstat-no" title="function not covered" ></span>ge</span>tBaseValue(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0&amp;&amp;e&lt;0?e:t&gt;0&amp;&amp;e&gt;0?t:0}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks||[];<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=0&amp;&amp;t&lt;e.length){const i=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>return i.$context||(i.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return _i(t,{tick:i,index:e,type:"tick"})}</span>(this.getContext(),t,i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.$context||(this.$context=_i(this.chart.getContext(),{scale:this,type:"scale"}))}<span class="fstat-no" title="function not covered" ></span>_t</span>ickSize(){const t=<span class="cstat-no" title="statement not covered" >this.options.ticks,</span>e=<span class="cstat-no" title="statement not covered" >H(this.labelRotation),</span>i=<span class="cstat-no" title="statement not covered" >Math.abs(Math.cos(e)),</span>s=<span class="cstat-no" title="statement not covered" >Math.abs(Math.sin(e)),</span>n=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>o=<span class="cstat-no" title="statement not covered" >t.autoSkipPadding||0,</span>a=<span class="cstat-no" title="statement not covered" >n?n.widest.width+o:0,</span>r=<span class="cstat-no" title="statement not covered" >n?n.highest.height+o:0;<span class="cstat-no" title="statement not covered" ></span>return this.isHorizontal()?r*i&gt;a*s?a/i:r/s:r*s&lt;a*i?r/i:a/s}<span class="fstat-no" title="function not covered" ></span>_i</span>sVisible(){const t=<span class="cstat-no" title="statement not covered" >this.options.display;<span class="cstat-no" title="statement not covered" ></span>return"auto"!==t?!!t:this.getMatchingVisibleMetas().length&gt;0}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeGridLineItems(t){const e=<span class="cstat-no" title="statement not covered" >this.axis,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>s=<span class="cstat-no" title="statement not covered" >this.options,</span>{grid:o,position:a}=<span class="cstat-no" title="statement not covered" >s,</span>l=<span class="cstat-no" title="statement not covered" >o.offset,</span>h=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>c=<span class="cstat-no" title="statement not covered" >this.ticks.length+(l?1:0),</span>d=<span class="cstat-no" title="statement not covered" >Ws(o),</span>u=<span class="cstat-no" title="statement not covered" >[],</span>f=<span class="cstat-no" title="statement not covered" >o.setContext(this.getContext()),</span>g=<span class="cstat-no" title="statement not covered" >f.drawBorder?f.borderWidth:0,</span>p=<span class="cstat-no" title="statement not covered" >g/2,</span>m=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return ve(i,t,g)}</span>;</span>let b,x,_,y,v,w,M,k,S,P,D,O;<span class="cstat-no" title="statement not covered" >if("top"===a)<span class="cstat-no" title="statement not covered" >b=m(this.bottom),w=this.bottom-d,k=b-p,P=m(t.top)+p,O=t.bottom;e</span>lse <span class="cstat-no" title="statement not covered" >if("bottom"===a)<span class="cstat-no" title="statement not covered" >b=m(this.top),P=t.top,O=m(t.bottom)-p,w=b+p,k=this.top+d;e</span>lse <span class="cstat-no" title="statement not covered" >if("left"===a)<span class="cstat-no" title="statement not covered" >b=m(this.right),v=this.right-d,M=b-p,S=m(t.left)+p,D=t.right;e</span>lse <span class="cstat-no" title="statement not covered" >if("right"===a)<span class="cstat-no" title="statement not covered" >b=m(this.left),S=t.left,D=m(t.right)-p,v=b+p,M=this.left+d;e</span>lse <span class="cstat-no" title="statement not covered" >if("x"===e){<span class="cstat-no" title="statement not covered" >if("center"===a)<span class="cstat-no" title="statement not covered" >b=m((t.top+t.bottom)/2+.5);e</span>lse <span class="cstat-no" title="statement not covered" >if(n(a)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(a)[0],</span>e=<span class="cstat-no" title="statement not covered" >a[t];<span class="cstat-no" title="statement not covered" ></span>b=m(this.chart.scales[t].getPixelForValue(e))}<span class="cstat-no" title="statement not covered" ></span>P</span></span>=t.top,O=t.bottom,w=b+p,k=w+d}</span>else <span class="cstat-no" title="statement not covered" >if("y"===e){<span class="cstat-no" title="statement not covered" >if("center"===a)<span class="cstat-no" title="statement not covered" >b=m((t.left+t.right)/2);e</span>lse <span class="cstat-no" title="statement not covered" >if(n(a)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(a)[0],</span>e=<span class="cstat-no" title="statement not covered" >a[t];<span class="cstat-no" title="statement not covered" ></span>b=m(this.chart.scales[t].getPixelForValue(e))}<span class="cstat-no" title="statement not covered" ></span>v</span></span>=b-p,M=v-d,S=t.left,D=t.right}</span>c</span></span></span></span></span></span>onst C=<span class="cstat-no" title="statement not covered" >r(s.ticks.maxTicksLimit,c),</span>A=<span class="cstat-no" title="statement not covered" >Math.max(1,Math.ceil(c/C));<span class="cstat-no" title="statement not covered" ></span>for(x=0;x&lt;c;x+=A){const t=<span class="cstat-no" title="statement not covered" >o.setContext(this.getContext(x)),</span>e=<span class="cstat-no" title="statement not covered" >t.lineWidth,</span>s=<span class="cstat-no" title="statement not covered" >t.color,</span>n=<span class="cstat-no" title="statement not covered" >t.borderDash||[],</span>a=<span class="cstat-no" title="statement not covered" >t.borderDashOffset,</span>r=<span class="cstat-no" title="statement not covered" >t.tickWidth,</span>c=<span class="cstat-no" title="statement not covered" >t.tickColor,</span>d=<span class="cstat-no" title="statement not covered" >t.tickBorderDash||[],</span>f=<span class="cstat-no" title="statement not covered" >t.tickBorderDashOffset;<span class="cstat-no" title="statement not covered" ></span>_=Ns(this,x,l),void 0!==_&amp;&amp;(y=ve(i,_,e),h?v=M=S=D=y:w=k=P=O=y,u.push({tx1:v,ty1:w,tx2:M,ty2:k,x1:S,y1:P,x2:D,y2:O,width:e,color:s,borderDash:n,borderDashOffset:a,tickWidth:r,tickColor:c,tickBorderDash:d,tickBorderDashOffset:f}))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._ticksLength=c,this._borderValue=b,u}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelItems(t){const e=<span class="cstat-no" title="statement not covered" >this.axis,</span>i=<span class="cstat-no" title="statement not covered" >this.options,</span>{position:o,ticks:a}=<span class="cstat-no" title="statement not covered" >i,</span>r=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>l=<span class="cstat-no" title="statement not covered" >this.ticks,</span>{align:h,crossAlign:c,padding:d,mirror:u}=<span class="cstat-no" title="statement not covered" >a,</span>f=<span class="cstat-no" title="statement not covered" >Ws(i.grid),</span>g=<span class="cstat-no" title="statement not covered" >f+d,</span>p=<span class="cstat-no" title="statement not covered" >u?-d:g,</span>m=<span class="cstat-no" title="statement not covered" >-H(this.labelRotation),</span>b=<span class="cstat-no" title="statement not covered" >[];</span>let x,_,y,v,w,M,k,S,P,D,O,C,A=<span class="cstat-no" title="statement not covered" >"middle";<span class="cstat-no" title="statement not covered" ></span>if("top"===o)<span class="cstat-no" title="statement not covered" >M=this.bottom-p,k=this._getXAxisLabelAlignment();e</span>lse <span class="cstat-no" title="statement not covered" >if("bottom"===o)<span class="cstat-no" title="statement not covered" >M=this.top+p,k=this._getXAxisLabelAlignment();e</span>lse <span class="cstat-no" title="statement not covered" >if("left"===o){const t=<span class="cstat-no" title="statement not covered" >this._getYAxisLabelAlignment(f);<span class="cstat-no" title="statement not covered" ></span>k=t.textAlign,w=t.x}</span>else <span class="cstat-no" title="statement not covered" >if("right"===o){const t=<span class="cstat-no" title="statement not covered" >this._getYAxisLabelAlignment(f);<span class="cstat-no" title="statement not covered" ></span>k=t.textAlign,w=t.x}</span>else <span class="cstat-no" title="statement not covered" >if("x"===e){<span class="cstat-no" title="statement not covered" >if("center"===o)<span class="cstat-no" title="statement not covered" >M=(t.top+t.bottom)/2+g;e</span>lse <span class="cstat-no" title="statement not covered" >if(n(o)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(o)[0],</span>e=<span class="cstat-no" title="statement not covered" >o[t];<span class="cstat-no" title="statement not covered" ></span>M=this.chart.scales[t].getPixelForValue(e)+g}<span class="cstat-no" title="statement not covered" ></span>k</span></span>=this._getXAxisLabelAlignment()}</span>else <span class="cstat-no" title="statement not covered" >if("y"===e){<span class="cstat-no" title="statement not covered" >if("center"===o)<span class="cstat-no" title="statement not covered" >w=(t.left+t.right)/2-g;e</span>lse <span class="cstat-no" title="statement not covered" >if(n(o)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(o)[0],</span>e=<span class="cstat-no" title="statement not covered" >o[t];<span class="cstat-no" title="statement not covered" ></span>w=this.chart.scales[t].getPixelForValue(e)}<span class="cstat-no" title="statement not covered" ></span>k</span></span>=this._getYAxisLabelAlignment(f).textAlign}<span class="cstat-no" title="statement not covered" ></span>"</span></span></span></span></span></span>y"===e&amp;&amp;("start"===h?A="top":"end"===h&amp;&amp;(A="bottom"));c</span>onst T=<span class="cstat-no" title="statement not covered" >this._getLabelSizes();<span class="cstat-no" title="statement not covered" ></span>for(x=0,_=l.length;x&lt;_;++x){<span class="cstat-no" title="statement not covered" >y=l[x],v=y.label;c</span>onst t=<span class="cstat-no" title="statement not covered" >a.setContext(this.getContext(x));<span class="cstat-no" title="statement not covered" ></span>S=this.getPixelForTick(x)+a.labelOffset,P=this._resolveTickFontOptions(x),D=P.lineHeight,O=s(v)?v.length:1;c</span>onst e=<span class="cstat-no" title="statement not covered" >O/2,</span>i=<span class="cstat-no" title="statement not covered" >t.color,</span>n=<span class="cstat-no" title="statement not covered" >t.textStrokeColor,</span>h=<span class="cstat-no" title="statement not covered" >t.textStrokeWidth;</span>let d,f=<span class="cstat-no" title="statement not covered" >k;<span class="cstat-no" title="statement not covered" ></span>if(r?(w=S,"inner"===k&amp;&amp;(f=x===_-1?this.options.reverse?"left":"right":0===x?this.options.reverse?"right":"left":"center"),C="top"===o?"near"===c||0!==m?-O*D+D/2:"center"===c?-T.highest.height/2-e*D+D:-T.highest.height+D/2:"near"===c||0!==m?D/2:"center"===c?T.highest.height/2-e*D:T.highest.height-O*D,u&amp;&amp;(C*=-1)):(M=S,C=(1-O)*D/2),t.showLabelBackdrop){const e=<span class="cstat-no" title="statement not covered" >pi(t.backdropPadding),</span>i=<span class="cstat-no" title="statement not covered" >T.heights[x],</span>s=<span class="cstat-no" title="statement not covered" >T.widths[x];</span>let n=<span class="cstat-no" title="statement not covered" >M+C-e.top,</span>o=<span class="cstat-no" title="statement not covered" >w-e.left;<span class="cstat-no" title="statement not covered" ></span>switch(A){case"middle":<span class="cstat-no" title="statement not covered" >n-=i/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"bottom":<span class="cstat-no" title="statement not covered" >n-=i}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(k){case"center":<span class="cstat-no" title="statement not covered" >o-=s/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >o-=s}<span class="cstat-no" title="statement not covered" ></span>d</span>={left:o,top:n,width:s+e.width,height:i+e.height,color:t.backdropColor}}<span class="cstat-no" title="statement not covered" ></span>b</span>.push({rotation:m,label:v,font:P,color:i,strokeColor:n,strokeWidth:h,textOffset:C,textAlign:f,textBaseline:A,translation:[w,M],backdrop:d})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn b}<span class="fstat-no" title="function not covered" ></span>_g</span>etXAxisLabelAlignment(){const{position:t,ticks:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(-H(this.labelRotation))<span class="cstat-no" title="statement not covered" >return"top"===t?"left":"right";l</span></span>et i=<span class="cstat-no" title="statement not covered" >"center";<span class="cstat-no" title="statement not covered" ></span>return"start"===e.align?i="left":"end"===e.align?i="right":"inner"===e.align&amp;&amp;(i="inner"),i}<span class="fstat-no" title="function not covered" ></span>_g</span>etYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:n}}=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >t+n,</span>a=<span class="cstat-no" title="statement not covered" >this._getLabelSizes().widest.width;</span>let r,l;<span class="cstat-no" title="statement not covered" >return"left"===e?s?(l=this.right+n,"near"===i?r="left":"center"===i?(r="center",l+=a/2):(r="right",l+=a)):(l=this.right-o,"near"===i?r="right":"center"===i?(r="center",l-=a/2):(r="left",l=this.left)):"right"===e?s?(l=this.left+n,"near"===i?r="right":"center"===i?(r="center",l-=a/2):(r="left",l-=a)):(l=this.left+o,"near"===i?r="left":"center"===i?(r="center",l+=a/2):(r="right",l=this.right)):r="right",{textAlign:r,x:l}}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelArea(){<span class="cstat-no" title="statement not covered" >if(this.options.ticks.mirror)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >this.options.position;<span class="cstat-no" title="statement not covered" ></span>return"left"===e||"right"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:"top"===e||"bottom"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:n,height:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(t.save(),t.fillStyle=e,t.fillRect(i,s,n,o),t.restore())}<span class="fstat-no" title="function not covered" ></span>ge</span>tLineWidthForValue(t){const e=<span class="cstat-no" title="statement not covered" >this.options.grid;<span class="cstat-no" title="statement not covered" ></span>if(!this._isVisible()||!e.display)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.ticks.findIndex((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.value===t)</span>);<span class="cstat-no" title="statement not covered" ></span>if(i&gt;=0){<span class="cstat-no" title="statement not covered" >return e.setContext(this.getContext(i)).lineWidth}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0}<span class="fstat-no" title="function not covered" ></span>dr</span>awGrid(t){const e=<span class="cstat-no" title="statement not covered" >this.options.grid,</span>i=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));</span>let n,o;const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >s.width&amp;&amp;s.color&amp;&amp;(i.save(),i.lineWidth=s.width,i.strokeStyle=s.color,i.setLineDash(s.borderDash||[]),i.lineDashOffset=s.borderDashOffset,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),i.restore())}</span>;<span class="cstat-no" title="statement not covered" ></span>if(e.display)<span class="cstat-no" title="statement not covered" >for(n=0,o=s.length;n&lt;o;++n){const t=<span class="cstat-no" title="statement not covered" >s[n];<span class="cstat-no" title="statement not covered" ></span>e.drawOnChartArea&amp;&amp;a({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&amp;&amp;a({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}</span>}<span class="fstat-no" title="function not covered" ></span></span>dr</span>awBorder(){const{chart:t,ctx:e,options:{grid:i}}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >i.setContext(this.getContext()),</span>n=<span class="cstat-no" title="statement not covered" >i.drawBorder?s.borderWidth:0;<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >i.setContext(this.getContext(0)).lineWidth,</span>a=<span class="cstat-no" title="statement not covered" >this._borderValue;</span>let r,l,h,c;<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(r=ve(t,this.left,n)-n/2,l=ve(t,this.right,o)+o/2,h=c=a):(h=ve(t,this.top,n)-n/2,c=ve(t,this.bottom,o)+o/2,r=l=a),e.save(),e.lineWidth=s.borderWidth,e.strokeStyle=s.borderColor,e.beginPath(),e.moveTo(r,h),e.lineTo(l,c),e.stroke(),e.restore()}<span class="fstat-no" title="function not covered" ></span>dr</span>awLabels(t){<span class="cstat-no" title="statement not covered" >if(!this.options.ticks.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >this._computeLabelArea();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;Pe(e,i);c</span>onst s=<span class="cstat-no" title="statement not covered" >this._labelItems||(this._labelItems=this._computeLabelItems(t));</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=s.length;n&lt;o;++n){const t=<span class="cstat-no" title="statement not covered" >s[n],</span>i=<span class="cstat-no" title="statement not covered" >t.font,</span>o=<span class="cstat-no" title="statement not covered" >t.label;<span class="cstat-no" title="statement not covered" ></span>t.backdrop&amp;&amp;(e.fillStyle=t.backdrop.color,e.fillRect(t.backdrop.left,t.backdrop.top,t.backdrop.width,t.backdrop.height)),Ae(e,o,0,t.textOffset,i,t)}<span class="cstat-no" title="statement not covered" ></span>i</span>&amp;&amp;De(e)}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){const{ctx:t,options:{position:e,title:i,reverse:o}}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!i.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >mi(i.font),</span>r=<span class="cstat-no" title="statement not covered" >pi(i.padding),</span>l=<span class="cstat-no" title="statement not covered" >i.align;</span>let h=<span class="cstat-no" title="statement not covered" >a.lineHeight/2;<span class="cstat-no" title="statement not covered" ></span>"bottom"===e||"center"===e||n(e)?(h+=r.bottom,s(i.text)&amp;&amp;(h+=a.lineHeight*(i.text.length-1))):h+=r.top;c</span>onst{titleX:c,titleY:d,maxWidth:u,rotation:f}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{top:o,left:a,bottom:r,right:l,chart:h}=<span class="cstat-no" title="statement not covered" >t,</span>{chartArea:c,scales:d}=<span class="cstat-no" title="statement not covered" >h;</span>let u,f,g,p=<span class="cstat-no" title="statement not covered" >0;</span>const m=<span class="cstat-no" title="statement not covered" >r-o,</span>b=<span class="cstat-no" title="statement not covered" >l-a;<span class="cstat-no" title="statement not covered" ></span>if(t.isHorizontal()){<span class="cstat-no" title="statement not covered" >if(f=ut(s,a,l),n(i)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(i)[0],</span>s=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>g=d[t].getPixelForValue(s)+m-e}</span>else <span class="cstat-no" title="statement not covered" >g="center"===i?(c.bottom+c.top)/2+m-e:Vs(t,i,e);<span class="cstat-no" title="statement not covered" >u</span></span>=l-a}</span>else{<span class="cstat-no" title="statement not covered" >if(n(i)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(i)[0],</span>s=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>f=d[t].getPixelForValue(s)-b+e}</span>else <span class="cstat-no" title="statement not covered" >f="center"===i?(c.left+c.right)/2-b+e:Vs(t,i,e);<span class="cstat-no" title="statement not covered" >g</span></span>=ut(s,r,o),p="left"===i?-L:L}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{titleX:f,titleY:g,maxWidth:u,rotation:p}}</span>(this,h,e,l);<span class="cstat-no" title="statement not covered" ></span>Ae(t,i.text,0,0,a,{color:i.color,maxWidth:u,rotation:f,textAlign:Hs(l,e,o),textBaseline:"middle",translation:[c,d]})}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){<span class="cstat-no" title="statement not covered" >this._isVisible()&amp;&amp;(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}<span class="fstat-no" title="function not covered" ></span>_l</span>ayers(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks&amp;&amp;t.ticks.z||0,</span>i=<span class="cstat-no" title="statement not covered" >r(t.grid&amp;&amp;t.grid.z,-1);<span class="cstat-no" title="statement not covered" ></span>return this._isVisible()&amp;&amp;this.draw===$s.prototype.draw?[{z:i,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.drawBackground(),this.drawGrid(t),this.drawTitle()}</span>},{z:i+1,draw:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.drawBorder()}</span>},{z:e,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.drawLabels(t)}</span>}]:[{z:e,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.draw(t)}</span>}]}<span class="fstat-no" title="function not covered" ></span>ge</span>tMatchingVisibleMetas(t){const e=<span class="cstat-no" title="statement not covered" >this.chart.getSortedVisibleDatasetMetas(),</span>i=<span class="cstat-no" title="statement not covered" >this.axis+"AxisID",</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=e.length;n&lt;o;++n){const o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>o[i]!==this.id||t&amp;&amp;o.type!==t||s.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveTickFontOptions(t){<span class="cstat-no" title="statement not covered" >return mi(this.options.ticks.setContext(this.getContext(t)).font)}<span class="fstat-no" title="function not covered" ></span>_m</span>axDigits(){const t=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0).lineHeight;<span class="cstat-no" title="statement not covered" ></span>return(this.isHorizontal()?this.width:this.height)/t}</span>}class Ys{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}<span class="fstat-no" title="function not covered" ></span>is</span>ForType(t){<span class="cstat-no" title="statement not covered" >return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}<span class="fstat-no" title="function not covered" ></span>re</span>gister(t){const e=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf(t);</span>let i;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"id"in t&amp;&amp;"defaults"in t}</span>)(e)&amp;&amp;(i=this.register(e));c</span>onst s=<span class="cstat-no" title="statement not covered" >this.items,</span>n=<span class="cstat-no" title="statement not covered" >t.id,</span>o=<span class="cstat-no" title="statement not covered" >this.scope+"."+n;<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new Error("class does not have id: "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n in s||(s[n]=t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >m(Object.create(null),[i?ne.get(i):{},ne.get(e),t.defaults]);<span class="cstat-no" title="statement not covered" ></span>ne.set(e,s),t.defaultRoutes&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >Object.keys(e).forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i.split("."),</span>n=<span class="cstat-no" title="statement not covered" >s.pop(),</span>o=<span class="cstat-no" title="statement not covered" >[t].concat(s).join("."),</span>a=<span class="cstat-no" title="statement not covered" >e[i].split("."),</span>r=<span class="cstat-no" title="statement not covered" >a.pop(),</span>l=<span class="cstat-no" title="statement not covered" >a.join(".");<span class="cstat-no" title="statement not covered" ></span>ne.route(o,n,l,r)}</span>))}</span>(e,t.defaultRoutes);<span class="cstat-no" title="statement not covered" >t</span>.descriptors&amp;&amp;ne.describe(e,t.descriptors)}</span>(t,o,i),this.override&amp;&amp;ne.override(t.id,t.overrides)),o}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return this.items[t]}<span class="fstat-no" title="function not covered" ></span>un</span>register(t){const e=<span class="cstat-no" title="statement not covered" >this.items,</span>i=<span class="cstat-no" title="statement not covered" >t.id,</span>s=<span class="cstat-no" title="statement not covered" >this.scope;<span class="cstat-no" title="statement not covered" ></span>i in e&amp;&amp;delete e[i],s&amp;&amp;i in ne[s]&amp;&amp;(delete ne[s][i],this.override&amp;&amp;delete te[i])}</span>}var Us=<span class="cstat-no" title="statement not covered" >new class{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.controllers=new Ys(Ls,"datasets",!0),this.elements=new Ys(Es,"elements"),this.plugins=new Ys(Object,"plugins"),this.scales=new Ys($s,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}<span class="fstat-no" title="function not covered" ></span>ad</span>d(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t)}<span class="fstat-no" title="function not covered" ></span>re</span>move(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dControllers(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.controllers)}<span class="fstat-no" title="function not covered" ></span>ad</span>dElements(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.elements)}<span class="fstat-no" title="function not covered" ></span>ad</span>dPlugins(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.plugins)}<span class="fstat-no" title="function not covered" ></span>ad</span>dScales(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.scales)}<span class="fstat-no" title="function not covered" ></span>ge</span>tController(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.controllers,"controller")}<span class="fstat-no" title="function not covered" ></span>ge</span>tElement(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.elements,"element")}<span class="fstat-no" title="function not covered" ></span>ge</span>tPlugin(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.plugins,"plugin")}<span class="fstat-no" title="function not covered" ></span>ge</span>tScale(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.scales,"scale")}<span class="fstat-no" title="function not covered" ></span>re</span>moveControllers(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.controllers)}<span class="fstat-no" title="function not covered" ></span>re</span>moveElements(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.elements)}<span class="fstat-no" title="function not covered" ></span>re</span>movePlugins(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.plugins)}<span class="fstat-no" title="function not covered" ></span>re</span>moveScales(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.scales)}<span class="fstat-no" title="function not covered" ></span>_e</span>ach(t,e,i){<span class="cstat-no" title="statement not covered" >[...e].forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i||this._getRegistryForType(e);<span class="cstat-no" title="statement not covered" ></span>i||s.isForType(e)||s===this.plugins&amp;&amp;e.id?this._exec(t,s,e):d(e,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i||this._getRegistryForType(e);<span class="cstat-no" title="statement not covered" ></span>this._exec(t,s,e)}</span>))}</span>))}<span class="fstat-no" title="function not covered" ></span>_e</span>xec(t,e,i){const s=<span class="cstat-no" title="statement not covered" >w(t);<span class="cstat-no" title="statement not covered" ></span>c(i["before"+s],[],i),e[t](i),c(i["after"+s],[],i)}<span class="fstat-no" title="function not covered" ></span>_g</span>etRegistryForType(t){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this._typedRegistries.length;e++){const i=<span class="cstat-no" title="statement not covered" >this._typedRegistries[e];<span class="cstat-no" title="statement not covered" ></span>if(i.isForType(t))<span class="cstat-no" title="statement not covered" >return i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this.plugins}<span class="fstat-no" title="function not covered" ></span>_g</span>et(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>if(void 0===s)<span class="cstat-no" title="statement not covered" >throw new Error('"'+t+'" is not a registered '+i+".");<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>};</span>class Xs{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._init=[]}<span class="fstat-no" title="function not covered" ></span>no</span>tify(t,e,i,s){<span class="cstat-no" title="statement not covered" >"beforeInit"===e&amp;&amp;(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install"));c</span>onst n=<span class="cstat-no" title="statement not covered" >s?this._descriptors(t).filter(s):this._descriptors(t),</span>o=<span class="cstat-no" title="statement not covered" >this._notify(n,t,e,i);<span class="cstat-no" title="statement not covered" ></span>return"afterDestroy"===e&amp;&amp;(this._notify(n,t,"stop"),this._notify(this._init,t,"uninstall")),o}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t,e,i,s){<span class="cstat-no" title="statement not covered" >s=s||{};<span class="cstat-no" title="statement not covered" >f</span>or(const n of t){const t=<span class="cstat-no" title="statement not covered" >n.plugin;<span class="cstat-no" title="statement not covered" ></span>if(!1===c(t[i],[e,s,n.options],t)&amp;&amp;s.cancelable)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}<span class="fstat-no" title="function not covered" ></span>in</span>validate(){<span class="cstat-no" title="statement not covered" >i(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}<span class="fstat-no" title="function not covered" ></span>_d</span>escriptors(t){<span class="cstat-no" title="statement not covered" >if(this._cache)<span class="cstat-no" title="statement not covered" >return this._cache;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._cache=this._createDescriptors(t);<span class="cstat-no" title="statement not covered" ></span>return this._notifyStateChanges(t),e}<span class="fstat-no" title="function not covered" ></span>_c</span>reateDescriptors(t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.config,</span>s=<span class="cstat-no" title="statement not covered" >r(i.options&amp;&amp;i.options.plugins,{}),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(Us.plugins.items);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;s.length;t++)<span class="cstat-no" title="statement not covered" >i.push(Us.getPlugin(s[t]));c</span></span>onst n=<span class="cstat-no" title="statement not covered" >t.plugins||[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t++){const s=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>-1===i.indexOf(s)&amp;&amp;(i.push(s),e[s.id]=!0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{plugins:i,localIds:e}}</span>(i);<span class="cstat-no" title="statement not covered" ></span>return!1!==s||e?<span class="fstat-no" title="function not covered" >fu</span>nction(t,{plugins:e,localIds:i},s,n){const o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >t.getContext();<span class="cstat-no" title="statement not covered" ></span>for(const r of e){const e=<span class="cstat-no" title="statement not covered" >r.id,</span>l=<span class="cstat-no" title="statement not covered" >qs(s[e],n);<span class="cstat-no" title="statement not covered" ></span>null!==l&amp;&amp;o.push({plugin:r,options:Ks(t.config,{plugin:r,local:i[e]},l,a)})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>(t,n,s,e):[]}<span class="fstat-no" title="function not covered" ></span>_n</span>otifyStateChanges(t){const e=<span class="cstat-no" title="statement not covered" >this._oldCache||[],</span>i=<span class="cstat-no" title="statement not covered" >this._cache,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.plugin.id===e.plugin.id)</span>))</span>);<span class="cstat-no" title="statement not covered" ></span></span>this._notify(s(e,i),t,"stop"),this._notify(s(i,e),t,"start")}</span>}function <span class="fstat-no" title="function not covered" >qs(</span>t,e){<span class="cstat-no" title="statement not covered" >return e||!1!==t?!0===t?{}:t:null}</span>function <span class="fstat-no" title="function not covered" >Ks(</span>t,{plugin:e,local:i},s,n){const o=<span class="cstat-no" title="statement not covered" >t.pluginScopeKeys(e),</span>a=<span class="cstat-no" title="statement not covered" >t.getOptionScopes(s,o);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;e.defaults&amp;&amp;a.push(e.defaults),t.createResolver(a,n,[""],{scriptable:!1,indexable:!1,allKeys:!0})}</span>function <span class="fstat-no" title="function not covered" >Gs(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >ne.datasets[t]||{};<span class="cstat-no" title="statement not covered" ></span>return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||i.indexAxis||"x"}</span>function <span class="fstat-no" title="function not covered" >Zs(</span>t,e){<span class="cstat-no" title="statement not covered" >return"x"===t||"y"===t?t:e.axis||("top"===(i=e.position)||"bottom"===i?"x":"left"===i||"right"===i?"y":void 0)||t.charAt(0).toLowerCase();v</span>ar i}function <span class="fstat-no" title="function not covered" >Js(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.options||(t.options={});<span class="cstat-no" title="statement not covered" ></span>e.plugins=r(e.plugins,{}),e.scales=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >te[t.type]||{scales:{}},</span>s=<span class="cstat-no" title="statement not covered" >e.scales||{},</span>o=<span class="cstat-no" title="statement not covered" >Gs(t.type,e),</span>a=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>r=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>return Object.keys(s).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>if(!n(e))<span class="cstat-no" title="statement not covered" >return console.error(`Invalid scale configuration for scale: ${t}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(e._proxy)<span class="cstat-no" title="statement not covered" >return console.warn(`Ignoring resolver passed as options for scale: ${t}`);c</span></span>onst l=<span class="cstat-no" title="statement not covered" >Zs(t,e),</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t===e?"_index_":"_value_"}</span>(l,o),</span>c=<span class="cstat-no" title="statement not covered" >i.scales||{};<span class="cstat-no" title="statement not covered" ></span>a[l]=a[l]||t,r[t]=b(Object.create(null),[{axis:l},e,c[l],c[h]])}</span>)),t.data.datasets.forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >i.type||t.type,</span>o=<span class="cstat-no" title="statement not covered" >i.indexAxis||Gs(n,e),</span>l=<span class="cstat-no" title="statement not covered" >(te[n]||{}).scales||{};<span class="cstat-no" title="statement not covered" ></span>Object.keys(l).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"_index_"===t?i=e:"_value_"===t&amp;&amp;(i="x"===e?"y":"x"),i}</span>(t,o),</span>n=<span class="cstat-no" title="statement not covered" >i[e+"AxisID"]||a[e]||e;<span class="cstat-no" title="statement not covered" ></span>r[n]=r[n]||Object.create(null),b(r[n],[{axis:e},s[n],l[t]])}</span>))}</span>)),Object.keys(r).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >r[t];<span class="cstat-no" title="statement not covered" ></span>b(e,[ne.scales[e.type],ne.scale])}</span>)),r}</span>(t,e)}</span>function <span class="fstat-no" title="function not covered" >Qs(</span>t){<span class="cstat-no" title="statement not covered" >return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}</span>const tn=<span class="cstat-no" title="statement not covered" >new Map,</span>en=<span class="cstat-no" title="statement not covered" >new Set;</span>function <span class="fstat-no" title="function not covered" >sn(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >tn.get(t);<span class="cstat-no" title="statement not covered" ></span>return i||(i=e(),tn.set(t,i),en.add(i)),i}</span>const nn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >y(e,i);<span class="cstat-no" title="statement not covered" ></span>void 0!==s&amp;&amp;t.add(s)}</span>;</span>class on{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._config=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return(t=t||{}).data=Qs(t.data),Js(t),t}</span>(t),this._scopeCache=new Map,this._resolverCache=new Map}<span class="fstat-no" title="function not covered" ></span>ge</span>t platform(){<span class="cstat-no" title="statement not covered" >return this._config.platform}<span class="fstat-no" title="function not covered" ></span>ge</span>t type(){<span class="cstat-no" title="statement not covered" >return this._config.type}<span class="fstat-no" title="function not covered" ></span>se</span>t type(t){<span class="cstat-no" title="statement not covered" >this._config.type=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t data(){<span class="cstat-no" title="statement not covered" >return this._config.data}<span class="fstat-no" title="function not covered" ></span>se</span>t data(t){<span class="cstat-no" title="statement not covered" >this._config.data=Qs(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t options(){<span class="cstat-no" title="statement not covered" >return this._config.options}<span class="fstat-no" title="function not covered" ></span>se</span>t options(t){<span class="cstat-no" title="statement not covered" >this._config.options=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t plugins(){<span class="cstat-no" title="statement not covered" >return this._config.plugins}<span class="fstat-no" title="function not covered" ></span>up</span>date(){const t=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>this.clearCache(),Js(t)}<span class="fstat-no" title="function not covered" ></span>cl</span>earCache(){<span class="cstat-no" title="statement not covered" >this._scopeCache.clear(),this._resolverCache.clear()}<span class="fstat-no" title="function not covered" ></span>da</span>tasetScopeKeys(t){<span class="cstat-no" title="statement not covered" >return sn(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>da</span>tasetAnimationScopeKeys(t,e){<span class="cstat-no" title="statement not covered" >return sn(`${t}.transition.${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>da</span>tasetElementScopeKeys(t,e){<span class="cstat-no" title="statement not covered" >return sn(`${t}-${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>pl</span>uginScopeKeys(t){const e=<span class="cstat-no" title="statement not covered" >t.id;<span class="cstat-no" title="statement not covered" ></span>return sn(`${this.type}-plugin-${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`plugins.${e}`,...t.additionalOptionScopes||[]]])</span>)}<span class="fstat-no" title="function not covered" ></span>_c</span>achedScopes(t,e){const i=<span class="cstat-no" title="statement not covered" >this._scopeCache;</span>let s=<span class="cstat-no" title="statement not covered" >i.get(t);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;!e||(s=new Map,i.set(t,s)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptionScopes(t,e,i){const{options:s,type:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >this._cachedScopes(t,i),</span>a=<span class="cstat-no" title="statement not covered" >o.get(e);<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return a;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t&amp;&amp;(r.add(t),e.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >nn(r,t,e))</span>)),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >nn(r,s,t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >nn(r,te[n]||{},t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >nn(r,ne,t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >nn(r,ee,t))</span>)}</span>));c</span>onst l=<span class="cstat-no" title="statement not covered" >Array.from(r);<span class="cstat-no" title="statement not covered" ></span>return 0===l.length&amp;&amp;l.push(Object.create(null)),en.has(e)&amp;&amp;o.set(e,l),l}<span class="fstat-no" title="function not covered" ></span>ch</span>artOptionScopes(){const{options:t,type:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return[t,te[e]||{},ne.datasets[e]||{},{type:e},ne,ee]}<span class="fstat-no" title="function not covered" ></span>re</span>solveNamedOptions(t,e,i,n=<span class="branch-0 cbranch-no" title="branch not covered" >[""])</span>{const o=<span class="cstat-no" title="statement not covered" >{$shared:!0},</span>{resolver:a,subPrefixes:r}=<span class="cstat-no" title="statement not covered" >an(this._resolverCache,t,n);</span>let l=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>if(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{isScriptable:i,isIndexable:n}=<span class="cstat-no" title="statement not covered" >Ie(t);<span class="cstat-no" title="statement not covered" ></span>for(const o of e){const e=<span class="cstat-no" title="statement not covered" >i(o),</span>a=<span class="cstat-no" title="statement not covered" >n(o),</span>r=<span class="cstat-no" title="statement not covered" >(a||e)&amp;&amp;t[o];<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;(k(r)||rn(r))||a&amp;&amp;s(r))<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>(a,e)){<span class="cstat-no" title="statement not covered" >o.$shared=!1;<span class="cstat-no" title="statement not covered" >l</span>=Re(a,i=k(i)?i():i,this.createResolver(t,i,r))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const t of e)<span class="cstat-no" title="statement not covered" >o[t]=l[t];<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}<span class="fstat-no" title="function not covered" ></span>cr</span>eateResolver(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >[""],</span>s){const{resolver:o}=<span class="cstat-no" title="statement not covered" >an(this._resolverCache,t,i);<span class="cstat-no" title="statement not covered" ></span>return n(e)?Re(o,e,void 0,s):o}</span>}function <span class="fstat-no" title="function not covered" >an(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >t.get(e);<span class="cstat-no" title="statement not covered" ></span>s||(s=new Map,t.set(e,s));c</span>onst n=<span class="cstat-no" title="statement not covered" >i.join();</span>let o=<span class="cstat-no" title="statement not covered" >s.get(n);<span class="cstat-no" title="statement not covered" ></span>if(!o){<span class="cstat-no" title="statement not covered" >o={resolver:Ee(e,i),subPrefixes:i.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.toLowerCase().includes("hover"))</span>)},s.set(n,o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>const rn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >n(t)&amp;&amp;Object.getOwnPropertyNames(t).reduce((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >e||k(t[i]))</span>,!1);</span></span>const ln=<span class="cstat-no" title="statement not covered" >["top","bottom","left","right","chartArea"];</span>function <span class="fstat-no" title="function not covered" >hn(</span>t,e){<span class="cstat-no" title="statement not covered" >return"top"===t||"bottom"===t||-1===ln.indexOf(t)&amp;&amp;"x"===e}</span>function <span class="fstat-no" title="function not covered" >cn(</span>t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(i,s){<span class="cstat-no" title="statement not covered" >return i[t]===s[t]?i[e]-s[e]:i[t]-s[t]}</span>}</span>function <span class="fstat-no" title="function not covered" >dn(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.chart,</span>i=<span class="cstat-no" title="statement not covered" >e.options.animation;<span class="cstat-no" title="statement not covered" ></span>e.notifyPlugins("afterRender"),c(i&amp;&amp;i.onComplete,[t],e)}</span>function <span class="fstat-no" title="function not covered" >un(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.chart,</span>i=<span class="cstat-no" title="statement not covered" >e.options.animation;<span class="cstat-no" title="statement not covered" ></span>c(i&amp;&amp;i.onProgress,[t],e)}</span>function <span class="fstat-no" title="function not covered" >fn(</span>t){<span class="cstat-no" title="statement not covered" >return oe()&amp;&amp;"string"==typeof t?t=document.getElementById(t):t&amp;&amp;t.length&amp;&amp;(t=t[0]),t&amp;&amp;t.canvas&amp;&amp;(t=t.canvas),t}</span>const gn=<span class="cstat-no" title="statement not covered" >{},</span>pn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >fn(t);<span class="cstat-no" title="statement not covered" ></span>return Object.values(gn).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.canvas===e)</span>).pop()}</span>;</span>function <span class="fstat-no" title="function not covered" >mn(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >Object.keys(t);<span class="cstat-no" title="statement not covered" ></span>for(const n of s){const s=<span class="cstat-no" title="statement not covered" >+n;<span class="cstat-no" title="statement not covered" ></span>if(s&gt;=e){const o=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>delete t[n],(i&gt;0||s&gt;e)&amp;&amp;(t[s+i]=o)}</span>}</span>}</span>class bn{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,i){const s=<span class="cstat-no" title="statement not covered" >this.config=new on(i),</span>n=<span class="cstat-no" title="statement not covered" >fn(t),</span>o=<span class="cstat-no" title="statement not covered" >pn(n);<span class="cstat-no" title="statement not covered" ></span>if(o)<span class="cstat-no" title="statement not covered" >throw new Error("Canvas is already in use. Chart with ID '"+o.id+"' must be destroyed before the canvas with ID '"+o.canvas.id+"' can be reused.");c</span></span>onst a=<span class="cstat-no" title="statement not covered" >s.createResolver(s.chartOptionScopes(),this.getContext());<span class="cstat-no" title="statement not covered" ></span>this.platform=new(s.platform||gs(n)),this.platform.updateConfig(s);c</span>onst r=<span class="cstat-no" title="statement not covered" >this.platform.acquireContext(n,a.aspectRatio),</span>l=<span class="cstat-no" title="statement not covered" >r&amp;&amp;r.canvas,</span>h=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l.height,</span>c=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l.width;<span class="cstat-no" title="statement not covered" ></span>this.id=e(),this.ctx=r,this.canvas=l,this.width=c,this.height=h,this._options=a,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Xs,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=ct((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.update(t))</span>,a.resizeDelay||0),this._dataChanges=[],gn[this.id]=this,r&amp;&amp;l?(mt.listen(this,"complete",dn),mt.listen(this,"progress",un),this._initialize(),this.attached&amp;&amp;this.update()):console.error("Failed to create chart: can't acquire context from the given item")}<span class="fstat-no" title="function not covered" ></span>ge</span>t aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:s,height:n,_aspectRatio:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return i(t)?e&amp;&amp;o?o:n?s/n:null:t}<span class="fstat-no" title="function not covered" ></span>ge</span>t data(){<span class="cstat-no" title="statement not covered" >return this.config.data}<span class="fstat-no" title="function not covered" ></span>se</span>t data(t){<span class="cstat-no" title="statement not covered" >this.config.data=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t options(){<span class="cstat-no" title="statement not covered" >return this._options}<span class="fstat-no" title="function not covered" ></span>se</span>t options(t){<span class="cstat-no" title="statement not covered" >this.config.options=t}<span class="fstat-no" title="function not covered" ></span>_i</span>nitialize(){<span class="cstat-no" title="statement not covered" >return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():pe(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >return we(this.canvas,this.ctx),this}<span class="fstat-no" title="function not covered" ></span>st</span>op(){<span class="cstat-no" title="statement not covered" >return mt.stop(this),this}<span class="fstat-no" title="function not covered" ></span>re</span>size(t,e){<span class="cstat-no" title="statement not covered" >mt.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}<span class="fstat-no" title="function not covered" ></span>_r</span>esize(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >this.canvas,</span>n=<span class="cstat-no" title="statement not covered" >i.maintainAspectRatio&amp;&amp;this.aspectRatio,</span>o=<span class="cstat-no" title="statement not covered" >this.platform.getMaximumSize(s,t,e,n),</span>a=<span class="cstat-no" title="statement not covered" >i.devicePixelRatio||this.platform.getDevicePixelRatio(),</span>r=<span class="cstat-no" title="statement not covered" >this.width?"resize":"attach";<span class="cstat-no" title="statement not covered" ></span>this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,pe(this,a,!0)&amp;&amp;(this.notifyPlugins("resize",{size:o}),c(i.onResize,[this,o],this),this.attached&amp;&amp;this._doResize(r)&amp;&amp;this.render())}<span class="fstat-no" title="function not covered" ></span>en</span>sureScalesHaveIDs(){<span class="cstat-no" title="statement not covered" >d(this.options.scales||{},(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t.id=e}</span>))}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateScales(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.scales,</span>i=<span class="cstat-no" title="statement not covered" >this.scales,</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(i).reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;(<span class="cstat-no" title="statement not covered" >t[e]=!1,t)</span>),{});</span>let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(n=n.concat(Object.keys(e).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e[t],</span>s=<span class="cstat-no" title="statement not covered" >Zs(t,i),</span>n=<span class="cstat-no" title="statement not covered" >"r"===s,</span>o=<span class="cstat-no" title="statement not covered" >"x"===s;<span class="cstat-no" title="statement not covered" ></span>return{options:i,dposition:n?"chartArea":o?"bottom":"left",dtype:n?"radialLinear":o?"category":"linear"}}</span>)))),d(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >e.options,</span>o=<span class="cstat-no" title="statement not covered" >n.id,</span>a=<span class="cstat-no" title="statement not covered" >Zs(o,n),</span>l=<span class="cstat-no" title="statement not covered" >r(n.type,e.dtype);<span class="cstat-no" title="statement not covered" ></span>void 0!==n.position&amp;&amp;hn(n.position,a)===hn(e.dposition)||(n.position=e.dposition),s[o]=!0;l</span>et h=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(o in i&amp;&amp;i[o].type===l)<span class="cstat-no" title="statement not covered" >h=i[o];e</span>lse{<span class="cstat-no" title="statement not covered" >h=new(Us.getScale(l))({id:o,type:l,ctx:this.ctx,chart:this}),i[h.id]=h}<span class="cstat-no" title="statement not covered" ></span>h</span>.init(n,t)}</span>)),d(s,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t||delete i[e]}</span>)),d(i,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >Zi.configure(this,t,t.options),Zi.addBox(this,t)}</span>))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateMetasets(){const t=<span class="cstat-no" title="statement not covered" >this._metasets,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length,</span>i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>if(t.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.index-e.index)</span>),i&gt;e){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >e;</span>t&lt;i;++t)<span class="cstat-no" title="statement not covered" >this._destroyDatasetMeta(t);<span class="cstat-no" title="statement not covered" >t</span></span>.splice(e,i-e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._sortedMetasets=t.slice(0).sort(cn("order","index"))}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.length&gt;e.length&amp;&amp;delete this._stacks,t.forEach((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >0===e.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e===t._dataset)</span>).length&amp;&amp;this._destroyDatasetMeta(i)}</span>))}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateControllers(){const t=<span class="cstat-no" title="statement not covered" >[],</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets;</span>let i,s;<span class="cstat-no" title="statement not covered" >for(this._removeUnreferencedMetasets(),i=0,s=e.length;i&lt;s;i++){const s=<span class="cstat-no" title="statement not covered" >e[i];</span>let n=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(i);</span>const o=<span class="cstat-no" title="statement not covered" >s.type||this.config.type;<span class="cstat-no" title="statement not covered" ></span>if(n.type&amp;&amp;n.type!==o&amp;&amp;(this._destroyDatasetMeta(i),n=this.getDatasetMeta(i)),n.type=o,n.indexAxis=s.indexAxis||Gs(o,this.options),n.order=s.order||0,n.index=i,n.label=""+s.label,n.visible=this.isDatasetVisible(i),n.controller)<span class="cstat-no" title="statement not covered" >n.controller.updateIndex(i),n.controller.linkScales();e</span>lse{const e=<span class="cstat-no" title="statement not covered" >Us.getController(o),</span>{datasetElementType:s,dataElementType:a}=<span class="cstat-no" title="statement not covered" >ne.datasets[o];<span class="cstat-no" title="statement not covered" ></span>Object.assign(e.prototype,{dataElementType:Us.getElement(a),datasetElementType:s&amp;&amp;Us.getElement(s)}),n.controller=new e(this,i),t.push(n.controller)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._updateMetasets(),t}<span class="fstat-no" title="function not covered" ></span>_r</span>esetElements(){<span class="cstat-no" title="statement not covered" >d(this.data.datasets,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(e).controller.reset()}</span>),this)}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._resetElements(),this.notifyPlugins("reset")}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this.config;<span class="cstat-no" title="statement not covered" ></span>e.update();c</span>onst i=<span class="cstat-no" title="statement not covered" >this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >this._animationsDisabled=!i.animation;<span class="cstat-no" title="statement not covered" ></span>if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.buildOrUpdateControllers();<span class="cstat-no" title="statement not covered" ></span>this.notifyPlugins("beforeElementsUpdate");l</span>et o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>t&lt;e;t++){const{controller:e}=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>i=<span class="cstat-no" title="statement not covered" >!s&amp;&amp;-1===n.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>e.buildOrUpdateElements(i),o=Math.max(+e.getMaxOverflow(),o)}<span class="cstat-no" title="statement not covered" ></span>o</span>=this._minPadding=i.layout.autoPadding?o:0,this._updateLayout(o),s||d(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.reset()}</span>)),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(cn("z","_idx"));c</span>onst{_active:a,_lastEvent:r}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>r?this._eventHandler(r,!0):a.length&amp;&amp;this._updateHoverStyles(a,a,!0),this.render()}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateScales(){<span class="cstat-no" title="statement not covered" >d(this.scales,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >Zi.removeBox(this,t)}</span>)),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}<span class="fstat-no" title="function not covered" ></span>_c</span>heckEventBindings(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >new Set(Object.keys(this._listeners)),</span>i=<span class="cstat-no" title="statement not covered" >new Set(t.events);<span class="cstat-no" title="statement not covered" ></span>S(e,i)&amp;&amp;!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateHiddenIndices(){const{_hiddenIndices:t}=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this._getUniformDataChanges()||[];<span class="cstat-no" title="statement not covered" ></span>for(const{method:i,start:s,count:n}of e){<span class="cstat-no" title="statement not covered" >mn(t,s,"_removeElements"===i?-n:n)}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etUniformDataChanges(){const t=<span class="cstat-no" title="statement not covered" >this._dataChanges;<span class="cstat-no" title="statement not covered" ></span>if(!t||!t.length)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._dataChanges=[];c</span>onst e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new Set(t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[0]===e)</span>).map((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e+","+t.splice(1).join(","))</span>)),</span></span>s=<span class="cstat-no" title="statement not covered" >i(0);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >1;</span>t&lt;e;t++)<span class="cstat-no" title="statement not covered" >if(!S(s,i(t)))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn Array.from(s).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.split(","))</span>).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{method:t[1],start:+t[2],count:+t[3]})</span>))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateLayout(t){<span class="cstat-no" title="statement not covered" >if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >Z</span></span>i.update(this,this.width,this.height,t);c</span>onst e=<span class="cstat-no" title="statement not covered" >this.chartArea,</span>i=<span class="cstat-no" title="statement not covered" >e.width&lt;=0||e.height&lt;=0;<span class="cstat-no" title="statement not covered" ></span>this._layers=[],d(this.boxes,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;"chartArea"===t.position||(t.configure&amp;&amp;t.configure(),this._layers.push(...t._layers()))}</span>),this),this._layers.forEach((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t._idx=e}</span>)),this.notifyPlugins("afterLayout")}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateDatasets(t){<span class="cstat-no" title="statement not covered" >if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>t&lt;e;++t)<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t).controller.configure();<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>e&lt;i;++e)<span class="cstat-no" title="statement not covered" >this._updateDataset(e,k(t)?t({datasetIndex:e}):t);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDatasetsUpdate",{mode:t})}</span>}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateDataset(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>s=<span class="cstat-no" title="statement not covered" >{meta:i,index:t,mode:e,cancelable:!0};<span class="cstat-no" title="statement not covered" ></span>!1!==this.notifyPlugins("beforeDatasetUpdate",s)&amp;&amp;(i.controller._update(e),s.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",s))}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&amp;&amp;(mt.has(this)?this.attached&amp;&amp;!mt.running(this)&amp;&amp;mt.start(this):(this.draw(),dn({chart:this})))}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){let t;<span class="cstat-no" title="statement not covered" >if(this._resizeBeforeDraw){const{width:t,height:e}=<span class="cstat-no" title="statement not covered" >this._resizeBeforeDraw;<span class="cstat-no" title="statement not covered" ></span>this._resize(t,e),this._resizeBeforeDraw=null}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.clear(),this.width&lt;=0||this.height&lt;=0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._layers;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;e.length&amp;&amp;e[t].z&lt;=0;++t)<span class="cstat-no" title="statement not covered" >e[t].draw(this.chartArea);<span class="cstat-no" title="statement not covered" >f</span></span>or(this._drawDatasets();t&lt;e.length;++t)<span class="cstat-no" title="statement not covered" >e[t].draw(this.chartArea);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDraw")}<span class="fstat-no" title="function not covered" ></span>_g</span>etSortedDatasetMetas(t){const e=<span class="cstat-no" title="statement not covered" >this._sortedMetasets,</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s,n;<span class="cstat-no" title="statement not covered" >for(s=0,n=e.length;s&lt;n;++s){const n=<span class="cstat-no" title="statement not covered" >e[s];<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;!n.visible||i.push(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tSortedVisibleDatasetMetas(){<span class="cstat-no" title="statement not covered" >return this._getSortedDatasetMetas(!0)}<span class="fstat-no" title="function not covered" ></span>_d</span>rawDatasets(){<span class="cstat-no" title="statement not covered" >if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.getSortedVisibleDatasetMetas();<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >t.length-1;</span>e&gt;=0;--e)<span class="cstat-no" title="statement not covered" >this._drawDataset(t[e]);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDatasetsDraw")}<span class="fstat-no" title="function not covered" ></span>_d</span>rawDataset(t){const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >t._clip,</span>s=<span class="cstat-no" title="statement not covered" >!i.disabled,</span>n=<span class="cstat-no" title="statement not covered" >this.chartArea,</span>o=<span class="cstat-no" title="statement not covered" >{meta:t,index:t.index,cancelable:!0};<span class="cstat-no" title="statement not covered" ></span>!1!==this.notifyPlugins("beforeDatasetDraw",o)&amp;&amp;(s&amp;&amp;Pe(e,{left:!1===i.left?0:n.left-i.left,right:!1===i.right?this.width:n.right+i.right,top:!1===i.top?0:n.top-i.top,bottom:!1===i.bottom?this.height:n.bottom+i.bottom}),t.controller.draw(),s&amp;&amp;De(e),o.cancelable=!1,this.notifyPlugins("afterDatasetDraw",o))}<span class="fstat-no" title="function not covered" ></span>is</span>PointInArea(t){<span class="cstat-no" title="statement not covered" >return Se(t,this.chartArea,this._minPadding)}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsAtEventForMode(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >Vi.modes[e];<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof n?n(this,t,i,s):[]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDatasetMeta(t){const e=<span class="cstat-no" title="statement not covered" >this.data.datasets[t],</span>i=<span class="cstat-no" title="statement not covered" >this._metasets;</span>let s=<span class="cstat-no" title="statement not covered" >i.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;t._dataset===e)</span>).pop();<span class="cstat-no" title="statement not covered" ></span>return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&amp;&amp;e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(s)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(){<span class="cstat-no" title="statement not covered" >return this.$context||(this.$context=_i(null,{chart:this,type:"chart"}))}<span class="fstat-no" title="function not covered" ></span>ge</span>tVisibleDatasetCount(){<span class="cstat-no" title="statement not covered" >return this.getSortedVisibleDatasetMetas().length}<span class="fstat-no" title="function not covered" ></span>is</span>DatasetVisible(t){const e=<span class="cstat-no" title="statement not covered" >this.data.datasets[t];<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>return"boolean"==typeof i.hidden?!i.hidden:!e.hidden}<span class="fstat-no" title="function not covered" ></span>se</span>tDatasetVisibility(t,e){<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t).hidden=!e}<span class="fstat-no" title="function not covered" ></span>to</span>ggleDataVisibility(t){<span class="cstat-no" title="statement not covered" >this._hiddenIndices[t]=!this._hiddenIndices[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataVisibility(t){<span class="cstat-no" title="statement not covered" >return!this._hiddenIndices[t]}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateVisibility(t,e,i){const s=<span class="cstat-no" title="statement not covered" >i?"show":"hide",</span>n=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>o=<span class="cstat-no" title="statement not covered" >n.controller._resolveAnimations(void 0,s);<span class="cstat-no" title="statement not covered" ></span>M(e)?(n.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),o.update(n,{visible:i}),this.update((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.datasetIndex===t?s:void 0)</span>))}<span class="fstat-no" title="function not covered" ></span>hi</span>de(t,e){<span class="cstat-no" title="statement not covered" >this._updateVisibility(t,e,!1)}<span class="fstat-no" title="function not covered" ></span>sh</span>ow(t,e){<span class="cstat-no" title="statement not covered" >this._updateVisibility(t,e,!0)}<span class="fstat-no" title="function not covered" ></span>_d</span>estroyDatasetMeta(t){const e=<span class="cstat-no" title="statement not covered" >this._metasets[t];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.controller&amp;&amp;e.controller._destroy(),delete this._metasets[t]}<span class="fstat-no" title="function not covered" ></span>_s</span>top(){let t,e;<span class="cstat-no" title="statement not covered" >for(this.stop(),mt.remove(this),t=0,e=this.data.datasets.length;t&lt;e;++t)<span class="cstat-no" title="statement not covered" >this._destroyDatasetMeta(t)}<span class="fstat-no" title="function not covered" ></span></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.notifyPlugins("beforeDestroy");c</span>onst{canvas:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._stop(),this.config.clearCache(),t&amp;&amp;(this.unbindEvents(),we(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),this.notifyPlugins("destroy"),delete gn[this.id],this.notifyPlugins("afterDestroy")}<span class="fstat-no" title="function not covered" ></span>to</span>Base64Image(...t){<span class="cstat-no" title="statement not covered" >return this.canvas.toDataURL(...t)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndEvents(){<span class="cstat-no" title="statement not covered" >this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}<span class="fstat-no" title="function not covered" ></span>bi</span>ndUserEvents(){const t=<span class="cstat-no" title="statement not covered" >this._listeners,</span>e=<span class="cstat-no" title="statement not covered" >this.platform,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >e.addEventListener(this,i,s),t[i]=s}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >t.offsetX=e,t.offsetY=i,this._eventHandler(t)}</span>;<span class="cstat-no" title="statement not covered" ></span>d(this.options.events,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >i(t,s))</span>)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndResponsiveEvents(){<span class="cstat-no" title="statement not covered" >this._responsiveListeners||(this._responsiveListeners={});c</span>onst t=<span class="cstat-no" title="statement not covered" >this._responsiveListeners,</span>e=<span class="cstat-no" title="statement not covered" >this.platform,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >e.addEventListener(this,i,s),t[i]=s}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >t[i]&amp;&amp;(e.removeEventListener(this,i,s),delete t[i])}</span>,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.canvas&amp;&amp;this.resize(t,e)}</span>;</span>let o;const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s("attach",a),this.attached=!0,this.resize(),i("resize",n),i("detach",o)}</span>;<span class="cstat-no" title="statement not covered" ></span>o=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.attached=!1,s("resize",n),this._stop(),this._resize(0,0),i("attach",a)}</span>,e.isAttached(this.canvas)?a():o()}<span class="fstat-no" title="function not covered" ></span>un</span>bindEvents(){<span class="cstat-no" title="statement not covered" >d(this._listeners,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.platform.removeEventListener(this,e,t)}</span>)),this._listeners={},d(this._responsiveListeners,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.platform.removeEventListener(this,e,t)}</span>)),this._responsiveListeners=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>dateHoverStyle(t,e,i){const s=<span class="cstat-no" title="statement not covered" >i?"set":"remove";</span>let n,o,a,r;<span class="cstat-no" title="statement not covered" >for("dataset"===e&amp;&amp;(n=this.getDatasetMeta(t[0].datasetIndex),n.controller["_"+s+"DatasetHoverStyle"]()),a=0,r=t.length;a&lt;r;++a){<span class="cstat-no" title="statement not covered" >o=t[a];c</span>onst e=<span class="cstat-no" title="statement not covered" >o&amp;&amp;this.getDatasetMeta(o.datasetIndex).controller;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e[s+"HoverStyle"](o.element,o.datasetIndex,o.index)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tActiveElements(){<span class="cstat-no" title="statement not covered" >return this._active||[]}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveElements(t){const e=<span class="cstat-no" title="statement not covered" >this._active||[],</span>i=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >({</span>datasetIndex:t,index:e})=&gt;{const i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("No dataset found at index "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{datasetIndex:t,element:i.data[e],index:e}}</span>));<span class="cstat-no" title="statement not covered" ></span>!u(i,e)&amp;&amp;(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}<span class="fstat-no" title="function not covered" ></span>no</span>tifyPlugins(t,e,i){<span class="cstat-no" title="statement not covered" >return this._plugins.notify(this,t,e,i)}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateHoverStyles(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.options.hover,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.datasetIndex===e.datasetIndex&amp;&amp;t.index===e.index)</span>))</span>),</span></span>o=<span class="cstat-no" title="statement not covered" >n(e,t),</span>a=<span class="cstat-no" title="statement not covered" >i?t:n(t,e);<span class="cstat-no" title="statement not covered" ></span>o.length&amp;&amp;this.updateHoverStyle(o,s.mode,!1),a.length&amp;&amp;s.mode&amp;&amp;this.updateHoverStyle(a,s.mode,!0)}<span class="fstat-no" title="function not covered" ></span>_e</span>ventHandler(t,e){const i=<span class="cstat-no" title="statement not covered" >{event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >(e.options.events||this.options.events).includes(t.native.type);<span class="cstat-no" title="statement not covered" ></span></span>if(!1===this.notifyPlugins("beforeEvent",i,s))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._handleEvent(t,e,i.inChartArea);<span class="cstat-no" title="statement not covered" ></span>return i.cancelable=!1,this.notifyPlugins("afterEvent",i,s),(n||i.changed)&amp;&amp;this.render(),this}<span class="fstat-no" title="function not covered" ></span>_h</span>andleEvent(t,e,i){const{_active:s=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>options:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >this._getActiveElements(t,s,i,o),</span>r=<span class="cstat-no" title="statement not covered" >P(t),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >return i&amp;&amp;"mouseout"!==t.type?s?e:t:null}</span>(t,this._lastEvent,i,r);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(this._lastEvent=null,c(n.onHover,[t,a,this],this),r&amp;&amp;c(n.onClick,[t,a,this],this));c</span>onst h=<span class="cstat-no" title="statement not covered" >!u(a,s);<span class="cstat-no" title="statement not covered" ></span>return(h||e)&amp;&amp;(this._active=a,this._updateHoverStyles(a,s,e)),this._lastEvent=l,h}<span class="fstat-no" title="function not covered" ></span>_g</span>etActiveElements(t,e,i,s){<span class="cstat-no" title="statement not covered" >if("mouseout"===t.type)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(!i)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.options.hover;<span class="cstat-no" title="statement not covered" ></span>return this.getElementsAtEventForMode(t,n.mode,n,s)}</span>}const xn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >d(bn.instances,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t._plugins.invalidate())</span>),</span></span>_n=<span class="cstat-no" title="statement not covered" >!0;</span>function <span class="fstat-no" title="function not covered" >yn(</span>){<span class="cstat-no" title="statement not covered" >throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}<span class="cstat-no" title="statement not covered" ></span>Object.defineProperties(bn,{defaults:{enumerable:_n,value:ne},instances:{enumerable:_n,value:gn},overrides:{enumerable:_n,value:te},registry:{enumerable:_n,value:Us},version:{enumerable:_n,value:"3.9.1"},getChart:{enumerable:_n,value:pn},register:{enumerable:_n,value:<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;{<span class="cstat-no" title="statement not covered" >Us.add(...t),xn()}</span>},unregister:{enumerable:_n,value:<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;{<span class="cstat-no" title="statement not covered" >Us.remove(...t),xn()}</span>}});c</span>lass vn{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.options=t||{}}<span class="fstat-no" title="function not covered" ></span>in</span>it(t){}<span class="fstat-no" title="function not covered" >fo</span>rmats(){<span class="cstat-no" title="statement not covered" >return yn()}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return yn()}<span class="fstat-no" title="function not covered" ></span>fo</span>rmat(t,e){<span class="cstat-no" title="statement not covered" >return yn()}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t,e,i){<span class="cstat-no" title="statement not covered" >return yn()}<span class="fstat-no" title="function not covered" ></span>di</span>ff(t,e,i){<span class="cstat-no" title="statement not covered" >return yn()}<span class="fstat-no" title="function not covered" ></span>st</span>artOf(t,e,i){<span class="cstat-no" title="statement not covered" >return yn()}<span class="fstat-no" title="function not covered" ></span>en</span>dOf(t,e){<span class="cstat-no" title="statement not covered" >return yn()}</span>}<span class="cstat-no" title="statement not covered" >vn.override=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >Object.assign(vn.prototype,t)}</span>;v</span>ar wn=<span class="cstat-no" title="statement not covered" >{_date:vn};</span>function <span class="fstat-no" title="function not covered" >Mn(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.iScale,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!t._cache.$bar){const i=<span class="cstat-no" title="statement not covered" >t.getMatchingVisibleMetas(e);</span>let s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >i.length;</span>e&lt;n;e++)<span class="cstat-no" title="statement not covered" >s=s.concat(i[e].controller.getAllParsedValues(t));<span class="cstat-no" title="statement not covered" >t</span></span>._cache.$bar=rt(s.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e)</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t._cache.$bar}</span>(e,t.type);</span>let s,n,o,a,r=<span class="cstat-no" title="statement not covered" >e._length;</span>const l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >32767!==o&amp;&amp;-32768!==o&amp;&amp;(M(a)&amp;&amp;(r=Math.min(r,Math.abs(o-a)||r)),a=o)}</span>;<span class="cstat-no" title="statement not covered" ></span>for(s=0,n=i.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o=e.getPixelForValue(i[s]),l();<span class="cstat-no" title="statement not covered" >f</span></span>or(a=void 0,s=0,n=e.ticks.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o=e.getPixelForTick(s),l();<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >kn(</span>t,e,i,n){<span class="cstat-no" title="statement not covered" >return s(t)?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i.parse(t[0],s),</span>o=<span class="cstat-no" title="statement not covered" >i.parse(t[1],s),</span>a=<span class="cstat-no" title="statement not covered" >Math.min(n,o),</span>r=<span class="cstat-no" title="statement not covered" >Math.max(n,o);</span>let l=<span class="cstat-no" title="statement not covered" >a,</span>h=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>Math.abs(a)&gt;Math.abs(r)&amp;&amp;(l=r,h=a),e[i.axis]=h,e._custom={barStart:l,barEnd:h,start:n,end:o,min:a,max:r}}</span>(t,e,i,n):e[i.axis]=i.parse(t,n),e}</span>function <span class="fstat-no" title="function not covered" >Sn(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.iScale,</span>o=<span class="cstat-no" title="statement not covered" >t.vScale,</span>a=<span class="cstat-no" title="statement not covered" >n.getLabels(),</span>r=<span class="cstat-no" title="statement not covered" >n===o,</span>l=<span class="cstat-no" title="statement not covered" >[];</span>let h,c,d,u;<span class="cstat-no" title="statement not covered" >for(h=i,c=i+s;h&lt;c;++h)<span class="cstat-no" title="statement not covered" >u=e[h],d={},d[n.axis]=r||n.parse(a[h],h),l.push(kn(u,d,o,h));<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}</span>function <span class="fstat-no" title="function not covered" >Pn(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;void 0!==t.barStart&amp;&amp;void 0!==t.barEnd}</span>function <span class="fstat-no" title="function not covered" >Dn(</span>t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >e.borderSkipped;</span>const o=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return void(t.borderSkipped=o);<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===n)<span class="cstat-no" title="statement not covered" >return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});c</span></span>onst{start:a,end:r,reverse:l,top:h,bottom:c}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){let e,i,s,n,o;<span class="cstat-no" title="statement not covered" >return t.horizontal?(e=t.base&gt;t.x,i="left",s="right"):(e=t.base&lt;t.y,i="bottom",s="top"),e?(n="end",o="start"):(n="start",o="end"),{start:i,end:s,reverse:e,top:n,bottom:o}}</span>(t);<span class="cstat-no" title="statement not covered" ></span>"middle"===n&amp;&amp;i&amp;&amp;(t.enableBorderRadius=!0,(i._top||0)===s?n=h:(i._bottom||0)===s?n=c:(o[On(c,a,r,l)]=!0,n=h)),o[On(n,a,r,l)]=!0,t.borderSkipped=o}</span>function <span class="fstat-no" title="function not covered" >On(</span>t,e,i,s){var n,o,a;<span class="cstat-no" title="statement not covered" >return s?(a=i,t=Cn(t=(n=t)===(o=e)?a:n===a?o:n,i,e)):t=Cn(t,e,i),t}</span>function <span class="fstat-no" title="function not covered" >Cn(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return"start"===t?e:"end"===t?i:t}</span>function <span class="fstat-no" title="function not covered" >An(</span>t,{inflateAmount:e},i){<span class="cstat-no" title="statement not covered" >t.inflateAmount="auto"===e?1===i?.33:0:e}</span>class Tn extends Ls{<span class="fstat-no" title="function not covered" >pa</span>rsePrimitiveData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return Sn(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return Sn(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){const{iScale:n,vScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>{xAxisKey:a=<span class="branch-0 cbranch-no" title="branch not covered" >"x",</span>yAxisKey:r=<span class="branch-0 cbranch-no" title="branch not covered" >"y"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>l=<span class="cstat-no" title="statement not covered" >"x"===n.axis?a:r,</span>h=<span class="cstat-no" title="statement not covered" >"x"===o.axis?a:r,</span>c=<span class="cstat-no" title="statement not covered" >[];</span>let d,u,f,g;<span class="cstat-no" title="statement not covered" >for(d=i,u=i+s;d&lt;u;++d)<span class="cstat-no" title="statement not covered" >g=e[d],f={},f[n.axis]=n.parse(y(g,l),d),c.push(kn(y(g,h),f,o,d));<span class="cstat-no" title="statement not covered" >r</span></span>eturn c}<span class="fstat-no" title="function not covered" ></span>up</span>dateRangeFromParsed(t,e,i,s){<span class="cstat-no" title="statement not covered" >super.updateRangeFromParsed(t,e,i,s);c</span>onst n=<span class="cstat-no" title="statement not covered" >i._custom;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;e===this._cachedMeta.vScale&amp;&amp;(t.min=Math.min(t.min,n.min),t.max=Math.max(t.max,n.max))}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){<span class="cstat-no" title="statement not covered" >return 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{iScale:i,vScale:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>o=<span class="cstat-no" title="statement not covered" >n._custom,</span>a=<span class="cstat-no" title="statement not covered" >Pn(o)?"["+o.start+", "+o.end+"]":""+s.getLabelForValue(n[s.axis]);<span class="cstat-no" title="statement not covered" ></span>return{label:""+i.getLabelForValue(n[i.axis]),value:a}}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,super.initialize();<span class="cstat-no" title="statement not covered" >t</span>his._cachedMeta.stack=this.getDataset().stack}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.updateElements(e.data,0,e.data.length,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,s,n){const o=<span class="cstat-no" title="statement not covered" >"reset"===n,</span>{index:a,_cachedMeta:{vScale:r}}=<span class="cstat-no" title="statement not covered" >this,</span>l=<span class="cstat-no" title="statement not covered" >r.getBasePixel(),</span>h=<span class="cstat-no" title="statement not covered" >r.isHorizontal(),</span>c=<span class="cstat-no" title="statement not covered" >this._getRuler(),</span>{sharedOptions:d,includeOptions:u}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,n);<span class="cstat-no" title="statement not covered" ></span>for(let f=<span class="cstat-no" title="statement not covered" >e;</span>f&lt;e+s;f++){const e=<span class="cstat-no" title="statement not covered" >this.getParsed(f),</span>s=<span class="cstat-no" title="statement not covered" >o||i(e[r.axis])?{base:l,head:l}:this._calculateBarValuePixels(f),</span>g=<span class="cstat-no" title="statement not covered" >this._calculateBarIndexPixels(f,c),</span>p=<span class="cstat-no" title="statement not covered" >(e._stacks||{})[r.axis],</span>m=<span class="cstat-no" title="statement not covered" >{horizontal:h,base:s.base,enableBorderRadius:!p||Pn(e._custom)||a===p._top||a===p._bottom,x:h?s.head:g.center,y:h?g.center:s.head,height:h?g.size:Math.abs(s.size),width:h?Math.abs(s.size):g.size};<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;(m.options=d||this.resolveDataElementOptions(f,t[f].active?"active":n));c</span>onst b=<span class="cstat-no" title="statement not covered" >m.options||t[f].options;<span class="cstat-no" title="statement not covered" ></span>Dn(m,b,p,a),An(m,b,c.ratio),this.updateElement(t[f],f,m,n)}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etStacks(t,e){const{iScale:s}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >s.getMatchingVisibleMetas(this._type).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.controller.options.grouped)</span>),</span>o=<span class="cstat-no" title="statement not covered" >s.options.stacked,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >t.controller.getParsed(e),</span>n=<span class="cstat-no" title="statement not covered" >s&amp;&amp;s[t.vScale.axis];<span class="cstat-no" title="statement not covered" ></span>if(i(n)||isNaN(n))<span class="cstat-no" title="statement not covered" >return!0}</span></span>;<span class="cstat-no" title="statement not covered" ></span>for(const i of n)<span class="cstat-no" title="statement not covered" >if((void 0===e||!r(i))&amp;&amp;((!1===o||-1===a.indexOf(i.stack)||void 0===o&amp;&amp;void 0===i.stack)&amp;&amp;a.push(i.stack),i.index===t))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn a.length||a.push(void 0),a}<span class="fstat-no" title="function not covered" ></span>_g</span>etStackCount(t){<span class="cstat-no" title="statement not covered" >return this._getStacks(void 0,t).length}<span class="fstat-no" title="function not covered" ></span>_g</span>etStackIndex(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this._getStacks(t,i),</span>n=<span class="cstat-no" title="statement not covered" >void 0!==e?s.indexOf(e):-1;<span class="cstat-no" title="statement not covered" ></span>return-1===n?s.length-1:n}<span class="fstat-no" title="function not covered" ></span>_g</span>etRuler(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.iScale,</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=e.data.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >s.push(i.getPixelForValue(this.getParsed(n)[i.axis],n));c</span></span>onst a=<span class="cstat-no" title="statement not covered" >t.barThickness;<span class="cstat-no" title="statement not covered" ></span>return{min:a||Mn(e),pixels:s,start:i._startPixel,end:i._endPixel,stackCount:this._getStackCount(),scale:i,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}<span class="fstat-no" title="function not covered" ></span>_c</span>alculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:s},options:{base:n,minBarLength:o}}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >n||0,</span>r=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>l=<span class="cstat-no" title="statement not covered" >r._custom,</span>h=<span class="cstat-no" title="statement not covered" >Pn(l);</span>let c,d,u=<span class="cstat-no" title="statement not covered" >r[e.axis],</span>f=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >s?this.applyStack(e,r,s):u;<span class="cstat-no" title="statement not covered" ></span>g!==u&amp;&amp;(f=g-u,g=u),h&amp;&amp;(u=l.barStart,g=l.barEnd-l.barStart,0!==u&amp;&amp;z(u)!==z(l.barEnd)&amp;&amp;(f=0),f+=u);c</span>onst p=<span class="cstat-no" title="statement not covered" >i(n)||h?f:n;</span>let m=<span class="cstat-no" title="statement not covered" >e.getPixelForValue(p);<span class="cstat-no" title="statement not covered" ></span>if(c=this.chart.getDataVisibility(t)?e.getPixelForValue(f+g):m,d=c-m,Math.abs(d)&lt;o){<span class="cstat-no" title="statement not covered" >d=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return 0!==t?z(t):(e.isHorizontal()?1:-1)*(e.min&gt;=i?1:-1)}</span>(d,e,a)*o,u===a&amp;&amp;(m-=d/2);c</span>onst t=<span class="cstat-no" title="statement not covered" >e.getPixelForDecimal(0),</span>i=<span class="cstat-no" title="statement not covered" >e.getPixelForDecimal(1),</span>s=<span class="cstat-no" title="statement not covered" >Math.min(t,i),</span>n=<span class="cstat-no" title="statement not covered" >Math.max(t,i);<span class="cstat-no" title="statement not covered" ></span>m=Math.max(Math.min(m,n),s),c=m+d}<span class="cstat-no" title="statement not covered" ></span>i</span>f(m===e.getPixelForValue(a)){const t=<span class="cstat-no" title="statement not covered" >z(d)*e.getLineWidthForValue(a)/2;<span class="cstat-no" title="statement not covered" ></span>m+=t,d-=t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{size:d,base:m,head:c,center:c+d/2}}<span class="fstat-no" title="function not covered" ></span>_c</span>alculateBarIndexPixels(t,e){const s=<span class="cstat-no" title="statement not covered" >e.scale,</span>n=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >n.skipNull,</span>a=<span class="cstat-no" title="statement not covered" >r(n.maxBarThickness,1/0);</span>let l,h;<span class="cstat-no" title="statement not covered" >if(e.grouped){const s=<span class="cstat-no" title="statement not covered" >o?this._getStackCount(t):e.stackCount,</span>r=<span class="cstat-no" title="statement not covered" >"flex"===n.barThickness?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.pixels,</span>o=<span class="cstat-no" title="statement not covered" >n[t];</span>let a=<span class="cstat-no" title="statement not covered" >t&gt;0?n[t-1]:null,</span>r=<span class="cstat-no" title="statement not covered" >t&lt;n.length-1?n[t+1]:null;</span>const l=<span class="cstat-no" title="statement not covered" >i.categoryPercentage;<span class="cstat-no" title="statement not covered" ></span>null===a&amp;&amp;(a=o-(null===r?e.end-e.start:r-o)),null===r&amp;&amp;(r=o+o-a);c</span>onst h=<span class="cstat-no" title="statement not covered" >o-(o-Math.min(a,r))/2*l;<span class="cstat-no" title="statement not covered" ></span>return{chunk:Math.abs(r-a)/2*l/s,ratio:i.barPercentage,start:h}}</span>(t,e,n,s):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,s,n){const o=<span class="cstat-no" title="statement not covered" >s.barThickness;</span>let a,r;<span class="cstat-no" title="statement not covered" >return i(o)?(a=e.min*s.categoryPercentage,r=s.barPercentage):(a=o*n,r=1),{chunk:a/n,ratio:r,start:e.pixels[t]-a/2}}</span>(t,e,n,s),</span>c=<span class="cstat-no" title="statement not covered" >this._getStackIndex(this.index,this._cachedMeta.stack,o?t:void 0);<span class="cstat-no" title="statement not covered" ></span>l=r.start+r.chunk*c+r.chunk/2,h=Math.min(a,r.chunk*r.ratio)}</span>else <span class="cstat-no" title="statement not covered" >l=s.getPixelForValue(this.getParsed(t)[s.axis],t),h=Math.min(a,e.min*e.ratio);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{base:l-h/2,head:l+h/2,center:l,size:h}}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.vScale,</span>i=<span class="cstat-no" title="statement not covered" >t.data,</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >null!==this.getParsed(n)[e.axis]&amp;&amp;i[n].draw(this._ctx)}</span></span>}<span class="cstat-no" title="statement not covered" >Tn.id="bar",Tn.defaults={datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}},Tn.overrides={scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}};c</span>lass Ln extends Ls{<span class="fstat-no" title="function not covered" >in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,super.initialize()}<span class="fstat-no" title="function not covered" ></span>pa</span>rsePrimitiveData(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >super.parsePrimitiveData(t,e,i,s);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t++)<span class="cstat-no" title="statement not covered" >n[t]._custom=this.resolveDataElementOptions(t+i).radius;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >super.parseArrayData(t,e,i,s);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t++){const s=<span class="cstat-no" title="statement not covered" >e[i+t];<span class="cstat-no" title="statement not covered" ></span>n[t]._custom=r(s[2],this.resolveDataElementOptions(t+i).radius)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >super.parseObjectData(t,e,i,s);<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;n.length;t++){const s=<span class="cstat-no" title="statement not covered" >e[i+t];<span class="cstat-no" title="statement not covered" ></span>n[t]._custom=r(s&amp;&amp;s.r&amp;&amp;+s.r,this.resolveDataElementOptions(t+i).radius)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;</span>let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >t.length-1;</span>i&gt;=0;--i)<span class="cstat-no" title="statement not covered" >e=Math.max(e,t[i].size(this.resolveDataElementOptions(i))/2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e&gt;0&amp;&amp;e}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{xScale:i,yScale:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>o=<span class="cstat-no" title="statement not covered" >i.getLabelForValue(n.x),</span>a=<span class="cstat-no" title="statement not covered" >s.getLabelForValue(n.y),</span>r=<span class="cstat-no" title="statement not covered" >n._custom;<span class="cstat-no" title="statement not covered" ></span>return{label:e.label,value:"("+o+", "+a+(r?", "+r:"")+")"}}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;<span class="cstat-no" title="statement not covered" ></span>this.updateElements(e,0,e.length,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>{iScale:o,vScale:a}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{sharedOptions:r,includeOptions:l}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,s),</span>h=<span class="cstat-no" title="statement not covered" >o.axis,</span>c=<span class="cstat-no" title="statement not covered" >a.axis;<span class="cstat-no" title="statement not covered" ></span>for(let d=<span class="cstat-no" title="statement not covered" >e;</span>d&lt;e+i;d++){const e=<span class="cstat-no" title="statement not covered" >t[d],</span>i=<span class="cstat-no" title="statement not covered" >!n&amp;&amp;this.getParsed(d),</span>u=<span class="cstat-no" title="statement not covered" >{},</span>f=<span class="cstat-no" title="statement not covered" >u[h]=n?o.getPixelForDecimal(.5):o.getPixelForValue(i[h]),</span>g=<span class="cstat-no" title="statement not covered" >u[c]=n?a.getBasePixel():a.getPixelForValue(i[c]);<span class="cstat-no" title="statement not covered" ></span>u.skip=isNaN(f)||isNaN(g),l&amp;&amp;(u.options=r||this.resolveDataElementOptions(d,e.active?"active":s),n&amp;&amp;(u.options.radius=0)),this.updateElement(e,d,u,s)}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>solveDataElementOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getParsed(t);</span>let s=<span class="cstat-no" title="statement not covered" >super.resolveDataElementOptions(t,e);<span class="cstat-no" title="statement not covered" ></span>s.$shared&amp;&amp;(s=Object.assign({},s,{$shared:!1}));c</span>onst n=<span class="cstat-no" title="statement not covered" >s.radius;<span class="cstat-no" title="statement not covered" ></span>return"active"!==e&amp;&amp;(s.radius=0),s.radius+=r(i&amp;&amp;i._custom,n),s}</span>}<span class="cstat-no" title="statement not covered" >Ln.id="bubble",Ln.defaults={datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}},Ln.overrides={scales:{x:{type:"linear"},y:{type:"linear"}},plugins:{tooltip:{callbacks:{title:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >""}</span>}}};c</span>lass En extends Ls{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}<span class="fstat-no" title="function not covered" ></span>li</span>nkScales(){}<span class="fstat-no" title="function not covered" >pa</span>rse(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getDataset().data,</span>s=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>if(!1===this._parsing)<span class="cstat-no" title="statement not covered" >s._parsed=i;e</span>lse{let o,a,r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >+i[t];<span class="cstat-no" title="statement not covered" ></span></span>if(n(i[t])){const{key:t=<span class="branch-0 cbranch-no" title="branch not covered" >"value"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing;<span class="cstat-no" title="statement not covered" ></span>r=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >+y(i[e],t)}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(o=t,a=t+e;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >s._parsed[o]=r(o)}</span></span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etRotation(){<span class="cstat-no" title="statement not covered" >return H(this.options.rotation-90)}<span class="fstat-no" title="function not covered" ></span>_g</span>etCircumference(){<span class="cstat-no" title="statement not covered" >return H(this.options.circumference)}<span class="fstat-no" title="function not covered" ></span>_g</span>etRotationExtents(){let t=<span class="cstat-no" title="statement not covered" >O,</span>e=<span class="cstat-no" title="statement not covered" >-O;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.chart.data.datasets.length;++i)<span class="cstat-no" title="statement not covered" >if(this.chart.isDatasetVisible(i)){const s=<span class="cstat-no" title="statement not covered" >this.chart.getDatasetMeta(i).controller,</span>n=<span class="cstat-no" title="statement not covered" >s._getRotation(),</span>o=<span class="cstat-no" title="statement not covered" >s._getCircumference();<span class="cstat-no" title="statement not covered" ></span>t=Math.min(t,n),e=Math.max(e,n+o)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{rotation:t,circumference:e-t}}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this.chart,</span>{chartArea:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >s.data,</span>o=<span class="cstat-no" title="statement not covered" >this.getMaxBorderWidth()+this.getMaxOffset(n)+this.options.spacing,</span>a=<span class="cstat-no" title="statement not covered" >Math.max((Math.min(i.width,i.height)-o)/2,0),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(l(this.options.cutout,a),1),</span>c=<span class="cstat-no" title="statement not covered" >this._getRingWeight(this.index),</span>{circumference:d,rotation:u}=<span class="cstat-no" title="statement not covered" >this._getRotationExtents(),</span>{ratioX:f,ratioY:g,offsetX:p,offsetY:m}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >1,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;O){const r=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >r+e,</span>h=<span class="cstat-no" title="statement not covered" >Math.cos(r),</span>c=<span class="cstat-no" title="statement not covered" >Math.sin(r),</span>d=<span class="cstat-no" title="statement not covered" >Math.cos(l),</span>u=<span class="cstat-no" title="statement not covered" >Math.sin(l),</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;<span class="cstat-no" title="statement not covered" >G(t,r,l,!0)?1:Math.max(e,e*i,s,s*i),</span></span>g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;<span class="cstat-no" title="statement not covered" >G(t,r,l,!0)?-1:Math.min(e,e*i,s,s*i),</span></span>p=<span class="cstat-no" title="statement not covered" >f(0,h,d),</span>m=<span class="cstat-no" title="statement not covered" >f(L,c,u),</span>b=<span class="cstat-no" title="statement not covered" >g(D,h,d),</span>x=<span class="cstat-no" title="statement not covered" >g(D+L,c,u);<span class="cstat-no" title="statement not covered" ></span>s=(p-b)/2,n=(m-x)/2,o=-(p+b)/2,a=-(m+x)/2}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{ratioX:s,ratioY:n,offsetX:o,offsetY:a}}</span>(u,d,r),</span>b=<span class="cstat-no" title="statement not covered" >(i.width-o)/f,</span>x=<span class="cstat-no" title="statement not covered" >(i.height-o)/g,</span>_=<span class="cstat-no" title="statement not covered" >Math.max(Math.min(b,x)/2,0),</span>y=<span class="cstat-no" title="statement not covered" >h(this.options.radius,_),</span>v=<span class="cstat-no" title="statement not covered" >(y-Math.max(y*r,0))/this._getVisibleDatasetWeightTotal();<span class="cstat-no" title="statement not covered" ></span>this.offsetX=p*y,this.offsetY=m*y,s.total=this.calculateTotal(),this.outerRadius=y-v*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-v*c,0),this.updateElements(n,0,n.length,t)}<span class="fstat-no" title="function not covered" ></span>_c</span>ircumference(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >this._getCircumference();<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;i.animation.animateRotate||!this.chart.getDataVisibility(t)||null===s._parsed[t]||s.data[t].hidden?0:this.calculateCircumference(s._parsed[t]*n/O)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>o=<span class="cstat-no" title="statement not covered" >this.chart,</span>a=<span class="cstat-no" title="statement not covered" >o.chartArea,</span>r=<span class="cstat-no" title="statement not covered" >o.options.animation,</span>l=<span class="cstat-no" title="statement not covered" >(a.left+a.right)/2,</span>h=<span class="cstat-no" title="statement not covered" >(a.top+a.bottom)/2,</span>c=<span class="cstat-no" title="statement not covered" >n&amp;&amp;r.animateScale,</span>d=<span class="cstat-no" title="statement not covered" >c?0:this.innerRadius,</span>u=<span class="cstat-no" title="statement not covered" >c?0:this.outerRadius,</span>{sharedOptions:f,includeOptions:g}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,s);</span>let p,m=<span class="cstat-no" title="statement not covered" >this._getRotation();<span class="cstat-no" title="statement not covered" ></span>for(p=0;p&lt;e;++p)<span class="cstat-no" title="statement not covered" >m+=this._circumference(p,n);<span class="cstat-no" title="statement not covered" >f</span></span>or(p=e;p&lt;e+i;++p){const e=<span class="cstat-no" title="statement not covered" >this._circumference(p,n),</span>i=<span class="cstat-no" title="statement not covered" >t[p],</span>o=<span class="cstat-no" title="statement not covered" >{x:l+this.offsetX,y:h+this.offsetY,startAngle:m,endAngle:m+e,circumference:e,outerRadius:u,innerRadius:d};<span class="cstat-no" title="statement not covered" ></span>g&amp;&amp;(o.options=f||this.resolveDataElementOptions(p,i.active?"active":s)),m+=e,this.updateElement(i,p,o,s)}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateTotal(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.data;</span>let i,s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;e.length;i++){const n=<span class="cstat-no" title="statement not covered" >t._parsed[i];<span class="cstat-no" title="statement not covered" ></span>null===n||isNaN(n)||!this.chart.getDataVisibility(i)||e[i].hidden||(s+=Math.abs(n))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateCircumference(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.total;<span class="cstat-no" title="statement not covered" ></span>return e&gt;0&amp;&amp;!isNaN(t)?O*(Math.abs(t)/e):0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>s=<span class="cstat-no" title="statement not covered" >i.data.labels||[],</span>n=<span class="cstat-no" title="statement not covered" >li(e._parsed[t],i.options.locale);<span class="cstat-no" title="statement not covered" ></span>return{label:s[t]||"",value:n}}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxBorderWidth(t){let e=<span class="cstat-no" title="statement not covered" >0;</span>const i=<span class="cstat-no" title="statement not covered" >this.chart;</span>let s,n,o,a,r;<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >for(s=0,n=i.data.datasets.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >if(i.isDatasetVisible(s)){<span class="cstat-no" title="statement not covered" >o=i.getDatasetMeta(s),t=o.data,a=o.controller;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span>f(!t)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=0,n=t.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >r=a.resolveDataElementOptions(s),"inner"!==r.borderAlign&amp;&amp;(e=Math.max(e,r.borderWidth||0,r.hoverBorderWidth||0));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOffset(t){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;++i){const t=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(i);<span class="cstat-no" title="statement not covered" ></span>e=Math.max(e,t.offset||0,t.hoverOffset||0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>_g</span>etRingWeightOffset(t){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t;++i)<span class="cstat-no" title="statement not covered" >this.chart.isDatasetVisible(i)&amp;&amp;(e+=this._getRingWeight(i));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>_g</span>etRingWeight(t){<span class="cstat-no" title="statement not covered" >return Math.max(r(this.chart.data.datasets[t].weight,1),0)}<span class="fstat-no" title="function not covered" ></span>_g</span>etVisibleDatasetWeightTotal(){<span class="cstat-no" title="statement not covered" >return this._getRingWeightOffset(this.chart.data.datasets.length)||1}</span>}<span class="cstat-no" title="statement not covered" >En.id="doughnut",En.defaults={datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"},En.descriptors={_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"spacing"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"spacing"!==t}</span>,En.overrides={aspectRatio:1,plugins:{legend:{labels:{<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data;<span class="cstat-no" title="statement not covered" ></span>if(e.labels.length&amp;&amp;e.datasets.length){const{labels:{pointStyle:i}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return e.labels.map((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;{const n=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(0).controller.getStyle(s);<span class="cstat-no" title="statement not covered" ></span>return{text:e,fillStyle:n.backgroundColor,strokeStyle:n.borderColor,lineWidth:n.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(s),index:s}}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[]}</span>},<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){<span class="cstat-no" title="statement not covered" >i.chart.toggleDataVisibility(e.index),i.chart.update()}</span>},tooltip:{callbacks:{title:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"",<span class="fstat-no" title="function not covered" ></span>la</span>bel(t){let e=<span class="cstat-no" title="statement not covered" >t.label;</span>const i=<span class="cstat-no" title="statement not covered" >": "+t.formattedValue;<span class="cstat-no" title="statement not covered" ></span>return s(e)?(e=e.slice(),e[0]+=i):e+=i,e}</span>}}}};c</span>lass Rn extends Ls{<span class="fstat-no" title="function not covered" >in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{dataset:i,data:s=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>_dataset:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled;</span>let{start:a,count:r}=<span class="cstat-no" title="statement not covered" >gt(e,s,o);<span class="cstat-no" title="statement not covered" ></span>this._drawStart=a,this._drawCount=r,pt(e)&amp;&amp;(a=0,r=s.length),i._chart=this.chart,i._datasetIndex=this.index,i._decimated=!!n._decimated,i.points=s;c</span>onst l=<span class="cstat-no" title="statement not covered" >this.resolveDatasetElementOptions(t);<span class="cstat-no" title="statement not covered" ></span>this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(i,void 0,{animated:!o,options:l},t),this.updateElements(s,a,r,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,s,n){const o=<span class="cstat-no" title="statement not covered" >"reset"===n,</span>{iScale:a,vScale:r,_stacked:l,_dataset:h}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{sharedOptions:c,includeOptions:d}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,n),</span>u=<span class="cstat-no" title="statement not covered" >a.axis,</span>f=<span class="cstat-no" title="statement not covered" >r.axis,</span>{spanGaps:g,segment:p}=<span class="cstat-no" title="statement not covered" >this.options,</span>m=<span class="cstat-no" title="statement not covered" >B(g)?g:Number.POSITIVE_INFINITY,</span>b=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled||o||"none"===n;</span>let x=<span class="cstat-no" title="statement not covered" >e&gt;0&amp;&amp;this.getParsed(e-1);<span class="cstat-no" title="statement not covered" ></span>for(let g=<span class="cstat-no" title="statement not covered" >e;</span>g&lt;e+s;++g){const e=<span class="cstat-no" title="statement not covered" >t[g],</span>s=<span class="cstat-no" title="statement not covered" >this.getParsed(g),</span>_=<span class="cstat-no" title="statement not covered" >b?e:{},</span>y=<span class="cstat-no" title="statement not covered" >i(s[f]),</span>v=<span class="cstat-no" title="statement not covered" >_[u]=a.getPixelForValue(s[u],g),</span>w=<span class="cstat-no" title="statement not covered" >_[f]=o||y?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,s,l):s[f],g);<span class="cstat-no" title="statement not covered" ></span>_.skip=isNaN(v)||isNaN(w)||y,_.stop=g&gt;0&amp;&amp;Math.abs(s[u]-x[u])&gt;m,p&amp;&amp;(_.parsed=s,_.raw=h.data[g]),d&amp;&amp;(_.options=c||this.resolveDataElementOptions(g,e.active?"active":n)),b||this.updateElement(e,g,_,n),x=s}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.dataset,</span>i=<span class="cstat-no" title="statement not covered" >e.options&amp;&amp;e.options.borderWidth||0,</span>s=<span class="cstat-no" title="statement not covered" >t.data||[];<span class="cstat-no" title="statement not covered" ></span>if(!s.length)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s[0].size(this.resolveDataElementOptions(0)),</span>o=<span class="cstat-no" title="statement not covered" >s[s.length-1].size(this.resolveDataElementOptions(s.length-1));<span class="cstat-no" title="statement not covered" ></span>return Math.max(i,n,o)/2}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}</span>}<span class="cstat-no" title="statement not covered" >Rn.id="line",Rn.defaults={datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1},Rn.overrides={scales:{_index_:{type:"category"},_value_:{type:"linear"}}};c</span>lass In extends Ls{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>s=<span class="cstat-no" title="statement not covered" >i.data.labels||[],</span>n=<span class="cstat-no" title="statement not covered" >li(e._parsed[t].r,i.options.locale);<span class="cstat-no" title="statement not covered" ></span>return{label:s[t]||"",value:n}}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return Ue.bind(this)(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;<span class="cstat-no" title="statement not covered" ></span>this._updateRadius(),this.updateElements(e,0,e.length,t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};<span class="cstat-no" title="statement not covered" ></span>return t.data.forEach((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >this.getParsed(i).r;<span class="cstat-no" title="statement not covered" ></span>!isNaN(s)&amp;&amp;this.chart.getDataVisibility(i)&amp;&amp;(s&lt;e.min&amp;&amp;(e.min=s),s&gt;e.max&amp;&amp;(e.max=s))}</span>)),e}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateRadius(){const t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >t.chartArea,</span>i=<span class="cstat-no" title="statement not covered" >t.options,</span>s=<span class="cstat-no" title="statement not covered" >Math.min(e.right-e.left,e.bottom-e.top),</span>n=<span class="cstat-no" title="statement not covered" >Math.max(s/2,0),</span>o=<span class="cstat-no" title="statement not covered" >(n-Math.max(i.cutoutPercentage?n/100*i.cutoutPercentage:1,0))/t.getVisibleDatasetCount();<span class="cstat-no" title="statement not covered" ></span>this.outerRadius=n-o*this.index,this.innerRadius=this.outerRadius-o}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>o=<span class="cstat-no" title="statement not covered" >this.chart,</span>a=<span class="cstat-no" title="statement not covered" >o.options.animation,</span>r=<span class="cstat-no" title="statement not covered" >this._cachedMeta.rScale,</span>l=<span class="cstat-no" title="statement not covered" >r.xCenter,</span>h=<span class="cstat-no" title="statement not covered" >r.yCenter,</span>c=<span class="cstat-no" title="statement not covered" >r.getIndexAngle(0)-.5*D;</span>let d,u=<span class="cstat-no" title="statement not covered" >c;</span>const f=<span class="cstat-no" title="statement not covered" >360/this.countVisibleElements();<span class="cstat-no" title="statement not covered" ></span>for(d=0;d&lt;e;++d)<span class="cstat-no" title="statement not covered" >u+=this._computeAngle(d,s,f);<span class="cstat-no" title="statement not covered" >f</span></span>or(d=e;d&lt;e+i;d++){const e=<span class="cstat-no" title="statement not covered" >t[d];</span>let i=<span class="cstat-no" title="statement not covered" >u,</span>g=<span class="cstat-no" title="statement not covered" >u+this._computeAngle(d,s,f),</span>p=<span class="cstat-no" title="statement not covered" >o.getDataVisibility(d)?r.getDistanceFromCenterForValue(this.getParsed(d).r):0;<span class="cstat-no" title="statement not covered" ></span>u=g,n&amp;&amp;(a.animateScale&amp;&amp;(p=0),a.animateRotate&amp;&amp;(i=g=c));c</span>onst m=<span class="cstat-no" title="statement not covered" >{x:l,y:h,innerRadius:0,outerRadius:p,startAngle:i,endAngle:g,options:this.resolveDataElementOptions(d,e.active?"active":s)};<span class="cstat-no" title="statement not covered" ></span>this.updateElement(e,d,m,s)}</span>}<span class="fstat-no" title="function not covered" ></span>co</span>untVisibleElements(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;</span>let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t.data.forEach((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >!isNaN(this.getParsed(i).r)&amp;&amp;this.chart.getDataVisibility(i)&amp;&amp;e++}</span>)),e}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeAngle(t,e,i){<span class="cstat-no" title="statement not covered" >return this.chart.getDataVisibility(t)?H(this.resolveDataElementOptions(t,e).angle||i):0}</span>}<span class="cstat-no" title="statement not covered" >In.id="polarArea",In.defaults={dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0},In.overrides={aspectRatio:1,plugins:{legend:{labels:{<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data;<span class="cstat-no" title="statement not covered" ></span>if(e.labels.length&amp;&amp;e.datasets.length){const{labels:{pointStyle:i}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return e.labels.map((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;{const n=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(0).controller.getStyle(s);<span class="cstat-no" title="statement not covered" ></span>return{text:e,fillStyle:n.backgroundColor,strokeStyle:n.borderColor,lineWidth:n.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(s),index:s}}</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[]}</span>},<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){<span class="cstat-no" title="statement not covered" >i.chart.toggleDataVisibility(e.index),i.chart.update()}</span>},tooltip:{callbacks:{title:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"",</span>label:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.data.labels[t.dataIndex]+": "+t.formattedValue}</span>}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};c</span>lass zn extends En{}<span class="cstat-no" title="statement not covered" >zn.id="pie",zn.defaults={cutout:0,rotation:0,circumference:360,radius:"100%"};c</span>lass Fn extends Ls{<span class="fstat-no" title="function not covered" >ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.vScale,</span>i=<span class="cstat-no" title="statement not covered" >this.getParsed(t);<span class="cstat-no" title="statement not covered" ></span>return{label:e.getLabels()[t],value:""+e.getLabelForValue(i[e.axis])}}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return Ue.bind(this)(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.dataset,</span>s=<span class="cstat-no" title="statement not covered" >e.data||[],</span>n=<span class="cstat-no" title="statement not covered" >e.iScale.getLabels();<span class="cstat-no" title="statement not covered" ></span>if(i.points=s,"resize"!==t){const e=<span class="cstat-no" title="statement not covered" >this.resolveDatasetElementOptions(t);<span class="cstat-no" title="statement not covered" ></span>this.options.showLine||(e.borderWidth=0);c</span>onst o=<span class="cstat-no" title="statement not covered" >{_loop:!0,_fullLoop:n.length===s.length,options:e};<span class="cstat-no" title="statement not covered" ></span>this.updateElement(i,void 0,o,t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.updateElements(s,0,s.length,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this._cachedMeta.rScale,</span>o=<span class="cstat-no" title="statement not covered" >"reset"===s;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >e;</span>a&lt;e+i;a++){const e=<span class="cstat-no" title="statement not covered" >t[a],</span>i=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(a,e.active?"active":s),</span>r=<span class="cstat-no" title="statement not covered" >n.getPointPositionForValue(a,this.getParsed(a).r),</span>l=<span class="cstat-no" title="statement not covered" >o?n.xCenter:r.x,</span>h=<span class="cstat-no" title="statement not covered" >o?n.yCenter:r.y,</span>c=<span class="cstat-no" title="statement not covered" >{x:l,y:h,angle:r.angle,skip:isNaN(l)||isNaN(h),options:i};<span class="cstat-no" title="statement not covered" ></span>this.updateElement(e,a,c,s)}</span>}</span>}<span class="cstat-no" title="statement not covered" >Fn.id="radar",Fn.defaults={datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}},Fn.overrides={aspectRatio:1,scales:{r:{type:"radialLinear"}}};c</span>lass Vn extends Ls{<span class="fstat-no" title="function not covered" >up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{data:i=<span class="branch-0 cbranch-no" title="branch not covered" >[]}</span>=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled;</span>let{start:n,count:o}=<span class="cstat-no" title="statement not covered" >gt(e,i,s);<span class="cstat-no" title="statement not covered" ></span>if(this._drawStart=n,this._drawCount=o,pt(e)&amp;&amp;(n=0,o=i.length),this.options.showLine){const{dataset:n,_dataset:o}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!o._decimated,n.points=i;c</span>onst a=<span class="cstat-no" title="statement not covered" >this.resolveDatasetElementOptions(t);<span class="cstat-no" title="statement not covered" ></span>a.segment=this.options.segment,this.updateElement(n,void 0,{animated:!s,options:a},t)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.updateElements(i,n,o,t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dElements(){const{showLine:t}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>!this.datasetElementType&amp;&amp;t&amp;&amp;(this.datasetElementType=Us.getElement("line")),super.addElements()}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,s,n){const o=<span class="cstat-no" title="statement not covered" >"reset"===n,</span>{iScale:a,vScale:r,_stacked:l,_dataset:h}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>c=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(e,n),</span>d=<span class="cstat-no" title="statement not covered" >this.getSharedOptions(c),</span>u=<span class="cstat-no" title="statement not covered" >this.includeOptions(n,d),</span>f=<span class="cstat-no" title="statement not covered" >a.axis,</span>g=<span class="cstat-no" title="statement not covered" >r.axis,</span>{spanGaps:p,segment:m}=<span class="cstat-no" title="statement not covered" >this.options,</span>b=<span class="cstat-no" title="statement not covered" >B(p)?p:Number.POSITIVE_INFINITY,</span>x=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled||o||"none"===n;</span>let _=<span class="cstat-no" title="statement not covered" >e&gt;0&amp;&amp;this.getParsed(e-1);<span class="cstat-no" title="statement not covered" ></span>for(let c=<span class="cstat-no" title="statement not covered" >e;</span>c&lt;e+s;++c){const e=<span class="cstat-no" title="statement not covered" >t[c],</span>s=<span class="cstat-no" title="statement not covered" >this.getParsed(c),</span>p=<span class="cstat-no" title="statement not covered" >x?e:{},</span>y=<span class="cstat-no" title="statement not covered" >i(s[g]),</span>v=<span class="cstat-no" title="statement not covered" >p[f]=a.getPixelForValue(s[f],c),</span>w=<span class="cstat-no" title="statement not covered" >p[g]=o||y?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,s,l):s[g],c);<span class="cstat-no" title="statement not covered" ></span>p.skip=isNaN(v)||isNaN(w)||y,p.stop=c&gt;0&amp;&amp;Math.abs(s[f]-_[f])&gt;b,m&amp;&amp;(p.parsed=s,p.raw=h.data[c]),u&amp;&amp;(p.options=d||this.resolveDataElementOptions(c,e.active?"active":n)),x||this.updateElement(e,c,p,n),_=s}<span class="cstat-no" title="statement not covered" ></span>t</span>his.updateSharedOptions(d,n,c)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.data||[];<span class="cstat-no" title="statement not covered" ></span>if(!this.options.showLine){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >e.length-1;</span>i&gt;=0;--i)<span class="cstat-no" title="statement not covered" >t=Math.max(t,e[i].size(this.resolveDataElementOptions(i))/2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t&gt;0&amp;&amp;t}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >t.dataset,</span>s=<span class="cstat-no" title="statement not covered" >i.options&amp;&amp;i.options.borderWidth||0;<span class="cstat-no" title="statement not covered" ></span>if(!e.length)<span class="cstat-no" title="statement not covered" >return s;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >e[0].size(this.resolveDataElementOptions(0)),</span>o=<span class="cstat-no" title="statement not covered" >e[e.length-1].size(this.resolveDataElementOptions(e.length-1));<span class="cstat-no" title="statement not covered" ></span>return Math.max(s,n,o)/2}</span>}<span class="cstat-no" title="statement not covered" >Vn.id="scatter",Vn.defaults={datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1},Vn.overrides={interaction:{mode:"point"},plugins:{tooltip:{callbacks:{title:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"",</span>label:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"("+t.label+", "+t.formattedValue+")"}</span>}},scales:{x:{type:"linear"},y:{type:"linear"}}};v</span>ar Bn=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,BarController:Tn,BubbleController:Ln,DoughnutController:En,LineController:Rn,PolarAreaController:In,PieController:zn,RadarController:Fn,ScatterController:Vn});</span>function <span class="fstat-no" title="function not covered" >Nn(</span>t,e,i){const{startAngle:s,pixelMargin:n,x:o,y:a,outerRadius:r,innerRadius:l}=<span class="cstat-no" title="statement not covered" >e;</span>let h=<span class="cstat-no" title="statement not covered" >n/r;<span class="cstat-no" title="statement not covered" ></span>t.beginPath(),t.arc(o,a,r,s-h,i+h),l&gt;n?(h=n/l,t.arc(o,a,l,i+h,s-h,!0)):t.arc(o,a,n,i+L,s-L),t.closePath(),t.clip()}</span>function <span class="fstat-no" title="function not covered" >Wn(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ui(t.options.borderRadius,["outerStart","outerEnd","innerStart","innerEnd"]);</span>const o=<span class="cstat-no" title="statement not covered" >(i-e)/2,</span>a=<span class="cstat-no" title="statement not covered" >Math.min(o,s*e/2),</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >(i-Math.min(o,t))*s/2;<span class="cstat-no" title="statement not covered" ></span>return Z(t,0,Math.min(o,e))}</span>;<span class="cstat-no" title="statement not covered" ></span>return{outerStart:r(n.outerStart),outerEnd:r(n.outerEnd),innerStart:Z(n.innerStart,0,a),innerEnd:Z(n.innerEnd,0,a)}}</span>function <span class="fstat-no" title="function not covered" >jn(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:i+t*Math.cos(e),y:s+t*Math.sin(e)}}</span>function <span class="fstat-no" title="function not covered" >Hn(</span>t,e,i,s,n,o){const{x:a,y:r,startAngle:l,pixelMargin:h,innerRadius:c}=<span class="cstat-no" title="statement not covered" >e,</span>d=<span class="cstat-no" title="statement not covered" >Math.max(e.outerRadius+s+i-h,0),</span>u=<span class="cstat-no" title="statement not covered" >c&gt;0?c+s+i+h:0;</span>let f=<span class="cstat-no" title="statement not covered" >0;</span>const g=<span class="cstat-no" title="statement not covered" >n-l;<span class="cstat-no" title="statement not covered" ></span>if(s){const t=<span class="cstat-no" title="statement not covered" >((c&gt;0?c-s:0)+(d&gt;0?d-s:0))/2;<span class="cstat-no" title="statement not covered" ></span>f=(g-(0!==t?g*t/(t+s):g))/2}</span>c</span>onst p=<span class="cstat-no" title="statement not covered" >(g-Math.max(.001,g*d-i/D)/d)/2,</span>m=<span class="cstat-no" title="statement not covered" >l+p+f,</span>b=<span class="cstat-no" title="statement not covered" >n-p-f,</span>{outerStart:x,outerEnd:_,innerStart:y,innerEnd:v}=<span class="cstat-no" title="statement not covered" >Wn(e,u,d,b-m),</span>w=<span class="cstat-no" title="statement not covered" >d-x,</span>M=<span class="cstat-no" title="statement not covered" >d-_,</span>k=<span class="cstat-no" title="statement not covered" >m+x/w,</span>S=<span class="cstat-no" title="statement not covered" >b-_/M,</span>P=<span class="cstat-no" title="statement not covered" >u+y,</span>O=<span class="cstat-no" title="statement not covered" >u+v,</span>C=<span class="cstat-no" title="statement not covered" >m+y/P,</span>A=<span class="cstat-no" title="statement not covered" >b-v/O;<span class="cstat-no" title="statement not covered" ></span>if(t.beginPath(),o){<span class="cstat-no" title="statement not covered" >if(t.arc(a,r,d,k,S),_&gt;0){const e=<span class="cstat-no" title="statement not covered" >jn(M,S,a,r);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,_,S,b+L)}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >jn(O,b,a,r);<span class="cstat-no" title="statement not covered" ></span>if(t.lineTo(e.x,e.y),v&gt;0){const e=<span class="cstat-no" title="statement not covered" >jn(O,A,a,r);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,v,b+L,A+Math.PI)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t.arc(a,r,u,b-v/u,m+y/u,!0),y&gt;0){const e=<span class="cstat-no" title="statement not covered" >jn(P,C,a,r);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,y,C+Math.PI,m-L)}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >jn(w,m,a,r);<span class="cstat-no" title="statement not covered" ></span>if(t.lineTo(i.x,i.y),x&gt;0){const e=<span class="cstat-no" title="statement not covered" >jn(w,k,a,r);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,x,m-L,k)}</span>}</span>else{<span class="cstat-no" title="statement not covered" >t.moveTo(a,r);c</span>onst e=<span class="cstat-no" title="statement not covered" >Math.cos(k)*d+a,</span>i=<span class="cstat-no" title="statement not covered" >Math.sin(k)*d+r;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(e,i);c</span>onst s=<span class="cstat-no" title="statement not covered" >Math.cos(S)*d+a,</span>n=<span class="cstat-no" title="statement not covered" >Math.sin(S)*d+r;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(s,n)}<span class="cstat-no" title="statement not covered" ></span>t</span>.closePath()}</span>function <span class="fstat-no" title="function not covered" >$n(</span>t,e,i,s,n,o){const{options:a}=<span class="cstat-no" title="statement not covered" >e,</span>{borderWidth:r,borderJoinStyle:l}=<span class="cstat-no" title="statement not covered" >a,</span>h=<span class="cstat-no" title="statement not covered" >"inner"===a.borderAlign;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(h?(t.lineWidth=2*r,t.lineJoin=l||"round"):(t.lineWidth=r,t.lineJoin=l||"bevel"),e.fullCircles&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{x:s,y:n,startAngle:o,pixelMargin:a,fullCircles:r}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >Math.max(e.outerRadius-a,0),</span>h=<span class="cstat-no" title="statement not covered" >e.innerRadius+a;</span>let c;<span class="cstat-no" title="statement not covered" >for(i&amp;&amp;Nn(t,e,o+O),t.beginPath(),t.arc(s,n,h,o+O,o,!0),c=0;c&lt;r;++c)<span class="cstat-no" title="statement not covered" >t.stroke();<span class="cstat-no" title="statement not covered" >f</span></span>or(t.beginPath(),t.arc(s,n,l,o,o+O),c=0;c&lt;r;++c)<span class="cstat-no" title="statement not covered" >t.stroke()}</span></span>(t,e,h),h&amp;&amp;Nn(t,e,n),Hn(t,e,i,s,n,o),t.stroke())}</span>class Yn extends Es{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],i),</span>{angle:n,distance:o}=<span class="cstat-no" title="statement not covered" >U(s,{x:t,y:e}),</span>{startAngle:a,endAngle:l,innerRadius:h,outerRadius:c,circumference:d}=<span class="cstat-no" title="statement not covered" >this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],i),</span>u=<span class="cstat-no" title="statement not covered" >this.options.spacing/2,</span>f=<span class="cstat-no" title="statement not covered" >r(d,l-a)&gt;=O||G(n,a,l),</span>g=<span class="cstat-no" title="statement not covered" >Q(o,h+u,c+u);<span class="cstat-no" title="statement not covered" ></span>return f&amp;&amp;g}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i,startAngle:s,endAngle:n,innerRadius:o,outerRadius:a}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius","circumference"],t),</span>{offset:r,spacing:l}=<span class="cstat-no" title="statement not covered" >this.options,</span>h=<span class="cstat-no" title="statement not covered" >(s+n)/2,</span>c=<span class="cstat-no" title="statement not covered" >(o+a+l+r)/2;<span class="cstat-no" title="statement not covered" ></span>return{x:e+Math.cos(h)*c,y:i+Math.sin(h)*c}}<span class="fstat-no" title="function not covered" ></span>to</span>oltipPosition(t){<span class="cstat-no" title="statement not covered" >return this.getCenterPoint(t)}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const{options:e,circumference:i}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >(e.offset||0)/2,</span>n=<span class="cstat-no" title="statement not covered" >(e.spacing||0)/2,</span>o=<span class="cstat-no" title="statement not covered" >e.circular;<span class="cstat-no" title="statement not covered" ></span>if(this.pixelMargin="inner"===e.borderAlign?.33:0,this.fullCircles=i&gt;O?Math.floor(i/O):0,0===i||this.innerRadius&lt;0||this.outerRadius&lt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.save();l</span>et a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >a=s/2;c</span>onst e=<span class="cstat-no" title="statement not covered" >(this.startAngle+this.endAngle)/2;<span class="cstat-no" title="statement not covered" ></span>t.translate(Math.cos(e)*a,Math.sin(e)*a),this.circumference&gt;=D&amp;&amp;(a=s)}<span class="cstat-no" title="statement not covered" ></span>t</span>.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor;c</span>onst r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r}=<span class="cstat-no" title="statement not covered" >e;</span>let l=<span class="cstat-no" title="statement not covered" >e.endAngle;<span class="cstat-no" title="statement not covered" ></span>if(o){<span class="cstat-no" title="statement not covered" >Hn(t,e,i,s,a+O,n);<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o;++e)<span class="cstat-no" title="statement not covered" >t.fill();<span class="cstat-no" title="statement not covered" >i</span></span>sNaN(r)||(l=a+r%O,r%O==0&amp;&amp;(l+=O))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Hn(t,e,i,s,l,n),t.fill(),l}</span>(t,this,a,n,o);<span class="cstat-no" title="statement not covered" ></span>$n(t,this,a,n,r,o),t.restore()}</span>}function <span class="fstat-no" title="function not covered" >Un(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>{<span class="cstat-no" title="statement not covered" >t.lineCap=r(i.borderCapStyle,e.borderCapStyle),t.setLineDash(r(i.borderDash,e.borderDash)),t.lineDashOffset=r(i.borderDashOffset,e.borderDashOffset),t.lineJoin=r(i.borderJoinStyle,e.borderJoinStyle),t.lineWidth=r(i.borderWidth,e.borderWidth),t.strokeStyle=r(i.borderColor,e.borderColor)}</span>function <span class="fstat-no" title="function not covered" >Xn(</span>t,e,i){<span class="cstat-no" title="statement not covered" >t.lineTo(i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >qn(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >t.length,</span>{start:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>end:o=<span class="branch-0 cbranch-no" title="branch not covered" >s-1}</span>=<span class="cstat-no" title="statement not covered" >i,</span>{start:a,end:r}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >Math.max(n,a),</span>h=<span class="cstat-no" title="statement not covered" >Math.min(o,r),</span>c=<span class="cstat-no" title="statement not covered" >n&lt;a&amp;&amp;o&lt;a||n&gt;r&amp;&amp;o&gt;r;<span class="cstat-no" title="statement not covered" ></span>return{count:s,start:l,loop:e.loop,ilen:h&lt;l&amp;&amp;!c?s+h-l:h-l}}</span>function <span class="fstat-no" title="function not covered" >Kn(</span>t,e,i,s){const{points:n,options:o}=<span class="cstat-no" title="statement not covered" >e,</span>{count:a,start:r,loop:l,ilen:h}=<span class="cstat-no" title="statement not covered" >qn(n,i,s),</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stepped?Oe:t.tension||"monotone"===t.cubicInterpolationMode?Ce:Xn}</span>(o);</span>let d,u,f,{move:g=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>reverse:p}=<span class="cstat-no" title="statement not covered" >s||{};<span class="cstat-no" title="statement not covered" ></span>for(d=0;d&lt;=h;++d)<span class="cstat-no" title="statement not covered" >u=n[(r+(p?h-d:d))%a],u.skip||(g?(t.moveTo(u.x,u.y),g=!1):c(t,f,u,p,o.stepped),f=u);<span class="cstat-no" title="statement not covered" >r</span></span>eturn l&amp;&amp;(u=n[(r+(p?h:0))%a],c(t,f,u,p,o.stepped)),!!l}</span>function <span class="fstat-no" title="function not covered" >Gn(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.points,</span>{count:o,start:a,ilen:r}=<span class="cstat-no" title="statement not covered" >qn(n,i,s),</span>{move:l=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>reverse:h}=<span class="cstat-no" title="statement not covered" >s||{};</span>let c,d,u,f,g,p,m=<span class="cstat-no" title="statement not covered" >0,</span>b=<span class="cstat-no" title="statement not covered" >0;</span>const x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(a+(h?r-t:t))%o,</span></span>_=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >f!==g&amp;&amp;(t.lineTo(m,g),t.lineTo(m,f),t.lineTo(m,p))}</span>;<span class="cstat-no" title="statement not covered" ></span>for(l&amp;&amp;(d=n[x(0)],t.moveTo(d.x,d.y)),c=0;c&lt;=r;++c){<span class="cstat-no" title="statement not covered" >if(d=n[x(c)],d.skip)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >d.x,</span>i=<span class="cstat-no" title="statement not covered" >d.y,</span>s=<span class="cstat-no" title="statement not covered" >0|e;<span class="cstat-no" title="statement not covered" ></span>s===u?(i&lt;f?f=i:i&gt;g&amp;&amp;(g=i),m=(b*m+e)/++b):(_(),t.lineTo(e,i),u=s,b=0,f=g=i),p=i}<span class="cstat-no" title="statement not covered" ></span>_</span>()}</span>function <span class="fstat-no" title="function not covered" >Zn(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.options,</span>i=<span class="cstat-no" title="statement not covered" >e.borderDash&amp;&amp;e.borderDash.length;<span class="cstat-no" title="statement not covered" ></span>return!(t._decimated||t._loop||e.tension||"monotone"===e.cubicInterpolationMode||e.stepped||i)?Gn:Kn}<span class="cstat-no" title="statement not covered" ></span>Yn.id="arc",Yn.defaults={borderAlign:"center",borderColor:"#fff",borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0},Yn.defaultRoutes={backgroundColor:"backgroundColor"};c</span>onst Jn=<span class="cstat-no" title="statement not covered" >"function"==typeof Path2D;</span>function <span class="fstat-no" title="function not covered" >Qn(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >Jn&amp;&amp;!e.options.segment?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >e._path;<span class="cstat-no" title="statement not covered" ></span>n||(n=e._path=new Path2D,e.path(n,i,s)&amp;&amp;n.closePath()),Un(t,e.options),t.stroke(n)}</span>(t,e,i,s):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{segments:n,options:o}=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >Zn(e);<span class="cstat-no" title="statement not covered" ></span>for(const r of n)<span class="cstat-no" title="statement not covered" >Un(t,o,r.style),t.beginPath(),a(t,e,r,{start:i,end:i+s-1})&amp;&amp;t.closePath(),t.stroke()}</span></span>(t,e,i,s)}</span>class to extends Es{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateControlPoints(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if((i.tension||"monotone"===i.cubicInterpolationMode)&amp;&amp;!i.stepped&amp;&amp;!this._pointsUpdated){const s=<span class="cstat-no" title="statement not covered" >i.spanGaps?this._loop:this._fullLoop;<span class="cstat-no" title="statement not covered" ></span>Qe(this._points,i,t,s,e),this._pointsUpdated=!0}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>t points(t){<span class="cstat-no" title="statement not covered" >this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}<span class="fstat-no" title="function not covered" ></span>ge</span>t points(){<span class="cstat-no" title="statement not covered" >return this._points}<span class="fstat-no" title="function not covered" ></span>ge</span>t segments(){<span class="cstat-no" title="statement not covered" >return this._segments||(this._segments=Di(this,this.options.segment))}<span class="fstat-no" title="function not covered" ></span>fi</span>rst(){const t=<span class="cstat-no" title="statement not covered" >this.segments,</span>e=<span class="cstat-no" title="statement not covered" >this.points;<span class="cstat-no" title="statement not covered" ></span>return t.length&amp;&amp;e[t[0].start]}<span class="fstat-no" title="function not covered" ></span>la</span>st(){const t=<span class="cstat-no" title="statement not covered" >this.segments,</span>e=<span class="cstat-no" title="statement not covered" >this.points,</span>i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;e[t[i-1].end]}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >t[e],</span>n=<span class="cstat-no" title="statement not covered" >this.points,</span>o=<span class="cstat-no" title="statement not covered" >Pi(this,{property:e,start:s,end:s});<span class="cstat-no" title="statement not covered" ></span>if(!o.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stepped?oi:t.tension||"monotone"===t.cubicInterpolationMode?ai:ni}</span>(i);</span>let l,h;<span class="cstat-no" title="statement not covered" >for(l=0,h=o.length;l&lt;h;++l){const{start:h,end:c}=<span class="cstat-no" title="statement not covered" >o[l],</span>d=<span class="cstat-no" title="statement not covered" >n[h],</span>u=<span class="cstat-no" title="statement not covered" >n[c];<span class="cstat-no" title="statement not covered" ></span>if(d===u){<span class="cstat-no" title="statement not covered" >a.push(d);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst f=<span class="cstat-no" title="statement not covered" >r(d,u,Math.abs((s-d[e])/(u[e]-d[e])),i.stepped);<span class="cstat-no" title="statement not covered" ></span>f[e]=t[e],a.push(f)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 1===a.length?a[0]:a}<span class="fstat-no" title="function not covered" ></span>pa</span>thSegment(t,e,i){<span class="cstat-no" title="statement not covered" >return Zn(this)(t,this,e,i)}<span class="fstat-no" title="function not covered" ></span>pa</span>th(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.segments,</span>n=<span class="cstat-no" title="statement not covered" >Zn(this);</span>let o=<span class="cstat-no" title="statement not covered" >this._loop;<span class="cstat-no" title="statement not covered" ></span>e=e||0,i=i||this.points.length-e;<span class="cstat-no" title="statement not covered" >f</span>or(const a of s)<span class="cstat-no" title="statement not covered" >o&amp;=n(t,this,a,{start:e,end:e+i-1});<span class="cstat-no" title="statement not covered" >r</span></span>eturn!!o}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options||{};<span class="cstat-no" title="statement not covered" ></span>(this.points||[]).length&amp;&amp;n.borderWidth&amp;&amp;(t.save(),Qn(t,this,i,s),t.restore()),this.animated&amp;&amp;(this._pointsUpdated=!1,this._path=void 0)}</span>}function <span class="fstat-no" title="function not covered" >eo(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.options,</span>{[i]:o}=<span class="cstat-no" title="statement not covered" >t.getProps([i],s);<span class="cstat-no" title="statement not covered" ></span>return Math.abs(e-o)&lt;n.radius+n.hitRadius}<span class="cstat-no" title="statement not covered" ></span>to.id="line",to.defaults={borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0},to.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"},to.descriptors={_scriptable:!0,_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t&amp;&amp;"fill"!==t}</span>;c</span>lass io extends Es{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.options,</span>{x:n,y:o}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],i);<span class="cstat-no" title="statement not covered" ></span>return Math.pow(t-n,2)+Math.pow(e-o,2)&lt;Math.pow(s.hitRadius+s.radius,2)}<span class="fstat-no" title="function not covered" ></span>in</span>XRange(t,e){<span class="cstat-no" title="statement not covered" >return eo(this,t,"x",e)}<span class="fstat-no" title="function not covered" ></span>in</span>YRange(t,e){<span class="cstat-no" title="statement not covered" >return eo(this,t,"y",e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:e,y:i}}<span class="fstat-no" title="function not covered" ></span>si</span>ze(t){let e=<span class="cstat-no" title="statement not covered" >(t=t||this.options||{}).radius||0;<span class="cstat-no" title="statement not covered" ></span>e=Math.max(e,e&amp;&amp;t.hoverRadius||0);<span class="cstat-no" title="statement not covered" >r</span>eturn 2*(e+(e&amp;&amp;t.borderWidth||0))}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>this.skip||i.radius&lt;.1||!Se(this,e,this.size(i)/2)||(t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.fillStyle=i.backgroundColor,Me(t,i,this.x,this.y))}<span class="fstat-no" title="function not covered" ></span>ge</span>tRange(){const t=<span class="cstat-no" title="statement not covered" >this.options||{};<span class="cstat-no" title="statement not covered" ></span>return t.radius+t.hitRadius}</span>}function <span class="fstat-no" title="function not covered" >so(</span>t,e){const{x:i,y:s,base:n,width:o,height:a}=<span class="cstat-no" title="statement not covered" >t.getProps(["x","y","base","width","height"],e);</span>let r,l,h,c,d;<span class="cstat-no" title="statement not covered" >return t.horizontal?(d=a/2,r=Math.min(i,n),l=Math.max(i,n),h=s-d,c=s+d):(d=o/2,r=i-d,l=i+d,h=Math.min(s,n),c=Math.max(s,n)),{left:r,top:h,right:l,bottom:c}}</span>function <span class="fstat-no" title="function not covered" >no(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return t?0:Z(e,i,s)}</span>function <span class="fstat-no" title="function not covered" >oo(</span>t){const e=<span class="cstat-no" title="statement not covered" >so(t),</span>i=<span class="cstat-no" title="statement not covered" >e.right-e.left,</span>s=<span class="cstat-no" title="statement not covered" >e.bottom-e.top,</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.options.borderWidth,</span>n=<span class="cstat-no" title="statement not covered" >t.borderSkipped,</span>o=<span class="cstat-no" title="statement not covered" >fi(s);<span class="cstat-no" title="statement not covered" ></span>return{t:no(n.top,o.top,0,i),r:no(n.right,o.right,0,e),b:no(n.bottom,o.bottom,0,i),l:no(n.left,o.left,0,e)}}</span>(t,i/2,s/2),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{enableBorderRadius:s}=<span class="cstat-no" title="statement not covered" >t.getProps(["enableBorderRadius"]),</span>o=<span class="cstat-no" title="statement not covered" >t.options.borderRadius,</span>a=<span class="cstat-no" title="statement not covered" >gi(o),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(e,i),</span>l=<span class="cstat-no" title="statement not covered" >t.borderSkipped,</span>h=<span class="cstat-no" title="statement not covered" >s||n(o);<span class="cstat-no" title="statement not covered" ></span>return{topLeft:no(!h||l.top||l.left,a.topLeft,0,r),topRight:no(!h||l.top||l.right,a.topRight,0,r),bottomLeft:no(!h||l.bottom||l.left,a.bottomLeft,0,r),bottomRight:no(!h||l.bottom||l.right,a.bottomRight,0,r)}}</span>(t,i/2,s/2);<span class="cstat-no" title="statement not covered" ></span>return{outer:{x:e.left,y:e.top,w:i,h:s,radius:a},inner:{x:e.left+o.l,y:e.top+o.t,w:i-o.l-o.r,h:s-o.t-o.b,radius:{topLeft:Math.max(0,a.topLeft-Math.max(o.t,o.l)),topRight:Math.max(0,a.topRight-Math.max(o.t,o.r)),bottomLeft:Math.max(0,a.bottomLeft-Math.max(o.b,o.l)),bottomRight:Math.max(0,a.bottomRight-Math.max(o.b,o.r))}}}}</span>function <span class="fstat-no" title="function not covered" >ao(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >null===e,</span>o=<span class="cstat-no" title="statement not covered" >null===i,</span>a=<span class="cstat-no" title="statement not covered" >t&amp;&amp;!(n&amp;&amp;o)&amp;&amp;so(t,s);<span class="cstat-no" title="statement not covered" ></span>return a&amp;&amp;(n||Q(e,a.left,a.right))&amp;&amp;(o||Q(i,a.top,a.bottom))}</span>function <span class="fstat-no" title="function not covered" >ro(</span>t,e){<span class="cstat-no" title="statement not covered" >t.rect(e.x,e.y,e.w,e.h)}</span>function <span class="fstat-no" title="function not covered" >lo(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >t.x!==i.x?-e:0,</span>n=<span class="cstat-no" title="statement not covered" >t.y!==i.y?-e:0,</span>o=<span class="cstat-no" title="statement not covered" >(t.x+t.w!==i.x+i.w?e:0)-s,</span>a=<span class="cstat-no" title="statement not covered" >(t.y+t.h!==i.y+i.h?e:0)-n;<span class="cstat-no" title="statement not covered" ></span>return{x:t.x+s,y:t.y+n,w:t.w+o,h:t.h+a,radius:t.radius}}<span class="cstat-no" title="statement not covered" ></span>io.id="point",io.defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0},io.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};c</span>lass ho extends Es{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:s}}=<span class="cstat-no" title="statement not covered" >this,</span>{inner:n,outer:o}=<span class="cstat-no" title="statement not covered" >oo(this),</span>a=<span class="cstat-no" title="statement not covered" >(r=o.radius).topLeft||r.topRight||r.bottomLeft||r.bottomRight?Le:ro;</span>var r;<span class="cstat-no" title="statement not covered" >t.save(),o.w===n.w&amp;&amp;o.h===n.h||(t.beginPath(),a(t,lo(o,e,n)),t.clip(),a(t,lo(n,-e,o)),t.fillStyle=i,t.fill("evenodd")),t.beginPath(),a(t,lo(n,e)),t.fillStyle=s,t.fill(),t.restore()}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){<span class="cstat-no" title="statement not covered" >return ao(this,t,e,i)}<span class="fstat-no" title="function not covered" ></span>in</span>XRange(t,e){<span class="cstat-no" title="statement not covered" >return ao(this,t,null,e)}<span class="fstat-no" title="function not covered" ></span>in</span>YRange(t,e){<span class="cstat-no" title="statement not covered" >return ao(this,null,t,e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i,base:s,horizontal:n}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y","base","horizontal"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:n?(e+s)/2:e,y:n?i:(i+s)/2}}<span class="fstat-no" title="function not covered" ></span>ge</span>tRange(t){<span class="cstat-no" title="statement not covered" >return"x"===t?this.width/2:this.height/2}</span>}<span class="cstat-no" title="statement not covered" >ho.id="bar",ho.defaults={borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0},ho.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};v</span>ar co=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,ArcElement:Yn,LineElement:to,PointElement:io,BarElement:ho});</span>function <span class="fstat-no" title="function not covered" >uo(</span>t){<span class="cstat-no" title="statement not covered" >if(t._decimated){const e=<span class="cstat-no" title="statement not covered" >t._data;<span class="cstat-no" title="statement not covered" ></span>delete t._decimated,delete t._data,Object.defineProperty(t,"data",{value:e})}</span>}</span>function <span class="fstat-no" title="function not covered" >fo(</span>t){<span class="cstat-no" title="statement not covered" >t.data.datasets.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >uo(t)}</span>))}</span>var go=<span class="cstat-no" title="statement not covered" >{id:"decimation",defaults:{algorithm:"min-max",enabled:!1},beforeElementsUpdate:<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >if(!s.enabled)<span class="cstat-no" title="statement not covered" >return void fo(t);c</span></span>onst n=<span class="cstat-no" title="statement not covered" >t.width;<span class="cstat-no" title="statement not covered" ></span>t.data.datasets.forEach((<span class="fstat-no" title="function not covered" >(e</span>,o)=&gt;{const{_data:a,indexAxis:r}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(o),</span>h=<span class="cstat-no" title="statement not covered" >a||e.data;<span class="cstat-no" title="statement not covered" ></span>if("y"===bi([r,t.options.indexAxis]))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!l.controller.supportsDecimation)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >t.scales[l.xAxisID];<span class="cstat-no" title="statement not covered" ></span>if("linear"!==c.type&amp;&amp;"time"!==c.type)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.options.parsing)<span class="cstat-no" title="statement not covered" >return;l</span></span>et{start:d,count:u}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >e.length;</span>let s,n=<span class="cstat-no" title="statement not covered" >0;</span>const{iScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>{min:a,max:r,minDefined:l,maxDefined:h}=<span class="cstat-no" title="statement not covered" >o.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>return l&amp;&amp;(n=Z(et(e,o.axis,a).lo,0,i-1)),s=h?Z(et(e,o.axis,r).hi+1,n,i)-n:i-n,{start:n,count:s}}</span>(l,h);<span class="cstat-no" title="statement not covered" ></span>if(u&lt;=(s.threshold||4*n))<span class="cstat-no" title="statement not covered" >return void uo(e);l</span></span>et f;<span class="cstat-no" title="statement not covered" >switch(i(a)&amp;&amp;(e._data=h,delete e.data,Object.defineProperty(e,"data",{configurable:!0,enumerable:!0,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this._decimated}</span>,set:<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >this._data=t}</span>})),s.algorithm){case"lttb":<span class="cstat-no" title="statement not covered" >f=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >n.samples||s;<span class="cstat-no" title="statement not covered" ></span>if(o&gt;=i)<span class="cstat-no" title="statement not covered" >return t.slice(e,e+i);c</span></span>onst a=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >(i-2)/(o-2);</span>let l=<span class="cstat-no" title="statement not covered" >0;</span>const h=<span class="cstat-no" title="statement not covered" >e+i-1;</span>let c,d,u,f,g,p=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(a[l++]=t[p],c=0;c&lt;o-2;c++){let s,n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>const h=<span class="cstat-no" title="statement not covered" >Math.floor((c+1)*r)+1+e,</span>m=<span class="cstat-no" title="statement not covered" >Math.min(Math.floor((c+2)*r)+1,i)+e,</span>b=<span class="cstat-no" title="statement not covered" >m-h;<span class="cstat-no" title="statement not covered" ></span>for(s=h;s&lt;m;s++)<span class="cstat-no" title="statement not covered" >n+=t[s].x,o+=t[s].y;<span class="cstat-no" title="statement not covered" >n</span></span>/=b,o/=b;c</span>onst x=<span class="cstat-no" title="statement not covered" >Math.floor(c*r)+1+e,</span>_=<span class="cstat-no" title="statement not covered" >Math.min(Math.floor((c+1)*r)+1,i)+e,</span>{x:y,y:v}=<span class="cstat-no" title="statement not covered" >t[p];<span class="cstat-no" title="statement not covered" ></span>for(u=f=-1,s=x;s&lt;_;s++)<span class="cstat-no" title="statement not covered" >f=.5*Math.abs((y-n)*(t[s].y-v)-(y-t[s].x)*(o-v)),f&gt;u&amp;&amp;(u=f,d=t[s],g=s);<span class="cstat-no" title="statement not covered" >a</span></span>[l++]=d,p=g}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a[l++]=t[h],a}</span>(h,d,u,n,s);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"min-max":<span class="cstat-no" title="statement not covered" >f=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,s,n){let o,a,r,l,h,c,d,u,f,g,p=<span class="cstat-no" title="statement not covered" >0,</span>m=<span class="cstat-no" title="statement not covered" >0;</span>const b=<span class="cstat-no" title="statement not covered" >[],</span>x=<span class="cstat-no" title="statement not covered" >e+s-1,</span>_=<span class="cstat-no" title="statement not covered" >t[e].x,</span>y=<span class="cstat-no" title="statement not covered" >t[x].x-_;<span class="cstat-no" title="statement not covered" ></span>for(o=e;o&lt;e+s;++o){<span class="cstat-no" title="statement not covered" >a=t[o],r=(a.x-_)/y*n,l=a.y;c</span>onst e=<span class="cstat-no" title="statement not covered" >0|r;<span class="cstat-no" title="statement not covered" ></span>if(e===h)<span class="cstat-no" title="statement not covered" >l&lt;f?(f=l,c=o):l&gt;g&amp;&amp;(g=l,d=o),p=(m*p+a.x)/++m;e</span>lse{const s=<span class="cstat-no" title="statement not covered" >o-1;<span class="cstat-no" title="statement not covered" ></span>if(!i(c)&amp;&amp;!i(d)){const e=<span class="cstat-no" title="statement not covered" >Math.min(c,d),</span>i=<span class="cstat-no" title="statement not covered" >Math.max(c,d);<span class="cstat-no" title="statement not covered" ></span>e!==u&amp;&amp;e!==s&amp;&amp;b.push({...t[e],x:p}),i!==u&amp;&amp;i!==s&amp;&amp;b.push({...t[i],x:p})}<span class="cstat-no" title="statement not covered" ></span>o</span>&gt;0&amp;&amp;s!==u&amp;&amp;b.push(t[s]),b.push(a),h=e,m=0,f=g=l,c=d=u=o}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn b}</span>(h,d,u,n);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Unsupported decimation algorithm '${s.algorithm}'`)}<span class="cstat-no" title="statement not covered" ></span>e</span>._decimated=f}</span>))}</span>,<span class="fstat-no" title="function not covered" >de</span>stroy(t){<span class="cstat-no" title="statement not covered" >fo(t)}</span>};</span>function <span class="fstat-no" title="function not covered" >po(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >if(s)<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >e[t],</span>o=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>return"angle"===t&amp;&amp;(n=K(n),o=K(o)),{property:t,start:n,end:o}}</span>function <span class="fstat-no" title="function not covered" >mo(</span>t,e,i){<span class="cstat-no" title="statement not covered" >for(;e&gt;t;e--){const t=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>if(!isNaN(t.x)&amp;&amp;!isNaN(t.y))<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >bo(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;e?s(t[i],e[i]):t?t[i]:e?e[i]:0}</span>function <span class="fstat-no" title="function not covered" >xo(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return s(t)?(n=!0,i=t):i=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{x:i=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>y:s=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>=<span class="cstat-no" title="statement not covered" >t||{},</span>n=<span class="cstat-no" title="statement not covered" >e.points,</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.segments.forEach((<span class="fstat-no" title="function not covered" >({</span>start:t,end:e})=&gt;{<span class="cstat-no" title="statement not covered" >e=mo(t,e,n);c</span>onst a=<span class="cstat-no" title="statement not covered" >n[t],</span>r=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>null!==s?(o.push({x:a.x,y:s}),o.push({x:r.x,y:s})):null!==i&amp;&amp;(o.push({x:i,y:a.y}),o.push({x:i,y:r.y}))}</span>)),o}</span>(t,e),i.length?new to({points:i,options:{tension:0},_loop:n,_fullLoop:n}):null}</span>function <span class="fstat-no" title="function not covered" >_o(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;!1!==t.fill}</span>function <span class="fstat-no" title="function not covered" >yo(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >t[e].fill;</span>const n=<span class="cstat-no" title="statement not covered" >[e];</span>let a;<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >f</span></span>or(;!1!==s&amp;&amp;-1===n.indexOf(s);){<span class="cstat-no" title="statement not covered" >if(!o(s))<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >i</span></span>f(a=t[s],!a)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(a.visible)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >n</span></span>.push(s),s=a.fill}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >vo(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.options,</span>i=<span class="cstat-no" title="statement not covered" >e.fill;</span>let s=<span class="cstat-no" title="statement not covered" >r(i&amp;&amp;i.target,i);<span class="cstat-no" title="statement not covered" ></span>void 0===s&amp;&amp;(s=!!e.backgroundColor);<span class="cstat-no" title="statement not covered" >i</span>f(!1===s||null===s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===s)<span class="cstat-no" title="statement not covered" >return"origin";<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>(t);<span class="cstat-no" title="statement not covered" ></span>if(n(s))<span class="cstat-no" title="statement not covered" >return!isNaN(s.value)&amp;&amp;s;l</span></span>et a=<span class="cstat-no" title="statement not covered" >parseFloat(s);<span class="cstat-no" title="statement not covered" ></span>return o(a)&amp;&amp;Math.floor(a)===a?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >"-"!==t&amp;&amp;"+"!==t||(i=e+i);<span class="cstat-no" title="statement not covered" >i</span>f(i===e||i&lt;0||i&gt;=s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>(s[0],e,a,i):["origin","start","end","stack","shape"].indexOf(s)&gt;=0&amp;&amp;s}</span>function <span class="fstat-no" title="function not covered" >wo(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;i.length;n++){const o=<span class="cstat-no" title="statement not covered" >i[n],</span>{first:a,last:r,point:l}=<span class="cstat-no" title="statement not covered" >Mo(o,e,"x");<span class="cstat-no" title="statement not covered" ></span>if(!(!l||a&amp;&amp;r))<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >s.unshift(l);e</span>lse <span class="cstat-no" title="statement not covered" >if(t.push(l),!r)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span></span></span>t</span>.push(...s)}</span>function <span class="fstat-no" title="function not covered" >Mo(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.interpolate(e,i);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return{};c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s[i],</span>o=<span class="cstat-no" title="statement not covered" >t.segments,</span>a=<span class="cstat-no" title="statement not covered" >t.points;</span>let r=<span class="cstat-no" title="statement not covered" >!1,</span>l=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;o.length;t++){const e=<span class="cstat-no" title="statement not covered" >o[t],</span>s=<span class="cstat-no" title="statement not covered" >a[e.start][i],</span>h=<span class="cstat-no" title="statement not covered" >a[e.end][i];<span class="cstat-no" title="statement not covered" ></span>if(Q(n,s,h)){<span class="cstat-no" title="statement not covered" >r=n===s,l=n===h;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{first:r,last:l,point:s}}</span>class ko{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.x=t.x,this.y=t.y,this.radius=t.radius}<span class="fstat-no" title="function not covered" ></span>pa</span>thSegment(t,e,i){const{x:s,y:n,radius:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return e=e||{start:0,end:O},t.arc(s,n,o,e.end,e.start,!0),!i.bounds}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t){const{x:e,y:i,radius:s}=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.angle;<span class="cstat-no" title="statement not covered" ></span>return{x:e+Math.cos(n)*s,y:i+Math.sin(n)*s,angle:n}}</span>}function <span class="fstat-no" title="function not covered" >So(</span>t){const{chart:e,fill:i,line:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(o(i))<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(e);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;t.isDatasetVisible(e)?i.dataset:null}</span>(e,i);<span class="cstat-no" title="statement not covered" >i</span></span>f("stack"===i)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e,index:i,line:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >s.segments,</span>a=<span class="cstat-no" title="statement not covered" >s.points,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.getMatchingVisibleMetas("line");<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;s.length;t++){const n=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>if(n.index===e)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >n</span></span>.hidden||i.unshift(n.dataset)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>(e,i);<span class="cstat-no" title="statement not covered" ></span>r.push(xo({x:null,y:e.bottom},s));<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;o.length;t++){const e=<span class="cstat-no" title="statement not covered" >o[t];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >e.start;</span>t&lt;=e.end;t++)<span class="cstat-no" title="statement not covered" >wo(n,a[t],r)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn new to({points:n,options:{}})}</span>(t);<span class="cstat-no" title="statement not covered" >i</span></span>f("shape"===i)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if((t.scale||{}).getPointPositionForValue)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e,fill:i}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" >e.options,</span>o=<span class="cstat-no" title="statement not covered" >e.getLabels().length,</span>a=<span class="cstat-no" title="statement not covered" >s.reverse?e.max:e.min,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s;<span class="cstat-no" title="statement not covered" >return s="start"===t?i:"end"===t?e.options.reverse?e.min:e.max:n(t)?t.value:e.getBaseValue(),s}</span>(i,e,a),</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(s.grid.circular){const t=<span class="cstat-no" title="statement not covered" >e.getPointPositionForValue(0,a);<span class="cstat-no" title="statement not covered" ></span>return new ko({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(r)})}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;o;++t)<span class="cstat-no" title="statement not covered" >l.push(e.getPointPositionForValue(t,r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}</span>(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>fill:i}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return"start"===t?i=e.bottom:"end"===t?i=e.top:n(t)?i=e.getPixelForValue(t.value):e.getBasePixel&amp;&amp;(i=e.getBasePixel()),i}</span>(i,e);<span class="cstat-no" title="statement not covered" ></span>if(o(s)){const t=<span class="cstat-no" title="statement not covered" >e.isHorizontal();<span class="cstat-no" title="statement not covered" ></span>return{x:t?s:null,y:t?null:s}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>(t)}</span>(t);<span class="cstat-no" title="statement not covered" ></span>return a instanceof ko?a:xo(a,s)}</span>function <span class="fstat-no" title="function not covered" >Po(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >So(e),</span>{line:n,scale:o,axis:a}=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >n.options,</span>l=<span class="cstat-no" title="statement not covered" >r.fill,</span>h=<span class="cstat-no" title="statement not covered" >r.backgroundColor,</span>{above:c=<span class="branch-0 cbranch-no" title="branch not covered" >h,</span>below:d=<span class="branch-0 cbranch-no" title="branch not covered" >h}</span>=<span class="cstat-no" title="statement not covered" >l||{};<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;n.points.length&amp;&amp;(Pe(t,i),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{line:i,target:s,above:n,below:o,area:a,scale:r}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >i._loop?"angle":e.axis;<span class="cstat-no" title="statement not covered" ></span>t.save(),"x"===l&amp;&amp;o!==n&amp;&amp;(Do(t,s,a.top),Oo(t,{line:i,target:s,color:n,scale:r,property:l}),t.restore(),t.save(),Do(t,s,a.bottom));<span class="cstat-no" title="statement not covered" >O</span>o(t,{line:i,target:s,color:o,scale:r,property:l}),t.restore()}</span>(t,{line:n,target:s,above:c,below:d,area:i,scale:o,axis:a}),De(t))}</span>function <span class="fstat-no" title="function not covered" >Do(</span>t,e,i){const{segments:s,points:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o=<span class="cstat-no" title="statement not covered" >!0,</span>a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const r of s){const{start:s,end:l}=<span class="cstat-no" title="statement not covered" >r,</span>h=<span class="cstat-no" title="statement not covered" >n[s],</span>c=<span class="cstat-no" title="statement not covered" >n[mo(s,l,n)];<span class="cstat-no" title="statement not covered" ></span>o?(t.moveTo(h.x,h.y),o=!1):(t.lineTo(h.x,i),t.lineTo(h.x,h.y)),a=!!e.pathSegment(t,r,{move:a}),a?t.closePath():t.lineTo(c.x,i)}<span class="cstat-no" title="statement not covered" ></span>t</span>.lineTo(e.first().x,i),t.closePath(),t.clip()}</span>function <span class="fstat-no" title="function not covered" >Oo(</span>t,e){const{line:i,target:s,property:n,color:o,scale:a}=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.segments,</span>n=<span class="cstat-no" title="statement not covered" >t.points,</span>o=<span class="cstat-no" title="statement not covered" >e.points,</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const t of s){let{start:s,end:r}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>r=mo(s,r,n);c</span>onst l=<span class="cstat-no" title="statement not covered" >po(i,n[s],n[r],t.loop);<span class="cstat-no" title="statement not covered" ></span>if(!e.segments){<span class="cstat-no" title="statement not covered" >a.push({source:t,target:l,start:n[s],end:n[r]});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst h=<span class="cstat-no" title="statement not covered" >Pi(e,l);<span class="cstat-no" title="statement not covered" ></span>for(const e of h){const s=<span class="cstat-no" title="statement not covered" >po(i,o[e.start],o[e.end],e.loop),</span>r=<span class="cstat-no" title="statement not covered" >Si(t,n,s);<span class="cstat-no" title="statement not covered" ></span>for(const t of r)<span class="cstat-no" title="statement not covered" >a.push({source:t,target:e,start:{[i]:bo(l,s,"start",Math.max)},end:{[i]:bo(l,s,"end",Math.min)}})}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>(i,s,n);<span class="cstat-no" title="statement not covered" ></span>for(const{source:e,target:l,start:h,end:c}of r){const{style:{backgroundColor:r=<span class="branch-0 cbranch-no" title="branch not covered" >o}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>=<span class="cstat-no" title="statement not covered" >e,</span>d=<span class="cstat-no" title="statement not covered" >!0!==s;<span class="cstat-no" title="statement not covered" ></span>t.save(),t.fillStyle=r,Co(t,a,d&amp;&amp;po(n,h,c)),t.beginPath();c</span>onst u=<span class="cstat-no" title="statement not covered" >!!i.pathSegment(t,e);</span>let f;<span class="cstat-no" title="statement not covered" >if(d){<span class="cstat-no" title="statement not covered" >u?t.closePath():Ao(t,s,c,n);c</span>onst e=<span class="cstat-no" title="statement not covered" >!!s.pathSegment(t,l,{move:u,reverse:!0});<span class="cstat-no" title="statement not covered" ></span>f=u&amp;&amp;e,f||Ao(t,s,h,n)}<span class="cstat-no" title="statement not covered" ></span>t</span>.closePath(),t.fill(f?"evenodd":"nonzero"),t.restore()}</span>}</span>function <span class="fstat-no" title="function not covered" >Co(</span>t,e,i){const{top:s,bottom:n}=<span class="cstat-no" title="statement not covered" >e.chart.chartArea,</span>{property:o,start:a,end:r}=<span class="cstat-no" title="statement not covered" >i||{};<span class="cstat-no" title="statement not covered" ></span>"x"===o&amp;&amp;(t.beginPath(),t.rect(a,s,r-a,n-s),t.clip())}</span>function <span class="fstat-no" title="function not covered" >Ao(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.interpolate(i,s);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;t.lineTo(n.x,n.y)}</span>var To=<span class="cstat-no" title="statement not covered" >{id:"filler",<span class="fstat-no" title="function not covered" >af</span>terDatasetsUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >(t.data.datasets||[]).length,</span>n=<span class="cstat-no" title="statement not covered" >[];</span>let o,a,r,l;<span class="cstat-no" title="statement not covered" >for(a=0;a&lt;s;++a)<span class="cstat-no" title="statement not covered" >o=t.getDatasetMeta(a),r=o.dataset,l=null,r&amp;&amp;r.options&amp;&amp;r instanceof to&amp;&amp;(l={visible:t.isDatasetVisible(a),index:a,fill:vo(r,a,s),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:r}),o.$filler=l,n.push(l);<span class="cstat-no" title="statement not covered" >f</span></span>or(a=0;a&lt;s;++a)<span class="cstat-no" title="statement not covered" >l=n[a],l&amp;&amp;!1!==l.fill&amp;&amp;(l.fill=yo(n,a,i.propagate))}</span></span>,<span class="fstat-no" title="function not covered" >be</span>foreDraw(t,e,i){const s=<span class="cstat-no" title="statement not covered" >"beforeDraw"===i.drawTime,</span>n=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas(),</span>o=<span class="cstat-no" title="statement not covered" >t.chartArea;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >n.length-1;</span>e&gt;=0;--e){const i=<span class="cstat-no" title="statement not covered" >n[e].$filler;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(i.line.updateControlPoints(o,i.axis),s&amp;&amp;i.fill&amp;&amp;Po(t.ctx,i,o))}</span>}</span>,<span class="fstat-no" title="function not covered" >be</span>foreDatasetsDraw(t,e,i){<span class="cstat-no" title="statement not covered" >if("beforeDatasetsDraw"!==i.drawTime)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas();<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >s.length-1;</span>e&gt;=0;--e){const i=<span class="cstat-no" title="statement not covered" >s[e].$filler;<span class="cstat-no" title="statement not covered" ></span>_o(i)&amp;&amp;Po(t.ctx,i,t.chartArea)}</span>}</span>,<span class="fstat-no" title="function not covered" >be</span>foreDatasetDraw(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.meta.$filler;<span class="cstat-no" title="statement not covered" ></span>_o(s)&amp;&amp;"beforeDatasetDraw"===i.drawTime&amp;&amp;Po(t.ctx,s,t.chartArea)}</span>,defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};</span>const Lo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{let{boxHeight:i=<span class="branch-0 cbranch-no" title="branch not covered" >e,</span>boxWidth:s=<span class="branch-0 cbranch-no" title="branch not covered" >e}</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return t.usePointStyle&amp;&amp;(i=Math.min(i,e),s=t.pointStyleWidth||Math.min(s,e)),{boxWidth:s,boxHeight:i,itemHeight:Math.max(e,i)}}</span>;</span>class Eo extends Es{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){<span class="cstat-no" title="statement not covered" >this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildLabels(){const t=<span class="cstat-no" title="statement not covered" >this.options.labels||{};</span>let e=<span class="cstat-no" title="statement not covered" >c(t.generateLabels,[this.chart],this)||[];<span class="cstat-no" title="statement not covered" ></span>t.filter&amp;&amp;(e=e.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.filter(e,this.chart.data))</span>)),t.sort&amp;&amp;(e=e.sort((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t.sort(e,i,this.chart.data))</span>)),this.options.reverse&amp;&amp;e.reverse(),this.legendItems=e}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const{options:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!t.display)<span class="cstat-no" title="statement not covered" >return void(this.width=this.height=0);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >t.labels,</span>s=<span class="cstat-no" title="statement not covered" >mi(i.font),</span>n=<span class="cstat-no" title="statement not covered" >s.size,</span>o=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight(),</span>{boxWidth:a,itemHeight:r}=<span class="cstat-no" title="statement not covered" >Lo(i,n);</span>let l,h;<span class="cstat-no" title="statement not covered" >e.font=s.string,this.isHorizontal()?(l=this.maxWidth,h=this._fitRows(o,n,a,r)+10):(h=this.maxHeight,l=this._fitCols(o,n,a,r)+10),this.width=Math.min(l,t.maxWidth||this.maxWidth),this.height=Math.min(h,t.maxHeight||this.maxHeight)}<span class="fstat-no" title="function not covered" ></span>_f</span>itRows(t,e,i,s){const{ctx:n,maxWidth:o,options:{labels:{padding:a}}}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >this.legendHitBoxes=[],</span>l=<span class="cstat-no" title="statement not covered" >this.lineWidths=[0],</span>h=<span class="cstat-no" title="statement not covered" >s+a;</span>let c=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>n.textAlign="left",n.textBaseline="middle";l</span>et d=<span class="cstat-no" title="statement not covered" >-1,</span>u=<span class="cstat-no" title="statement not covered" >-h;<span class="cstat-no" title="statement not covered" ></span>return this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(t</span>,f)=&gt;{const g=<span class="cstat-no" title="statement not covered" >i+e/2+n.measureText(t.text).width;<span class="cstat-no" title="statement not covered" ></span>(0===f||l[l.length-1]+g+2*a&gt;o)&amp;&amp;(c+=h,l[l.length-(f&gt;0?0:1)]=0,u+=h,d++),r[f]={left:0,top:u,row:d,width:g,height:s},l[l.length-1]+=g+a}</span>)),c}<span class="fstat-no" title="function not covered" ></span>_f</span>itCols(t,e,i,s){const{ctx:n,maxHeight:o,options:{labels:{padding:a}}}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >this.legendHitBoxes=[],</span>l=<span class="cstat-no" title="statement not covered" >this.columnSizes=[],</span>h=<span class="cstat-no" title="statement not covered" >o-t;</span>let c=<span class="cstat-no" title="statement not covered" >a,</span>d=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0,</span>f=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(t</span>,o)=&gt;{const p=<span class="cstat-no" title="statement not covered" >i+e/2+n.measureText(t.text).width;<span class="cstat-no" title="statement not covered" ></span>o&gt;0&amp;&amp;u+s+2*a&gt;h&amp;&amp;(c+=d+a,l.push({width:d,height:u}),f+=d+a,g++,d=u=0),r[o]={left:f,top:u,col:g,width:p,height:s},d=Math.max(d,p),u+=s+a}</span>)),c+=d,l.push({width:d,height:u}),c}<span class="fstat-no" title="function not covered" ></span>ad</span>justHitBoxes(){<span class="cstat-no" title="statement not covered" >if(!this.options.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight(),</span>{legendHitBoxes:e,options:{align:i,labels:{padding:s},rtl:n}}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >yi(n,this.left,this.width);<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal()){let n=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >ut(i,this.left+s,this.right-this.lineWidths[n]);<span class="cstat-no" title="statement not covered" ></span>for(const r of e)<span class="cstat-no" title="statement not covered" >n!==r.row&amp;&amp;(n=r.row,a=ut(i,this.left+s,this.right-this.lineWidths[n])),r.top+=this.top+t+s,r.left=o.leftForLtr(o.x(a),r.width),a+=r.width+s}</span></span>else{let n=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >ut(i,this.top+t+s,this.bottom-this.columnSizes[n].height);<span class="cstat-no" title="statement not covered" ></span>for(const r of e)<span class="cstat-no" title="statement not covered" >r.col!==n&amp;&amp;(n=r.col,a=ut(i,this.top+t+s,this.bottom-this.columnSizes[n].height)),r.top=a,r.left+=this.left+s,r.left=o.leftForLtr(o.x(r.left),r.width),a+=r.height+s}</span></span>}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){<span class="cstat-no" title="statement not covered" >return"top"===this.options.position||"bottom"===this.options.position}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){<span class="cstat-no" title="statement not covered" >if(this.options.display){const t=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>Pe(t,this),this._draw(),De(t)}</span>}<span class="fstat-no" title="function not covered" ></span>_d</span>raw(){const{options:t,columnSizes:e,lineWidths:i,ctx:s}=<span class="cstat-no" title="statement not covered" >this,</span>{align:n,labels:o}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >ne.color,</span>l=<span class="cstat-no" title="statement not covered" >yi(t.rtl,this.left,this.width),</span>h=<span class="cstat-no" title="statement not covered" >mi(o.font),</span>{color:c,padding:d}=<span class="cstat-no" title="statement not covered" >o,</span>u=<span class="cstat-no" title="statement not covered" >h.size,</span>f=<span class="cstat-no" title="statement not covered" >u/2;</span>let g;<span class="cstat-no" title="statement not covered" >this.drawTitle(),s.textAlign=l.textAlign("left"),s.textBaseline="middle",s.lineWidth=.5,s.font=h.string;c</span>onst{boxWidth:p,boxHeight:m,itemHeight:b}=<span class="cstat-no" title="statement not covered" >Lo(o,u),</span>x=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>_=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight();<span class="cstat-no" title="statement not covered" ></span>g=x?{x:ut(n,this.left+d,this.right-i[0]),y:this.top+d+_,line:0}:{x:this.left+d,y:ut(n,this.top+_+d,this.bottom-e[0].height),line:0},vi(this.ctx,t.textDirection);c</span>onst y=<span class="cstat-no" title="statement not covered" >b+d;<span class="cstat-no" title="statement not covered" ></span>this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(v</span>,w)=&gt;{<span class="cstat-no" title="statement not covered" >s.strokeStyle=v.fontColor||c,s.fillStyle=v.fontColor||c;c</span>onst M=<span class="cstat-no" title="statement not covered" >s.measureText(v.text).width,</span>k=<span class="cstat-no" title="statement not covered" >l.textAlign(v.textAlign||(v.textAlign=o.textAlign)),</span>S=<span class="cstat-no" title="statement not covered" >p+f+M;</span>let P=<span class="cstat-no" title="statement not covered" >g.x,</span>D=<span class="cstat-no" title="statement not covered" >g.y;<span class="cstat-no" title="statement not covered" ></span>l.setWidth(this.width),x?w&gt;0&amp;&amp;P+S+d&gt;this.right&amp;&amp;(D=g.y+=y,g.line++,P=g.x=ut(n,this.left+d,this.right-i[g.line])):w&gt;0&amp;&amp;D+y&gt;this.bottom&amp;&amp;(P=g.x=P+e[g.line].width+d,g.line++,D=g.y=ut(n,this.top+_+d,this.bottom-e[g.line].height));<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" ></span>fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if(isNaN(p)||p&lt;=0||isNaN(m)||m&lt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span></span>.save();c</span>onst n=<span class="cstat-no" title="statement not covered" >r(i.lineWidth,1);<span class="cstat-no" title="statement not covered" ></span>if(s.fillStyle=r(i.fillStyle,a),s.lineCap=r(i.lineCap,"butt"),s.lineDashOffset=r(i.lineDashOffset,0),s.lineJoin=r(i.lineJoin,"miter"),s.lineWidth=n,s.strokeStyle=r(i.strokeStyle,a),s.setLineDash(r(i.lineDash,[])),o.usePointStyle){const a=<span class="cstat-no" title="statement not covered" >{radius:m*Math.SQRT2/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:n},</span>r=<span class="cstat-no" title="statement not covered" >l.xPlus(t,p/2);<span class="cstat-no" title="statement not covered" ></span>ke(s,a,r,e+f,o.pointStyleWidth&amp;&amp;p)}</span>else{const o=<span class="cstat-no" title="statement not covered" >e+Math.max((u-m)/2,0),</span>a=<span class="cstat-no" title="statement not covered" >l.leftForLtr(t,p),</span>r=<span class="cstat-no" title="statement not covered" >gi(i.borderRadius);<span class="cstat-no" title="statement not covered" ></span>s.beginPath(),Object.values(r).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?Le(s,{x:a,y:o,w:p,h:m,radius:r}):s.rect(a,o,p,m),s.fill(),0!==n&amp;&amp;s.stroke()}<span class="cstat-no" title="statement not covered" ></span>s</span>.restore()}</span>(l.x(P),D,v),P=ft(k,P+p+f,x?P+S:this.right,t.rtl),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >Ae(s,i.text,t,e+b/2,h,{strikethrough:i.hidden,textAlign:l.textAlign(i.textAlign)})}</span>(l.x(P),D,v),x?g.x+=S+d:g.y+=y}</span>)),wi(this.ctx,t.textDirection)}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.title,</span>i=<span class="cstat-no" title="statement not covered" >mi(e.font),</span>s=<span class="cstat-no" title="statement not covered" >pi(e.padding);<span class="cstat-no" title="statement not covered" ></span>if(!e.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >yi(t.rtl,this.left,this.width),</span>o=<span class="cstat-no" title="statement not covered" >this.ctx,</span>a=<span class="cstat-no" title="statement not covered" >e.position,</span>r=<span class="cstat-no" title="statement not covered" >i.size/2,</span>l=<span class="cstat-no" title="statement not covered" >s.top+r;</span>let h,c=<span class="cstat-no" title="statement not covered" >this.left,</span>d=<span class="cstat-no" title="statement not covered" >this.width;<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal())<span class="cstat-no" title="statement not covered" >d=Math.max(...this.lineWidths),h=this.top+l,c=ut(t.align,c,this.right-d);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >this.columnSizes.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(t,e.height))</span>,0);<span class="cstat-no" title="statement not covered" ></span>h=l+ut(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}</span>c</span>onst u=<span class="cstat-no" title="statement not covered" >ut(a,c,c+d);<span class="cstat-no" title="statement not covered" ></span>o.textAlign=n.textAlign(dt(a)),o.textBaseline="middle",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=i.string,Ae(o,e.text,u,h,i)}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeTitleHeight(){const t=<span class="cstat-no" title="statement not covered" >this.options.title,</span>e=<span class="cstat-no" title="statement not covered" >mi(t.font),</span>i=<span class="cstat-no" title="statement not covered" >pi(t.padding);<span class="cstat-no" title="statement not covered" ></span>return t.display?e.lineHeight+i.height:0}<span class="fstat-no" title="function not covered" ></span>_g</span>etLegendItemAt(t,e){let i,s,n;<span class="cstat-no" title="statement not covered" >if(Q(t,this.left,this.right)&amp;&amp;Q(e,this.top,this.bottom))<span class="cstat-no" title="statement not covered" >for(n=this.legendHitBoxes,i=0;i&lt;n.length;++i)<span class="cstat-no" title="statement not covered" >if(s=n[i],Q(t,s.left,s.left+s.width)&amp;&amp;Q(e,s.top,s.top+s.height))<span class="cstat-no" title="statement not covered" >return this.legendItems[i];<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn null}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleEvent(t){const e=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(("mousemove"===t||"mouseout"===t)&amp;&amp;(e.onHover||e.onLeave))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.onClick&amp;&amp;("click"===t||"mouseup"===t))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!1}</span>(t.type,e))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._getLegendItemAt(t.x,t.y);<span class="cstat-no" title="statement not covered" ></span>if("mousemove"===t.type||"mouseout"===t.type){const o=<span class="cstat-no" title="statement not covered" >this._hoveredItem,</span>a=(<span class="cstat-no" title="statement not covered" >n=i,null!==(s=o)&amp;&amp;null!==n&amp;&amp;s.datasetIndex===n.datasetIndex&amp;&amp;s.index===n.index)</span>;<span class="cstat-no" title="statement not covered" >o&amp;&amp;!a&amp;&amp;c(e.onLeave,[t,o,this],this),this._hoveredItem=i,i&amp;&amp;!a&amp;&amp;c(e.onHover,[t,i,this],this)}</span>else <span class="cstat-no" title="statement not covered" >i&amp;&amp;c(e.onClick,[t,i,this],this);v</span></span>ar s,n}}var Ro=<span class="cstat-no" title="statement not covered" >{id:"legend",_element:Eo,<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.legend=new Eo({ctx:t.ctx,options:i,chart:t});<span class="cstat-no" title="statement not covered" ></span>Zi.configure(t,s,i),Zi.addBox(t,s)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){<span class="cstat-no" title="statement not covered" >Zi.removeBox(t,t.legend),delete t.legend}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.legend;<span class="cstat-no" title="statement not covered" ></span>Zi.configure(t,s,i),s.options=i}</span>,<span class="fstat-no" title="function not covered" >af</span>terUpdate(t){const e=<span class="cstat-no" title="statement not covered" >t.legend;<span class="cstat-no" title="statement not covered" ></span>e.buildLabels(),e.adjustHitBoxes()}</span>,<span class="fstat-no" title="function not covered" >af</span>terEvent(t,e){<span class="cstat-no" title="statement not covered" >e.replay||t.legend.handleEvent(e.event)}</span>,defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.datasetIndex,</span>n=<span class="cstat-no" title="statement not covered" >i.chart;<span class="cstat-no" title="statement not covered" ></span>n.isDatasetVisible(s)?(n.hide(s),e.hidden=!0):(n.show(s),e.hidden=!1)}</span>,onHover:null,onLeave:null,labels:{color:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.options.color,</span>boxWidth:40,padding:10,<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data.datasets,</span>{labels:{usePointStyle:i,pointStyle:s,textAlign:n,color:o}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return t._getSortedDatasetMetas().map((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const a=<span class="cstat-no" title="statement not covered" >t.controller.getStyle(i?0:void 0),</span>r=<span class="cstat-no" title="statement not covered" >pi(a.borderWidth);<span class="cstat-no" title="statement not covered" ></span>return{text:e[t.index].label,fillStyle:a.backgroundColor,fontColor:o,hidden:!t.visible,lineCap:a.borderCapStyle,lineDash:a.borderDash,lineDashOffset:a.borderDashOffset,lineJoin:a.borderJoinStyle,lineWidth:(r.width+r.height)/4,strokeStyle:a.borderColor,pointStyle:s||a.pointStyle,rotation:a.rotation,textAlign:n||a.textAlign,borderRadius:0,datasetIndex:t.index}}</span>),this)}</span>},title:{color:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.options.color,</span>display:!1,position:"center",text:""}},descriptors:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("on"),</span>labels:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!["generateLabels","filter","sort"].includes(t)}</span>}};</span>class Io extends Es{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(this.left=0,this.top=0,!i.display)<span class="cstat-no" title="statement not covered" >return void(this.width=this.height=this.right=this.bottom=0);<span class="cstat-no" title="statement not covered" >t</span></span>his.width=this.right=t,this.height=this.bottom=e;c</span>onst n=<span class="cstat-no" title="statement not covered" >s(i.text)?i.text.length:1;<span class="cstat-no" title="statement not covered" ></span>this._padding=pi(i.padding);c</span>onst o=<span class="cstat-no" title="statement not covered" >n*mi(i.font).lineHeight+this._padding.height;<span class="cstat-no" title="statement not covered" ></span>this.isHorizontal()?this.height=o:this.width=o}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){const t=<span class="cstat-no" title="statement not covered" >this.options.position;<span class="cstat-no" title="statement not covered" ></span>return"top"===t||"bottom"===t}<span class="fstat-no" title="function not covered" ></span>_d</span>rawArgs(t){const{top:e,left:i,bottom:s,right:n,options:o}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >o.align;</span>let r,l,h,c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.isHorizontal()?(l=ut(a,i,n),h=e+t,r=n-i):("left"===o.position?(l=i+t,h=ut(a,s,e),c=-.5*D):(l=n-t,h=ut(a,e,s),c=.5*D),r=s-e),{titleX:l,titleY:h,maxWidth:r,rotation:c}}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this.ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!e.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >mi(e.font),</span>s=<span class="cstat-no" title="statement not covered" >i.lineHeight/2+this._padding.top,</span>{titleX:n,titleY:o,maxWidth:a,rotation:r}=<span class="cstat-no" title="statement not covered" >this._drawArgs(s);<span class="cstat-no" title="statement not covered" ></span>Ae(t,e.text,0,0,i,{color:e.color,maxWidth:a,rotation:r,textAlign:dt(e.align),textBaseline:"middle",translation:[n,o]})}</span>}var zo=<span class="cstat-no" title="statement not covered" >{id:"title",_element:Io,<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >new Io({ctx:t.ctx,options:e,chart:t});<span class="cstat-no" title="statement not covered" ></span>Zi.configure(t,i,e),Zi.addBox(t,i),t.titleBlock=i}</span>(t,i)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){const e=<span class="cstat-no" title="statement not covered" >t.titleBlock;<span class="cstat-no" title="statement not covered" ></span>Zi.removeBox(t,e),delete t.titleBlock}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.titleBlock;<span class="cstat-no" title="statement not covered" ></span>Zi.configure(t,s,i),s.options=i}</span>,defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};</span>const Fo=<span class="cstat-no" title="statement not covered" >new WeakMap;</span>var Vo=<span class="cstat-no" title="statement not covered" >{id:"subtitle",<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){const s=<span class="cstat-no" title="statement not covered" >new Io({ctx:t.ctx,options:i,chart:t});<span class="cstat-no" title="statement not covered" ></span>Zi.configure(t,s,i),Zi.addBox(t,s),Fo.set(t,s)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){<span class="cstat-no" title="statement not covered" >Zi.removeBox(t,Fo.get(t)),Fo.delete(t)}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >Fo.get(t);<span class="cstat-no" title="statement not covered" ></span>Zi.configure(t,s,i),s.options=i}</span>,defaults:{align:"center",display:!1,font:{weight:"normal"},fullSize:!0,padding:0,position:"top",text:"",weight:1500},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};</span>const Bo=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >av</span>erage(t){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et e,i,s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(e=0,i=t.length;e&lt;i;++e){const i=<span class="cstat-no" title="statement not covered" >t[e].element;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;i.hasValue()){const t=<span class="cstat-no" title="statement not covered" >i.tooltipPosition();<span class="cstat-no" title="statement not covered" ></span>s+=t.x,n+=t.y,++o}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:s/o,y:n/o}}</span>,<span class="fstat-no" title="function not covered" >ne</span>arest(t,e){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et i,s,n,o=<span class="cstat-no" title="statement not covered" >e.x,</span>a=<span class="cstat-no" title="statement not covered" >e.y,</span>r=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>for(i=0,s=t.length;i&lt;s;++i){const s=<span class="cstat-no" title="statement not covered" >t[i].element;<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;s.hasValue()){const t=<span class="cstat-no" title="statement not covered" >X(e,s.getCenterPoint());<span class="cstat-no" title="statement not covered" ></span>t&lt;r&amp;&amp;(r=t,n=s)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n){const t=<span class="cstat-no" title="statement not covered" >n.tooltipPosition();<span class="cstat-no" title="statement not covered" ></span>o=t.x,a=t.y}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:o,y:a}}</span>};</span>function <span class="fstat-no" title="function not covered" >No(</span>t,e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;(s(e)?Array.prototype.push.apply(t,e):t.push(e)),t}</span>function <span class="fstat-no" title="function not covered" >Wo(</span>t){<span class="cstat-no" title="statement not covered" >return("string"==typeof t||t instanceof String)&amp;&amp;t.indexOf("\n")&gt;-1?t.split("\n"):t}</span>function <span class="fstat-no" title="function not covered" >jo(</span>t,e){const{element:i,datasetIndex:s,index:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(s).controller,</span>{label:a,value:r}=<span class="cstat-no" title="statement not covered" >o.getLabelAndValue(n);<span class="cstat-no" title="statement not covered" ></span>return{chart:t,label:a,parsed:o.getParsed(n),raw:t.data.datasets[s].data[n],formattedValue:r,dataset:o.getDataset(),dataIndex:n,datasetIndex:s,element:i}}</span>function <span class="fstat-no" title="function not covered" >Ho(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.chart.ctx,</span>{body:s,footer:n,title:o}=<span class="cstat-no" title="statement not covered" >t,</span>{boxWidth:a,boxHeight:r}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >mi(e.bodyFont),</span>h=<span class="cstat-no" title="statement not covered" >mi(e.titleFont),</span>c=<span class="cstat-no" title="statement not covered" >mi(e.footerFont),</span>u=<span class="cstat-no" title="statement not covered" >o.length,</span>f=<span class="cstat-no" title="statement not covered" >n.length,</span>g=<span class="cstat-no" title="statement not covered" >s.length,</span>p=<span class="cstat-no" title="statement not covered" >pi(e.padding);</span>let m=<span class="cstat-no" title="statement not covered" >p.height,</span>b=<span class="cstat-no" title="statement not covered" >0,</span>x=<span class="cstat-no" title="statement not covered" >s.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e.before.length+e.lines.length+e.after.length)</span>,0);<span class="cstat-no" title="statement not covered" ></span>if(x+=t.beforeBody.length+t.afterBody.length,u&amp;&amp;(m+=u*h.lineHeight+(u-1)*e.titleSpacing+e.titleMarginBottom),x){<span class="cstat-no" title="statement not covered" >m+=g*(e.displayColors?Math.max(r,l.lineHeight):l.lineHeight)+(x-g)*l.lineHeight+(x-1)*e.bodySpacing}<span class="cstat-no" title="statement not covered" ></span>f</span>&amp;&amp;(m+=e.footerMarginTop+f*c.lineHeight+(f-1)*e.footerSpacing);l</span>et _=<span class="cstat-no" title="statement not covered" >0;</span>const y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >b=Math.max(b,i.measureText(t).width+_)}</span>;<span class="cstat-no" title="statement not covered" ></span>return i.save(),i.font=h.string,d(t.title,y),i.font=l.string,d(t.beforeBody.concat(t.afterBody),y),_=e.displayColors?a+2+e.boxPadding:0,d(s,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >d(t.before,y),d(t.lines,y),d(t.after,y)}</span>)),_=0,i.font=c.string,d(t.footer,y),i.restore(),b+=p.width,{width:b,height:m}}</span>function <span class="fstat-no" title="function not covered" >$o(</span>t,e,i,s){const{x:n,width:o}=<span class="cstat-no" title="statement not covered" >i,</span>{width:a,chartArea:{left:r,right:l}}=<span class="cstat-no" title="statement not covered" >t;</span>let h=<span class="cstat-no" title="statement not covered" >"center";<span class="cstat-no" title="statement not covered" ></span>return"center"===s?h=n&lt;=(r+l)/2?"left":"right":n&lt;=o/2?h="left":n&gt;=a-o/2&amp;&amp;(h="right"),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{x:n,width:o}=<span class="cstat-no" title="statement not covered" >s,</span>a=<span class="cstat-no" title="statement not covered" >i.caretSize+i.caretPadding;<span class="cstat-no" title="statement not covered" ></span>return"left"===t&amp;&amp;n+o+a&gt;e.width||"right"===t&amp;&amp;n-o-a&lt;0||void 0}</span>(h,t,e,i)&amp;&amp;(h="center"),h}</span>function <span class="fstat-no" title="function not covered" >Yo(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >i.yAlign||e.yAlign||<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{y:i,height:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return i&lt;s/2?"top":i&gt;t.height-s/2?"bottom":"center"}</span>(t,i);<span class="cstat-no" title="statement not covered" ></span>return{xAlign:i.xAlign||e.xAlign||$o(t,e,i,s),yAlign:s}}</span>function <span class="fstat-no" title="function not covered" >Uo(</span>t,e,i,s){const{caretSize:n,caretPadding:o,cornerRadius:a}=<span class="cstat-no" title="statement not covered" >t,</span>{xAlign:r,yAlign:l}=<span class="cstat-no" title="statement not covered" >i,</span>h=<span class="cstat-no" title="statement not covered" >n+o,</span>{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=<span class="cstat-no" title="statement not covered" >gi(a);</span>let g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let{x:i,width:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"right"===e?i-=s:"center"===e&amp;&amp;(i-=s/2),i}</span>(e,r);</span>const p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let{y:s,height:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"top"===e?s+=i:s-="bottom"===e?n+i:n/2,s}</span>(e,l,h);<span class="cstat-no" title="statement not covered" ></span>return"center"===l?"left"===r?g+=h:"right"===r&amp;&amp;(g-=h):"left"===r?g-=Math.max(c,u)+n:"right"===r&amp;&amp;(g+=Math.max(d,f)+n),{x:Z(g,0,s.width-e.width),y:Z(p,0,s.height-e.height)}}</span>function <span class="fstat-no" title="function not covered" >Xo(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >pi(i.padding);<span class="cstat-no" title="statement not covered" ></span>return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-s.right:t.x+s.left}</span>function <span class="fstat-no" title="function not covered" >qo(</span>t){<span class="cstat-no" title="statement not covered" >return No([],Wo(t))}</span>function <span class="fstat-no" title="function not covered" >Ko(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.dataset&amp;&amp;e.dataset.tooltip&amp;&amp;e.dataset.tooltip.callbacks;<span class="cstat-no" title="statement not covered" ></span>return i?t.override(i):t}</span>class Go extends Es{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart||t._chart,this._chart=this.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(t){<span class="cstat-no" title="statement not covered" >this.options=t,this._cachedAnimations=void 0,this.$context=void 0}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveAnimations(){const t=<span class="cstat-no" title="statement not covered" >this._cachedAnimations;<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >i.enabled&amp;&amp;e.options.animation&amp;&amp;i.animations,</span>n=<span class="cstat-no" title="statement not covered" >new ys(this.chart,s);<span class="cstat-no" title="statement not covered" ></span>return s._cacheable&amp;&amp;(this._cachedAnimations=Object.freeze(n)),n}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(){<span class="cstat-no" title="statement not covered" >return this.$context||(this.$context=(t=this.chart.getContext(),e=this,i=this._tooltipItems,_i(t,{tooltip:e,tooltipItems:i,type:"tooltip"})));v</span>ar t,e,i}<span class="fstat-no" title="function not covered" >ge</span>tTitle(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >i.beforeTitle.apply(this,[t]),</span>n=<span class="cstat-no" title="statement not covered" >i.title.apply(this,[t]),</span>o=<span class="cstat-no" title="statement not covered" >i.afterTitle.apply(this,[t]);</span>let a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return a=No(a,Wo(s)),a=No(a,Wo(n)),a=No(a,Wo(o)),a}<span class="fstat-no" title="function not covered" ></span>ge</span>tBeforeBody(t,e){<span class="cstat-no" title="statement not covered" >return qo(e.callbacks.beforeBody.apply(this,[t]))}<span class="fstat-no" title="function not covered" ></span>ge</span>tBody(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return d(t,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >{before:[],lines:[],after:[]},</span>n=<span class="cstat-no" title="statement not covered" >Ko(i,t);<span class="cstat-no" title="statement not covered" ></span>No(e.before,Wo(n.beforeLabel.call(this,t))),No(e.lines,n.label.call(this,t)),No(e.after,Wo(n.afterLabel.call(this,t))),s.push(e)}</span>)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tAfterBody(t,e){<span class="cstat-no" title="statement not covered" >return qo(e.callbacks.afterBody.apply(this,[t]))}<span class="fstat-no" title="function not covered" ></span>ge</span>tFooter(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >i.beforeFooter.apply(this,[t]),</span>n=<span class="cstat-no" title="statement not covered" >i.footer.apply(this,[t]),</span>o=<span class="cstat-no" title="statement not covered" >i.afterFooter.apply(this,[t]);</span>let a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return a=No(a,Wo(s)),a=No(a,Wo(n)),a=No(a,Wo(o)),a}<span class="fstat-no" title="function not covered" ></span>_c</span>reateItems(t){const e=<span class="cstat-no" title="statement not covered" >this._active,</span>i=<span class="cstat-no" title="statement not covered" >this.chart.data,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[];</span>let a,r,l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(a=0,r=e.length;a&lt;r;++a)<span class="cstat-no" title="statement not covered" >l.push(jo(this.chart,e[a]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.filter&amp;&amp;(l=l.filter((<span class="fstat-no" title="function not covered" >(e</span>,s,n)=&gt;<span class="cstat-no" title="statement not covered" >t.filter(e,s,n,i))</span>)),t.itemSort&amp;&amp;(l=l.sort((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t.itemSort(e,s,i))</span>)),d(l,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >Ko(t.callbacks,e);<span class="cstat-no" title="statement not covered" ></span>s.push(i.labelColor.call(this,e)),n.push(i.labelPointStyle.call(this,e)),o.push(i.labelTextColor.call(this,e))}</span>)),this.labelColors=s,this.labelPointStyles=n,this.labelTextColors=o,this.dataPoints=l,l}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >this._active;</span>let n,o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(s.length){const t=<span class="cstat-no" title="statement not covered" >Bo[i.position].call(this,s,this._eventPosition);<span class="cstat-no" title="statement not covered" ></span>o=this._createItems(i),this.title=this.getTitle(o,i),this.beforeBody=this.getBeforeBody(o,i),this.body=this.getBody(o,i),this.afterBody=this.getAfterBody(o,i),this.footer=this.getFooter(o,i);c</span>onst e=<span class="cstat-no" title="statement not covered" >this._size=Ho(this,i),</span>a=<span class="cstat-no" title="statement not covered" >Object.assign({},t,e),</span>r=<span class="cstat-no" title="statement not covered" >Yo(this.chart,i,a),</span>l=<span class="cstat-no" title="statement not covered" >Uo(i,a,r,this.chart);<span class="cstat-no" title="statement not covered" ></span>this.xAlign=r.xAlign,this.yAlign=r.yAlign,n={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}</span>else <span class="cstat-no" title="statement not covered" >0!==this.opacity&amp;&amp;(n={opacity:0});<span class="cstat-no" title="statement not covered" >t</span></span>his._tooltipItems=o,this.$context=void 0,n&amp;&amp;this._resolveAnimations().update(this,n),t&amp;&amp;i.external&amp;&amp;i.external.call(this,{chart:this.chart,tooltip:this,replay:e})}<span class="fstat-no" title="function not covered" ></span>dr</span>awCaret(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.getCaretPosition(t,i,s);<span class="cstat-no" title="statement not covered" ></span>e.lineTo(n.x1,n.y1),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCaretPosition(t,e,i){const{xAlign:s,yAlign:n}=<span class="cstat-no" title="statement not covered" >this,</span>{caretSize:o,cornerRadius:a}=<span class="cstat-no" title="statement not covered" >i,</span>{topLeft:r,topRight:l,bottomLeft:h,bottomRight:c}=<span class="cstat-no" title="statement not covered" >gi(a),</span>{x:d,y:u}=<span class="cstat-no" title="statement not covered" >t,</span>{width:f,height:g}=<span class="cstat-no" title="statement not covered" >e;</span>let p,m,b,x,_,y;<span class="cstat-no" title="statement not covered" >return"center"===n?(_=u+g/2,"left"===s?(p=d,m=p-o,x=_+o,y=_-o):(p=d+f,m=p+o,x=_-o,y=_+o),b=p):(m="left"===s?d+Math.max(r,h)+o:"right"===s?d+f-Math.max(l,c)-o:this.caretX,"top"===n?(x=u,_=x-o,p=m-o,b=m+o):(x=u+g,_=x+o,p=m+o,b=m-o),y=x),{x1:p,x2:m,x3:b,y1:x,y2:_,y3:y}}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.title,</span>n=<span class="cstat-no" title="statement not covered" >s.length;</span>let o,a,r;<span class="cstat-no" title="statement not covered" >if(n){const l=<span class="cstat-no" title="statement not covered" >yi(i.rtl,this.x,this.width);<span class="cstat-no" title="statement not covered" ></span>for(t.x=Xo(this,i.titleAlign,i),e.textAlign=l.textAlign(i.titleAlign),e.textBaseline="middle",o=mi(i.titleFont),a=i.titleSpacing,e.fillStyle=i.titleColor,e.font=o.string,r=0;r&lt;n;++r)<span class="cstat-no" title="statement not covered" >e.fillText(s[r],l.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+a,r+1===n&amp;&amp;(t.y+=i.titleMarginBottom-a)}</span></span>}<span class="fstat-no" title="function not covered" ></span>_d</span>rawColorBox(t,e,i,s,o){const a=<span class="cstat-no" title="statement not covered" >this.labelColors[i],</span>r=<span class="cstat-no" title="statement not covered" >this.labelPointStyles[i],</span>{boxHeight:l,boxWidth:h,boxPadding:c}=<span class="cstat-no" title="statement not covered" >o,</span>d=<span class="cstat-no" title="statement not covered" >mi(o.bodyFont),</span>u=<span class="cstat-no" title="statement not covered" >Xo(this,"left",o),</span>f=<span class="cstat-no" title="statement not covered" >s.x(u),</span>g=<span class="cstat-no" title="statement not covered" >l&lt;d.lineHeight?(d.lineHeight-l)/2:0,</span>p=<span class="cstat-no" title="statement not covered" >e.y+g;<span class="cstat-no" title="statement not covered" ></span>if(o.usePointStyle){const e=<span class="cstat-no" title="statement not covered" >{radius:Math.min(h,l)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1},</span>i=<span class="cstat-no" title="statement not covered" >s.leftForLtr(f,h)+h/2,</span>n=<span class="cstat-no" title="statement not covered" >p+l/2;<span class="cstat-no" title="statement not covered" ></span>t.strokeStyle=o.multiKeyBackground,t.fillStyle=o.multiKeyBackground,Me(t,e,i,n),t.strokeStyle=a.borderColor,t.fillStyle=a.backgroundColor,Me(t,e,i,n)}</span>else{<span class="cstat-no" title="statement not covered" >t.lineWidth=n(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,t.strokeStyle=a.borderColor,t.setLineDash(a.borderDash||[]),t.lineDashOffset=a.borderDashOffset||0;c</span>onst e=<span class="cstat-no" title="statement not covered" >s.leftForLtr(f,h-c),</span>i=<span class="cstat-no" title="statement not covered" >s.leftForLtr(s.xPlus(f,1),h-c-2),</span>r=<span class="cstat-no" title="statement not covered" >gi(a.borderRadius);<span class="cstat-no" title="statement not covered" ></span>Object.values(r).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?(t.beginPath(),t.fillStyle=o.multiKeyBackground,Le(t,{x:e,y:p,w:h,h:l,radius:r}),t.fill(),t.stroke(),t.fillStyle=a.backgroundColor,t.beginPath(),Le(t,{x:i,y:p+1,w:h-2,h:l-2,radius:r}),t.fill()):(t.fillStyle=o.multiKeyBackground,t.fillRect(e,p,h,l),t.strokeRect(e,p,h,l),t.fillStyle=a.backgroundColor,t.fillRect(i,p+1,h-2,l-2))}<span class="cstat-no" title="statement not covered" ></span>t</span>.fillStyle=this.labelTextColors[i]}<span class="fstat-no" title="function not covered" ></span>dr</span>awBody(t,e,i){const{body:s}=<span class="cstat-no" title="statement not covered" >this,</span>{bodySpacing:n,bodyAlign:o,displayColors:a,boxHeight:r,boxWidth:l,boxPadding:h}=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >mi(i.bodyFont);</span>let u=<span class="cstat-no" title="statement not covered" >c.lineHeight,</span>f=<span class="cstat-no" title="statement not covered" >0;</span>const g=<span class="cstat-no" title="statement not covered" >yi(i.rtl,this.x,this.width),</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >e.fillText(i,g.x(t.x+f),t.y+u/2),t.y+=u+n}</span>,</span>m=<span class="cstat-no" title="statement not covered" >g.textAlign(o);</span>let b,x,_,y,v,w,M;<span class="cstat-no" title="statement not covered" >for(e.textAlign=o,e.textBaseline="middle",e.font=c.string,t.x=Xo(this,m,i),e.fillStyle=i.bodyColor,d(this.beforeBody,p),f=a&amp;&amp;"right"!==m?"center"===o?l/2+h:l+2+h:0,y=0,w=s.length;y&lt;w;++y){<span class="cstat-no" title="statement not covered" >for(b=s[y],x=this.labelTextColors[y],e.fillStyle=x,d(b.before,p),_=b.lines,a&amp;&amp;_.length&amp;&amp;(this._drawColorBox(e,t,y,g,i),u=Math.max(c.lineHeight,r)),v=0,M=_.length;v&lt;M;++v)<span class="cstat-no" title="statement not covered" >p(_[v]),u=c.lineHeight;<span class="cstat-no" title="statement not covered" >d</span></span>(b.after,p)}<span class="cstat-no" title="statement not covered" ></span>f</span>=0,u=c.lineHeight,d(this.afterBody,p),t.y-=n}<span class="fstat-no" title="function not covered" ></span>dr</span>awFooter(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.footer,</span>n=<span class="cstat-no" title="statement not covered" >s.length;</span>let o,a;<span class="cstat-no" title="statement not covered" >if(n){const r=<span class="cstat-no" title="statement not covered" >yi(i.rtl,this.x,this.width);<span class="cstat-no" title="statement not covered" ></span>for(t.x=Xo(this,i.footerAlign,i),t.y+=i.footerMarginTop,e.textAlign=r.textAlign(i.footerAlign),e.textBaseline="middle",o=mi(i.footerFont),e.fillStyle=i.footerColor,e.font=o.string,a=0;a&lt;n;++a)<span class="cstat-no" title="statement not covered" >e.fillText(s[a],r.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+i.footerSpacing}</span></span>}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(t,e,i,s){const{xAlign:n,yAlign:o}=<span class="cstat-no" title="statement not covered" >this,</span>{x:a,y:r}=<span class="cstat-no" title="statement not covered" >t,</span>{width:l,height:h}=<span class="cstat-no" title="statement not covered" >i,</span>{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=<span class="cstat-no" title="statement not covered" >gi(s.cornerRadius);<span class="cstat-no" title="statement not covered" ></span>e.fillStyle=s.backgroundColor,e.strokeStyle=s.borderColor,e.lineWidth=s.borderWidth,e.beginPath(),e.moveTo(a+c,r),"top"===o&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(a+l-d,r),e.quadraticCurveTo(a+l,r,a+l,r+d),"center"===o&amp;&amp;"right"===n&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(a+l,r+h-f),e.quadraticCurveTo(a+l,r+h,a+l-f,r+h),"bottom"===o&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(a+u,r+h),e.quadraticCurveTo(a,r+h,a,r+h-u),"center"===o&amp;&amp;"left"===n&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(a,r+c),e.quadraticCurveTo(a,r,a+c,r),e.closePath(),e.fill(),s.borderWidth&gt;0&amp;&amp;e.stroke()}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateAnimationTarget(t){const e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this.$animations,</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.x,</span>n=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.y;<span class="cstat-no" title="statement not covered" ></span>if(s||n){const i=<span class="cstat-no" title="statement not covered" >Bo[t.position].call(this,this._active,this._eventPosition);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this._size=Ho(this,t),</span>a=<span class="cstat-no" title="statement not covered" >Object.assign({},i,this._size),</span>r=<span class="cstat-no" title="statement not covered" >Yo(e,t,a),</span>l=<span class="cstat-no" title="statement not covered" >Uo(t,a,r,e);<span class="cstat-no" title="statement not covered" ></span>s._to===l.x&amp;&amp;n._to===l.y||(this.xAlign=r.xAlign,this.yAlign=r.yAlign,this.width=o.width,this.height=o.height,this.caretX=i.x,this.caretY=i.y,this._resolveAnimations().update(this,l))}</span>}<span class="fstat-no" title="function not covered" ></span>_w</span>illRender(){<span class="cstat-no" title="statement not covered" >return!!this.opacity}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const e=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext());</span>let i=<span class="cstat-no" title="statement not covered" >this.opacity;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._updateAnimationTarget(e);c</span>onst s=<span class="cstat-no" title="statement not covered" >{width:this.width,height:this.height},</span>n=<span class="cstat-no" title="statement not covered" >{x:this.x,y:this.y};<span class="cstat-no" title="statement not covered" ></span>i=Math.abs(i)&lt;.001?0:i;c</span>onst o=<span class="cstat-no" title="statement not covered" >pi(e.padding),</span>a=<span class="cstat-no" title="statement not covered" >this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;<span class="cstat-no" title="statement not covered" ></span>e.enabled&amp;&amp;a&amp;&amp;(t.save(),t.globalAlpha=i,this.drawBackground(n,t,s,e),vi(t,e.textDirection),n.y+=o.top,this.drawTitle(n,t,e),this.drawBody(n,t,e),this.drawFooter(n,t,e),wi(t,e.textDirection),t.restore())}<span class="fstat-no" title="function not covered" ></span>ge</span>tActiveElements(){<span class="cstat-no" title="statement not covered" >return this._active||[]}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveElements(t,e){const i=<span class="cstat-no" title="statement not covered" >this._active,</span>s=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >({</span>datasetIndex:t,index:e})=&gt;{const i=<span class="cstat-no" title="statement not covered" >this.chart.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot find a dataset at index "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{datasetIndex:t,element:i.data[e],index:e}}</span>)),</span>n=<span class="cstat-no" title="statement not covered" >!u(i,s),</span>o=<span class="cstat-no" title="statement not covered" >this._positionChanged(s,e);<span class="cstat-no" title="statement not covered" ></span>(n||o)&amp;&amp;(this._active=s,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleEvent(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;this._ignoreReplayEvents)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>his._ignoreReplayEvents=!1;c</span>onst s=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >this._active||[],</span>o=<span class="cstat-no" title="statement not covered" >this._getActiveElements(t,n,e,i),</span>a=<span class="cstat-no" title="statement not covered" >this._positionChanged(o,t),</span>r=<span class="cstat-no" title="statement not covered" >e||!u(o,n)||a;<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(this._active=o,(s.enabled||s.external)&amp;&amp;(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),r}<span class="fstat-no" title="function not covered" ></span>_g</span>etActiveElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if("mouseout"===t.type)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(!s)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this.chart.getElementsAtEventForMode(t,n.mode,n,i);<span class="cstat-no" title="statement not covered" ></span>return n.reverse&amp;&amp;o.reverse(),o}<span class="fstat-no" title="function not covered" ></span>_p</span>ositionChanged(t,e){const{caretX:i,caretY:s,options:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >Bo[n.position].call(this,t,e);<span class="cstat-no" title="statement not covered" ></span>return!1!==o&amp;&amp;(i!==o.x||s!==o.y)}</span>}<span class="cstat-no" title="statement not covered" >Go.positioners=Bo;v</span>ar Zo=<span class="cstat-no" title="statement not covered" >{id:"tooltip",_element:Go,positioners:Bo,<span class="fstat-no" title="function not covered" >af</span>terInit(t,e,i){<span class="cstat-no" title="statement not covered" >i&amp;&amp;(t.tooltip=new Go({chart:t,options:i}))}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){<span class="cstat-no" title="statement not covered" >t.tooltip&amp;&amp;t.tooltip.initialize(i)}</span>,<span class="fstat-no" title="function not covered" >re</span>set(t,e,i){<span class="cstat-no" title="statement not covered" >t.tooltip&amp;&amp;t.tooltip.initialize(i)}</span>,<span class="fstat-no" title="function not covered" >af</span>terDraw(t){const e=<span class="cstat-no" title="statement not covered" >t.tooltip;<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;e._willRender()){const i=<span class="cstat-no" title="statement not covered" >{tooltip:e};<span class="cstat-no" title="statement not covered" ></span>if(!1===t.notifyPlugins("beforeTooltipDraw",i))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>.draw(t.ctx),t.notifyPlugins("afterTooltipDraw",i)}</span>}</span>,<span class="fstat-no" title="function not covered" >af</span>terEvent(t,e){<span class="cstat-no" title="statement not covered" >if(t.tooltip){const i=<span class="cstat-no" title="statement not covered" >e.replay;<span class="cstat-no" title="statement not covered" ></span>t.tooltip.handleEvent(e.event,i,e.inChartArea)&amp;&amp;(e.changed=!0)}</span>}</span>,defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.bodyFont.size,</span>boxWidth:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.bodyFont.size,</span>multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:{beforeTitle:t,<span class="fstat-no" title="function not covered" >ti</span>tle(t){<span class="cstat-no" title="statement not covered" >if(t.length&gt;0){const e=<span class="cstat-no" title="statement not covered" >t[0],</span>i=<span class="cstat-no" title="statement not covered" >e.chart.data.labels,</span>s=<span class="cstat-no" title="statement not covered" >i?i.length:0;<span class="cstat-no" title="statement not covered" ></span>if(this&amp;&amp;this.options&amp;&amp;"dataset"===this.options.mode)<span class="cstat-no" title="statement not covered" >return e.dataset.label||"";<span class="cstat-no" title="statement not covered" >i</span></span>f(e.label)<span class="cstat-no" title="statement not covered" >return e.label;<span class="cstat-no" title="statement not covered" >i</span></span>f(s&gt;0&amp;&amp;e.dataIndex&lt;s)<span class="cstat-no" title="statement not covered" >return i[e.dataIndex]}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn""}</span>,afterTitle:t,beforeBody:t,beforeLabel:t,<span class="fstat-no" title="function not covered" >la</span>bel(t){<span class="cstat-no" title="statement not covered" >if(this&amp;&amp;this.options&amp;&amp;"dataset"===this.options.mode)<span class="cstat-no" title="statement not covered" >return t.label+": "+t.formattedValue||t.formattedValue;l</span></span>et e=<span class="cstat-no" title="statement not covered" >t.dataset.label||"";<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e+=": ");c</span>onst s=<span class="cstat-no" title="statement not covered" >t.formattedValue;<span class="cstat-no" title="statement not covered" ></span>return i(s)||(e+=s),e}</span>,<span class="fstat-no" title="function not covered" >la</span>belColor(t){const e=<span class="cstat-no" title="statement not covered" >t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);<span class="cstat-no" title="statement not covered" ></span>return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}}</span>,<span class="fstat-no" title="function not covered" >la</span>belTextColor(){<span class="cstat-no" title="statement not covered" >return this.options.bodyColor}</span>,<span class="fstat-no" title="function not covered" >la</span>belPointStyle(t){const e=<span class="cstat-no" title="statement not covered" >t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);<span class="cstat-no" title="statement not covered" ></span>return{pointStyle:e.pointStyle,rotation:e.rotation}}</span>,afterLabel:t,afterBody:t,beforeFooter:t,footer:t,afterFooter:t}},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"filter"!==t&amp;&amp;"itemSort"!==t&amp;&amp;"external"!==t,</span>_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]},</span>Jo=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,Decimation:go,Filler:To,Legend:Ro,SubTitle:Vo,Title:zo,Tooltip:Zo});</span>function <span class="fstat-no" title="function not covered" >Qo(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>if(-1===n)<span class="cstat-no" title="statement not covered" >return(<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;(<span class="cstat-no" title="statement not covered" >"string"==typeof e?(i=t.push(e)-1,s.unshift({index:i,label:e})):isNaN(e)&amp;&amp;(i=null),i)</span>)(t,e,i,s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n!==t.lastIndexOf(e)?i:n}</span>class ta extends $s{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}<span class="fstat-no" title="function not covered" ></span>in</span>it(t){const e=<span class="cstat-no" title="statement not covered" >this._addedLabels;<span class="cstat-no" title="statement not covered" ></span>if(e.length){const t=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>for(const{index:i,label:s}of e)<span class="cstat-no" title="statement not covered" >t[i]===s&amp;&amp;t.splice(i,1);<span class="cstat-no" title="statement not covered" >t</span></span>his._addedLabels=[]}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.init(t)}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >if(i(t))<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>return(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >null===t?null:Z(Math.round(t),0,e))</span>(e=isFinite(e)&amp;&amp;s[e]===t?e:Qo(s,t,r(e,t),this._addedLabels),s.length-1)}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{minDefined:t,maxDefined:e}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let{min:i,max:s}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>"ticks"===this.options.bounds&amp;&amp;(t||(i=0),e||(s=this.getLabels().length-1)),this.min=i,this.max=s}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.min,</span>e=<span class="cstat-no" title="statement not covered" >this.max,</span>i=<span class="cstat-no" title="statement not covered" >this.options.offset,</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>n=0===t&amp;&amp;e===n.length-1?n:n.slice(t,e+1),this._valueRange=Math.max(n.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >t;</span>i&lt;=e;i++)<span class="cstat-no" title="statement not covered" >s.push({value:i});<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){const e=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>return t&gt;=0&amp;&amp;t&lt;e.length?e[t]:t}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){<span class="cstat-no" title="statement not covered" >super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return"number"!=typeof t&amp;&amp;(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForTick(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0||t&gt;e.length-1?null:this.getPixelForValue(e[t].value)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){<span class="cstat-no" title="statement not covered" >return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePixel(){<span class="cstat-no" title="statement not covered" >return this.bottom}</span>}function <span class="fstat-no" title="function not covered" >ea(</span>t,e,{horizontal:i,minRotation:s}){const n=<span class="cstat-no" title="statement not covered" >H(s),</span>o=<span class="cstat-no" title="statement not covered" >(i?Math.sin(n):Math.cos(n))||.001,</span>a=<span class="cstat-no" title="statement not covered" >.75*e*(""+t).length;<span class="cstat-no" title="statement not covered" ></span>return Math.min(e/o,a)}<span class="cstat-no" title="statement not covered" ></span>ta.id="category",ta.defaults={ticks:{callback:ta.prototype.getLabelForValue}};c</span>lass ia extends $s{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return i(t)||("number"==typeof t||t instanceof Number)&amp;&amp;!isFinite(+t)?null:+t}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleTickRangeOptions(){const{beginAtZero:t}=<span class="cstat-no" title="statement not covered" >this.options,</span>{minDefined:e,maxDefined:i}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let{min:s,max:n}=<span class="cstat-no" title="statement not covered" >this;</span>const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >s=e?s:t,</span></span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >n=i?n:t;<span class="cstat-no" title="statement not covered" ></span></span>if(t){const t=<span class="cstat-no" title="statement not covered" >z(s),</span>e=<span class="cstat-no" title="statement not covered" >z(n);<span class="cstat-no" title="statement not covered" ></span>t&lt;0&amp;&amp;e&lt;0?a(0):t&gt;0&amp;&amp;e&gt;0&amp;&amp;o(0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s===n){let e=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>(n&gt;=Number.MAX_SAFE_INTEGER||s&lt;=Number.MIN_SAFE_INTEGER)&amp;&amp;(e=Math.abs(.05*n)),a(n+e),t||o(s-e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.min=s,this.max=n}<span class="fstat-no" title="function not covered" ></span>ge</span>tTickLimit(){const t=<span class="cstat-no" title="statement not covered" >this.options.ticks;</span>let e,{maxTicksLimit:i,stepSize:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return s?(e=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,e&gt;1e3&amp;&amp;(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),i=i||11),i&amp;&amp;(e=Math.min(i,e)),e}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){<span class="cstat-no" title="statement not covered" >return Number.POSITIVE_INFINITY}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks;</span>let s=<span class="cstat-no" title="statement not covered" >this.getTickLimit();<span class="cstat-no" title="statement not covered" ></span>s=Math.max(2,s);c</span>onst n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const s=<span class="cstat-no" title="statement not covered" >[],</span>{bounds:n,step:o,min:a,max:r,precision:l,count:h,maxTicks:c,maxDigits:d,includeBounds:u}=<span class="cstat-no" title="statement not covered" >t,</span>f=<span class="cstat-no" title="statement not covered" >o||1,</span>g=<span class="cstat-no" title="statement not covered" >c-1,</span>{min:p,max:m}=<span class="cstat-no" title="statement not covered" >e,</span>b=<span class="cstat-no" title="statement not covered" >!i(a),</span>x=<span class="cstat-no" title="statement not covered" >!i(r),</span>_=<span class="cstat-no" title="statement not covered" >!i(h),</span>y=<span class="cstat-no" title="statement not covered" >(m-p)/(d+1);</span>let v,w,M,k,S=<span class="cstat-no" title="statement not covered" >F((m-p)/g/f)*f;<span class="cstat-no" title="statement not covered" ></span>if(S&lt;1e-14&amp;&amp;!b&amp;&amp;!x)<span class="cstat-no" title="statement not covered" >return[{value:p},{value:m}];<span class="cstat-no" title="statement not covered" >k</span></span>=Math.ceil(m/S)-Math.floor(p/S),k&gt;g&amp;&amp;(S=F(k*S/g/f)*f),i(l)||(v=Math.pow(10,l),S=Math.ceil(S*v)/v),"ticks"===n?(w=Math.floor(p/S)*S,M=Math.ceil(m/S)*S):(w=p,M=m),b&amp;&amp;x&amp;&amp;o&amp;&amp;W((r-a)/o,S/1e3)?(k=Math.round(Math.min((r-a)/S,c)),S=(r-a)/k,w=a,M=r):_?(w=b?a:w,M=x?r:M,k=h-1,S=(M-w)/k):(k=(M-w)/S,k=N(k,Math.round(k),S/1e3)?Math.round(k):Math.ceil(k));c</span>onst P=<span class="cstat-no" title="statement not covered" >Math.max(Y(S),Y(w));<span class="cstat-no" title="statement not covered" ></span>v=Math.pow(10,i(l)?P:l),w=Math.round(w*v)/v,M=Math.round(M*v)/v;l</span>et D=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(b&amp;&amp;(u&amp;&amp;w!==a?(s.push({value:a}),w&lt;a&amp;&amp;D++,N(Math.round((w+D*S)*v)/v,a,ea(a,y,t))&amp;&amp;D++):w&lt;a&amp;&amp;D++);D&lt;k;++D)<span class="cstat-no" title="statement not covered" >s.push({value:Math.round((w+D*S)*v)/v});<span class="cstat-no" title="statement not covered" >r</span></span>eturn x&amp;&amp;u&amp;&amp;M!==r?s.length&amp;&amp;N(s[s.length-1].value,r,ea(r,y,t))?s[s.length-1].value=r:s.push({value:r}):x&amp;&amp;M!==r||s.push({value:M}),s}</span>({maxTicks:s,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);<span class="cstat-no" title="statement not covered" ></span>return"ticks"===t.bounds&amp;&amp;j(n,this,"value"),t.reverse?(n.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),n}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.ticks;</span>let e=<span class="cstat-no" title="statement not covered" >this.min,</span>i=<span class="cstat-no" title="statement not covered" >this.max;<span class="cstat-no" title="statement not covered" ></span>if(super.configure(),this.options.offset&amp;&amp;t.length){const s=<span class="cstat-no" title="statement not covered" >(i-e)/Math.max(t.length-1,1)/2;<span class="cstat-no" title="statement not covered" ></span>e-=s,i+=s}<span class="cstat-no" title="statement not covered" ></span>t</span>his._startValue=e,this._endValue=i,this._valueRange=i-e}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return li(t,this.chart.options.locale,this.options.ticks.format)}</span>}class sa extends ia{<span class="fstat-no" title="function not covered" >de</span>termineDataLimits(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>this.min=o(t)?t:0,this.max=o(e)?e:1,this.handleTickRangeOptions()}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){const t=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>e=<span class="cstat-no" title="statement not covered" >t?this.width:this.height,</span>i=<span class="cstat-no" title="statement not covered" >H(this.options.ticks.minRotation),</span>s=<span class="cstat-no" title="statement not covered" >(t?Math.sin(i):Math.cos(i))||.001,</span>n=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0);<span class="cstat-no" title="statement not covered" ></span>return Math.ceil(e/Math.min(40,n.lineHeight/s))}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){<span class="cstat-no" title="statement not covered" >return this._startValue+this.getDecimalForPixel(t)*this._valueRange}</span>}function <span class="fstat-no" title="function not covered" >na(</span>t){<span class="cstat-no" title="statement not covered" >return 1===t/Math.pow(10,Math.floor(I(t)))}<span class="cstat-no" title="statement not covered" ></span>sa.id="linear",sa.defaults={ticks:{callback:Is.formatters.numeric}};c</span>lass oa extends $s{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){const i=<span class="cstat-no" title="statement not covered" >ia.prototype.parse.apply(this,[t,e]);<span class="cstat-no" title="statement not covered" ></span>if(0!==i)<span class="cstat-no" title="statement not covered" >return o(i)&amp;&amp;i&gt;0?i:null;<span class="cstat-no" title="statement not covered" >t</span></span>his._zero=!0}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>this.min=o(t)?Math.max(0,t):null,this.max=o(e)?Math.max(0,e):null,this.options.beginAtZero&amp;&amp;(this._zero=!0),this.handleTickRangeOptions()}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleTickRangeOptions(){const{minDefined:t,maxDefined:e}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let i=<span class="cstat-no" title="statement not covered" >this.min,</span>s=<span class="cstat-no" title="statement not covered" >this.max;</span>const n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i=t?i:e,</span></span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >s=e?s:t,</span></span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.pow(10,Math.floor(I(t))+e);<span class="cstat-no" title="statement not covered" ></span></span>i===s&amp;&amp;(i&lt;=0?(n(1),o(10)):(n(a(i,-1)),o(a(s,1)))),i&lt;=0&amp;&amp;n(a(s,-1)),s&lt;=0&amp;&amp;o(a(i,1)),this._zero&amp;&amp;this.min!==this._suggestedMin&amp;&amp;i===a(this.min,0)&amp;&amp;n(a(i,-1)),this.min=i,this.max=s}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >Math.floor(I(e.max)),</span>s=<span class="cstat-no" title="statement not covered" >Math.ceil(e.max/Math.pow(10,i)),</span>n=<span class="cstat-no" title="statement not covered" >[];</span>let o=<span class="cstat-no" title="statement not covered" >a(t.min,Math.pow(10,Math.floor(I(e.min)))),</span>r=<span class="cstat-no" title="statement not covered" >Math.floor(I(o)),</span>l=<span class="cstat-no" title="statement not covered" >Math.floor(o/Math.pow(10,r)),</span>h=<span class="cstat-no" title="statement not covered" >r&lt;0?Math.pow(10,Math.abs(r)):1;<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >n.push({value:o,major:na(o)}),++l,10===l&amp;&amp;(l=1,++r,h=r&gt;=0?1:h),o=Math.round(l*Math.pow(10,r)*h)/h}</span>while(r&lt;i||r===i&amp;&amp;l&lt;s);c</span>onst c=<span class="cstat-no" title="statement not covered" >a(t.max,o);<span class="cstat-no" title="statement not covered" ></span>return n.push({value:c,major:na(o)}),n}</span>({min:this._userMin,max:this._userMax},this);<span class="cstat-no" title="statement not covered" ></span>return"ticks"===t.bounds&amp;&amp;j(e,this,"value"),t.reverse?(e.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),e}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return void 0===t?"0":li(t,this.chart.options.locale,this.options.ticks.format)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.min;<span class="cstat-no" title="statement not covered" ></span>super.configure(),this._startValue=I(t),this._valueRange=I(this.max)-I(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return void 0!==t&amp;&amp;0!==t||(t=this.min),null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(I(t)-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){const e=<span class="cstat-no" title="statement not covered" >this.getDecimalForPixel(t);<span class="cstat-no" title="statement not covered" ></span>return Math.pow(10,this._startValue+e*this._valueRange)}</span>}function <span class="fstat-no" title="function not covered" >aa(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.ticks;<span class="cstat-no" title="statement not covered" ></span>if(e.display&amp;&amp;t.display){const t=<span class="cstat-no" title="statement not covered" >pi(e.backdropPadding);<span class="cstat-no" title="statement not covered" ></span>return r(e.font&amp;&amp;e.font.size,ne.font.size)+t.height}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0}</span>function <span class="fstat-no" title="function not covered" >ra(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >return t===s||t===n?{start:e-i/2,end:e+i/2}:t&lt;s||t&gt;n?{start:e-i,end:e}:{start:e,end:e+i}}</span>function <span class="fstat-no" title="function not covered" >la(</span>t){const e=<span class="cstat-no" title="statement not covered" >{l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom},</span>i=<span class="cstat-no" title="statement not covered" >Object.assign({},e),</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >t._pointLabels.length,</span>r=<span class="cstat-no" title="statement not covered" >t.options.pointLabels,</span>l=<span class="cstat-no" title="statement not covered" >r.centerPointLabels?D/a:0;<span class="cstat-no" title="statement not covered" ></span>for(let u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;a;u++){const a=<span class="cstat-no" title="statement not covered" >r.setContext(t.getPointLabelContext(u));<span class="cstat-no" title="statement not covered" ></span>o[u]=a.padding;c</span>onst f=<span class="cstat-no" title="statement not covered" >t.getPointPosition(u,t.drawingArea+o[u],l),</span>g=<span class="cstat-no" title="statement not covered" >mi(a.font),</span>p=(<span class="cstat-no" title="statement not covered" >h=t.ctx,c=g,d=s(d=t._pointLabels[u])?d:[d],{w:ye(h,c.string,d),h:d.length*c.lineHeight})</span>;<span class="cstat-no" title="statement not covered" >n[u]=p;c</span>onst m=<span class="cstat-no" title="statement not covered" >K(t.getIndexAngle(u)+l),</span>b=<span class="cstat-no" title="statement not covered" >Math.round($(m));<span class="cstat-no" title="statement not covered" ></span>ha(i,e,m,ra(b,f.x,p.w,0,180),ra(b,f.y,p.h,90,270))}</span>v</span>ar h,c,d;<span class="cstat-no" title="statement not covered" >t.setCenterPoint(e.l-i.l,i.r-e.r,e.t-i.t,i.b-e.b),t._pointLabelItems=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >t._pointLabels.length,</span>o=<span class="cstat-no" title="statement not covered" >t.options,</span>a=<span class="cstat-no" title="statement not covered" >aa(o)/2,</span>r=<span class="cstat-no" title="statement not covered" >t.drawingArea,</span>l=<span class="cstat-no" title="statement not covered" >o.pointLabels.centerPointLabels?D/n:0;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n;o++){const n=<span class="cstat-no" title="statement not covered" >t.getPointPosition(o,r+a+i[o],l),</span>h=<span class="cstat-no" title="statement not covered" >Math.round($(K(n.angle+L))),</span>c=<span class="cstat-no" title="statement not covered" >e[o],</span>d=<span class="cstat-no" title="statement not covered" >ua(n.y,c.h,h),</span>u=<span class="cstat-no" title="statement not covered" >ca(h),</span>f=<span class="cstat-no" title="statement not covered" >da(n.x,c.w,u);<span class="cstat-no" title="statement not covered" ></span>s.push({x:n.x,y:d,textAlign:u,left:f,top:d,right:f+c.w,bottom:d+c.h})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>(t,n,o)}</span>function <span class="fstat-no" title="function not covered" >ha(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >Math.abs(Math.sin(i)),</span>a=<span class="cstat-no" title="statement not covered" >Math.abs(Math.cos(i));</span>let r=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>s.start&lt;e.l?(r=(e.l-s.start)/o,t.l=Math.min(t.l,e.l-r)):s.end&gt;e.r&amp;&amp;(r=(s.end-e.r)/o,t.r=Math.max(t.r,e.r+r)),n.start&lt;e.t?(l=(e.t-n.start)/a,t.t=Math.min(t.t,e.t-l)):n.end&gt;e.b&amp;&amp;(l=(n.end-e.b)/a,t.b=Math.max(t.b,e.b+l))}</span>function <span class="fstat-no" title="function not covered" >ca(</span>t){<span class="cstat-no" title="statement not covered" >return 0===t||180===t?"center":t&lt;180?"left":"right"}</span>function <span class="fstat-no" title="function not covered" >da(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return"right"===i?t-=e:"center"===i&amp;&amp;(t-=e/2),t}</span>function <span class="fstat-no" title="function not covered" >ua(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return 90===i||270===i?t-=e/2:(i&gt;270||i&lt;90)&amp;&amp;(t-=e),t}</span>function <span class="fstat-no" title="function not covered" >fa(</span>t,e,i,s){const{ctx:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >n.arc(t.xCenter,t.yCenter,e,0,O);e</span>lse{let i=<span class="cstat-no" title="statement not covered" >t.getPointPosition(0,e);<span class="cstat-no" title="statement not covered" ></span>n.moveTo(i.x,i.y);<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >1;</span>o&lt;s;o++)<span class="cstat-no" title="statement not covered" >i=t.getPointPosition(o,e),n.lineTo(i.x,i.y)}</span></span>}<span class="cstat-no" title="statement not covered" ></span>oa.id="logarithmic",oa.defaults={ticks:{callback:Is.formatters.logarithmic,major:{enabled:!0}}};c</span>lass ga extends ia{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){const t=<span class="cstat-no" title="statement not covered" >this._padding=pi(aa(this.options)/2),</span>e=<span class="cstat-no" title="statement not covered" >this.width=this.maxWidth-t.width,</span>i=<span class="cstat-no" title="statement not covered" >this.height=this.maxHeight-t.height;<span class="cstat-no" title="statement not covered" ></span>this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+i/2+t.top),this.drawingArea=Math.floor(Math.min(e,i)/2)}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!1);<span class="cstat-no" title="statement not covered" ></span>this.min=o(t)&amp;&amp;!isNaN(t)?t:0,this.max=o(e)&amp;&amp;!isNaN(e)?e:0,this.handleTickRangeOptions()}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){<span class="cstat-no" title="statement not covered" >return Math.ceil(this.drawingArea/aa(this.options))}<span class="fstat-no" title="function not covered" ></span>ge</span>nerateTickLabels(t){<span class="cstat-no" title="statement not covered" >ia.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const i=<span class="cstat-no" title="statement not covered" >c(this.options.pointLabels.callback,[t,e],this);<span class="cstat-no" title="statement not covered" ></span>return i||0===i?i:""}</span>)).filter((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >this.chart.getDataVisibility(e))</span>)}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const t=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>t.display&amp;&amp;t.pointLabels.display?la(this):this.setCenterPoint(0,0,0,0)}<span class="fstat-no" title="function not covered" ></span>se</span>tCenterPoint(t,e,i,s){<span class="cstat-no" title="statement not covered" >this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((i-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,i,s))}<span class="fstat-no" title="function not covered" ></span>ge</span>tIndexAngle(t){<span class="cstat-no" title="statement not covered" >return K(t*(O/(this._pointLabels.length||1))+H(this.options.startAngle||0))}<span class="fstat-no" title="function not covered" ></span>ge</span>tDistanceFromCenterForValue(t){<span class="cstat-no" title="statement not covered" >if(i(t))<span class="cstat-no" title="statement not covered" >return NaN;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.drawingArea/(this.max-this.min);<span class="cstat-no" title="statement not covered" ></span>return this.options.reverse?(this.max-t)*e:(t-this.min)*e}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForDistanceFromCenter(t){<span class="cstat-no" title="statement not covered" >if(i(t))<span class="cstat-no" title="statement not covered" >return NaN;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t/(this.drawingArea/(this.max-this.min));<span class="cstat-no" title="statement not covered" ></span>return this.options.reverse?this.max-e:this.min+e}<span class="fstat-no" title="function not covered" ></span>ge</span>tPointLabelContext(t){const e=<span class="cstat-no" title="statement not covered" >this._pointLabels||[];<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=0&amp;&amp;t&lt;e.length){const i=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return _i(t,{label:i,index:e,type:"pointLabel"})}</span>(this.getContext(),t,i)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tPointPosition(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{const s=<span class="cstat-no" title="statement not covered" >this.getIndexAngle(t)-L+i;<span class="cstat-no" title="statement not covered" ></span>return{x:Math.cos(s)*e+this.xCenter,y:Math.sin(s)*e+this.yCenter,angle:s}}<span class="fstat-no" title="function not covered" ></span>ge</span>tPointPositionForValue(t,e){<span class="cstat-no" title="statement not covered" >return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePosition(t){<span class="cstat-no" title="statement not covered" >return this.getPointPositionForValue(t||0,this.getBaseValue())}<span class="fstat-no" title="function not covered" ></span>ge</span>tPointLabelPosition(t){const{left:e,top:i,right:s,bottom:n}=<span class="cstat-no" title="statement not covered" >this._pointLabelItems[t];<span class="cstat-no" title="statement not covered" ></span>return{left:e,top:i,right:s,bottom:n}}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(){const{backgroundColor:t,grid:{circular:e}}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(t){const i=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>i.save(),i.beginPath(),fa(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),i.closePath(),i.fillStyle=t,i.fill(),i.restore()}</span>}<span class="fstat-no" title="function not covered" ></span>dr</span>awGrid(){const t=<span class="cstat-no" title="statement not covered" >this.ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.options,</span>{angleLines:s,grid:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >this._pointLabels.length;</span>let a,r,l;<span class="cstat-no" title="statement not covered" >if(e.pointLabels.display&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{ctx:s,options:{pointLabels:n}}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >e-1;</span>o&gt;=0;o--){const e=<span class="cstat-no" title="statement not covered" >n.setContext(t.getPointLabelContext(o)),</span>a=<span class="cstat-no" title="statement not covered" >mi(e.font),</span>{x:r,y:l,textAlign:h,left:c,top:d,right:u,bottom:f}=<span class="cstat-no" title="statement not covered" >t._pointLabelItems[o],</span>{backdropColor:g}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(!i(g)){const t=<span class="cstat-no" title="statement not covered" >gi(e.borderRadius),</span>i=<span class="cstat-no" title="statement not covered" >pi(e.backdropPadding);<span class="cstat-no" title="statement not covered" ></span>s.fillStyle=g;c</span>onst n=<span class="cstat-no" title="statement not covered" >c-i.left,</span>o=<span class="cstat-no" title="statement not covered" >d-i.top,</span>a=<span class="cstat-no" title="statement not covered" >u-c+i.width,</span>r=<span class="cstat-no" title="statement not covered" >f-d+i.height;<span class="cstat-no" title="statement not covered" ></span>Object.values(t).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?(s.beginPath(),Le(s,{x:n,y:o,w:a,h:r,radius:t}),s.fill()):s.fillRect(n,o,a,r)}<span class="cstat-no" title="statement not covered" ></span>A</span>e(s,t._pointLabels[o],r,l+a.lineHeight/2,a,{color:e.color,textAlign:h,textBaseline:"middle"})}</span>}</span>(this,o),n.display&amp;&amp;this.ticks.forEach((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(0!==e){<span class="cstat-no" title="statement not covered" >r=this.getDistanceFromCenterForValue(t.value);<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" ></span>fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.ctx,</span>o=<span class="cstat-no" title="statement not covered" >e.circular,</span>{color:a,lineWidth:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>!o&amp;&amp;!s||!a||!r||i&lt;0||(n.save(),n.strokeStyle=a,n.lineWidth=r,n.setLineDash(e.borderDash),n.lineDashOffset=e.borderDashOffset,n.beginPath(),fa(t,i,o,s),n.closePath(),n.stroke(),n.restore())}</span>(this,n.setContext(this.getContext(e-1)),r,o)}</span>}</span>)),s.display){<span class="cstat-no" title="statement not covered" >for(t.save(),a=o-1;a&gt;=0;a--){const i=<span class="cstat-no" title="statement not covered" >s.setContext(this.getPointLabelContext(a)),</span>{color:n,lineWidth:o}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;n&amp;&amp;(t.lineWidth=o,t.strokeStyle=n,t.setLineDash(i.borderDash),t.lineDashOffset=i.borderDashOffset,r=this.getDistanceFromCenterForValue(e.ticks.reverse?this.min:this.max),l=this.getPointPosition(a,r),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}<span class="cstat-no" title="statement not covered" ></span>t</span>.restore()}</span>}<span class="fstat-no" title="function not covered" ></span>dr</span>awBorder(){}<span class="fstat-no" title="function not covered" >dr</span>awLabels(){const t=<span class="cstat-no" title="statement not covered" >this.ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.options,</span>i=<span class="cstat-no" title="statement not covered" >e.ticks;<span class="cstat-no" title="statement not covered" ></span>if(!i.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.getIndexAngle(0);</span>let n,o;<span class="cstat-no" title="statement not covered" >t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(s),t.textAlign="center",t.textBaseline="middle",this.ticks.forEach((<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;{<span class="cstat-no" title="statement not covered" >if(0===a&amp;&amp;!e.reverse)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >i.setContext(this.getContext(a)),</span>l=<span class="cstat-no" title="statement not covered" >mi(r.font);<span class="cstat-no" title="statement not covered" ></span>if(n=this.getDistanceFromCenterForValue(this.ticks[a].value),r.showLabelBackdrop){<span class="cstat-no" title="statement not covered" >t.font=l.string,o=t.measureText(s.label).width,t.fillStyle=r.backdropColor;c</span>onst e=<span class="cstat-no" title="statement not covered" >pi(r.backdropPadding);<span class="cstat-no" title="statement not covered" ></span>t.fillRect(-o/2-e.left,-n-l.size/2-e.top,o+e.width,l.size+e.height)}<span class="cstat-no" title="statement not covered" ></span>A</span>e(t,s.label,0,-n,l,{color:r.color})}</span>)),t.restore()}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){}}<span class="cstat-no" title="statement not covered" >ga.id="radialLinear",ga.defaults={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:Is.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>padding:5,centerPointLabels:!1}},ga.defaultRoutes={"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"},ga.descriptors={angleLines:{_fallback:"grid"}};c</span>onst pa=<span class="cstat-no" title="statement not covered" >{millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},</span>ma=<span class="cstat-no" title="statement not covered" >Object.keys(pa);</span>function <span class="fstat-no" title="function not covered" >ba(</span>t,e){<span class="cstat-no" title="statement not covered" >return t-e}</span>function <span class="fstat-no" title="function not covered" >xa(</span>t,e){<span class="cstat-no" title="statement not covered" >if(i(e))<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t._adapter,</span>{parser:n,round:a,isoWeekday:r}=<span class="cstat-no" title="statement not covered" >t._parseOpts;</span>let l=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof n&amp;&amp;(l=n(l)),o(l)||(l="string"==typeof n?s.parse(l,n):s.parse(l)),null===l?null:(a&amp;&amp;(l="week"!==a||!B(r)&amp;&amp;!0!==r?s.startOf(l,a):s.startOf(l,"isoWeek",r)),+l)}</span>function <span class="fstat-no" title="function not covered" >_a(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ma.length;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >ma.indexOf(t);</span>o&lt;n-1;++o){const t=<span class="cstat-no" title="statement not covered" >pa[ma[o]],</span>n=<span class="cstat-no" title="statement not covered" >t.steps?t.steps:Number.MAX_SAFE_INTEGER;<span class="cstat-no" title="statement not covered" ></span>if(t.common&amp;&amp;Math.ceil((i-e)/(n*t.size))&lt;=s)<span class="cstat-no" title="statement not covered" >return ma[o]}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn ma[n-1]}</span>function <span class="fstat-no" title="function not covered" >ya(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >if(i.length){const{lo:s,hi:n}=<span class="cstat-no" title="statement not covered" >tt(i,e);<span class="cstat-no" title="statement not covered" ></span>t[i[s]&gt;=e?i[s]:i[n]]=!0}</span>}</span>else <span class="cstat-no" title="statement not covered" >t[e]=!0}</span></span>function <span class="fstat-no" title="function not covered" >va(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >{},</span>o=<span class="cstat-no" title="statement not covered" >e.length;</span>let a,r;<span class="cstat-no" title="statement not covered" >for(a=0;a&lt;o;++a)<span class="cstat-no" title="statement not covered" >r=e[a],n[r]=a,s.push({value:r,major:!1});<span class="cstat-no" title="statement not covered" >r</span></span>eturn 0!==o&amp;&amp;i?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t._adapter,</span>o=<span class="cstat-no" title="statement not covered" >+n.startOf(e[0].value,s),</span>a=<span class="cstat-no" title="statement not covered" >e[e.length-1].value;</span>let r,l;<span class="cstat-no" title="statement not covered" >for(r=o;r&lt;=a;r=+n.add(r,1,s))<span class="cstat-no" title="statement not covered" >l=i[r],l&gt;=0&amp;&amp;(e[l].major=!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(t,s,n,i):s}</span>class wa extends $s{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>it(t,e){const i=<span class="cstat-no" title="statement not covered" >t.time||(t.time={}),</span>s=<span class="cstat-no" title="statement not covered" >this._adapter=new wn._date(t.adapters.date);<span class="cstat-no" title="statement not covered" ></span>s.init(e),b(i.displayFormats,s.formats()),this._parseOpts={parser:i.parser,round:i.round,isoWeekday:i.isoWeekday},super.init(t),this._normalized=e.normalized}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return void 0===t?null:xa(this,t)}<span class="fstat-no" title="function not covered" ></span>be</span>foreLayout(){<span class="cstat-no" title="statement not covered" >super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >this._adapter,</span>i=<span class="cstat-no" title="statement not covered" >t.time.unit||"day";</span>let{min:s,max:n,minDefined:a,maxDefined:r}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>function <span class="fstat-no" title="function not covered" >l(</span>t){<span class="cstat-no" title="statement not covered" >a||isNaN(t.min)||(s=Math.min(s,t.min)),r||isNaN(t.max)||(n=Math.max(n,t.max))}<span class="cstat-no" title="statement not covered" ></span>a&amp;&amp;r||(l(this._getLabelBounds()),"ticks"===t.bounds&amp;&amp;"labels"===t.ticks.source||l(this.getMinMax(!1))),s=o(s)&amp;&amp;!isNaN(s)?s:+e.startOf(Date.now(),i),n=o(n)&amp;&amp;!isNaN(n)?n:+e.endOf(Date.now(),i)+1,this.min=Math.min(s,n-1),this.max=Math.max(s+1,n)}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelBounds(){const t=<span class="cstat-no" title="statement not covered" >this.getLabelTimestamps();</span>let e=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY,</span>i=<span class="cstat-no" title="statement not covered" >Number.NEGATIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>return t.length&amp;&amp;(e=t[0],i=t[t.length-1]),{min:e,max:i}}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.time,</span>i=<span class="cstat-no" title="statement not covered" >t.ticks,</span>s=<span class="cstat-no" title="statement not covered" >"labels"===i.source?this.getLabelTimestamps():this._generate();<span class="cstat-no" title="statement not covered" ></span>"ticks"===t.bounds&amp;&amp;s.length&amp;&amp;(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);c</span>onst n=<span class="cstat-no" title="statement not covered" >this.min,</span>o=<span class="cstat-no" title="statement not covered" >st(s,n,this.max);<span class="cstat-no" title="statement not covered" ></span>return this._unit=e.unit||(i.autoSkip?_a(e.minUnit,this.min,this.max,this._getLabelCapacity(n)):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){<span class="cstat-no" title="statement not covered" >for(let o=<span class="cstat-no" title="statement not covered" >ma.length-1;</span>o&gt;=ma.indexOf(i);o--){const i=<span class="cstat-no" title="statement not covered" >ma[o];<span class="cstat-no" title="statement not covered" ></span>if(pa[i].common&amp;&amp;t._adapter.diff(n,s,i)&gt;=e-1)<span class="cstat-no" title="statement not covered" >return i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn ma[i?ma.indexOf(i):0]}</span>(this,o.length,e.minUnit,this.min,this.max)),this._majorUnit=i.major.enabled&amp;&amp;"year"!==this._unit?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >ma.indexOf(t)+1,</span>i=<span class="cstat-no" title="statement not covered" >ma.length;</span>e&lt;i;++e)<span class="cstat-no" title="statement not covered" >if(pa[ma[e]].common)<span class="cstat-no" title="statement not covered" >return ma[e]}</span></span></span>(this._unit):void 0,this.initOffsets(s),t.reverse&amp;&amp;o.reverse(),va(this,o,this._majorUnit)}<span class="fstat-no" title="function not covered" ></span>af</span>terAutoSkip(){<span class="cstat-no" title="statement not covered" >this.options.offsetAfterAutoskip&amp;&amp;this.initOffsets(this.ticks.map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >+t.value)</span>))}<span class="fstat-no" title="function not covered" ></span>in</span>itOffsets(t){let e,i,s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this.options.offset&amp;&amp;t.length&amp;&amp;(e=this.getDecimalForValue(t[0]),s=1===t.length?1-e:(this.getDecimalForValue(t[1])-e)/2,i=this.getDecimalForValue(t[t.length-1]),n=1===t.length?i:(i-this.getDecimalForValue(t[t.length-2]))/2);c</span>onst o=<span class="cstat-no" title="statement not covered" >t.length&lt;3?.5:.25;<span class="cstat-no" title="statement not covered" ></span>s=Z(s,0,o),n=Z(n,0,o),this._offsets={start:s,end:n,factor:1/(s+1+n)}}<span class="fstat-no" title="function not covered" ></span>_g</span>enerate(){const t=<span class="cstat-no" title="statement not covered" >this._adapter,</span>e=<span class="cstat-no" title="statement not covered" >this.min,</span>i=<span class="cstat-no" title="statement not covered" >this.max,</span>s=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >s.time,</span>o=<span class="cstat-no" title="statement not covered" >n.unit||_a(n.minUnit,e,i,this._getLabelCapacity(e)),</span>a=<span class="cstat-no" title="statement not covered" >r(n.stepSize,1),</span>l=<span class="cstat-no" title="statement not covered" >"week"===o&amp;&amp;n.isoWeekday,</span>h=<span class="cstat-no" title="statement not covered" >B(l)||!0===l,</span>c=<span class="cstat-no" title="statement not covered" >{};</span>let d,u,f=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(h&amp;&amp;(f=+t.startOf(f,"isoWeek",l)),f=+t.startOf(f,h?"day":o),t.diff(i,e,o)&gt;1e5*a)<span class="cstat-no" title="statement not covered" >throw new Error(e+" and "+i+" are too far apart with stepSize of "+a+" "+o);c</span></span>onst g=<span class="cstat-no" title="statement not covered" >"data"===s.ticks.source&amp;&amp;this.getDataTimestamps();<span class="cstat-no" title="statement not covered" ></span>for(d=f,u=0;d&lt;i;d=+t.add(d,a,o),u++)<span class="cstat-no" title="statement not covered" >ya(c,d,g);<span class="cstat-no" title="statement not covered" >r</span></span>eturn d!==i&amp;&amp;"ticks"!==s.bounds&amp;&amp;1!==u||ya(c,d,g),Object.keys(c).sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e)</span>).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >+t)</span>)}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){const e=<span class="cstat-no" title="statement not covered" >this._adapter,</span>i=<span class="cstat-no" title="statement not covered" >this.options.time;<span class="cstat-no" title="statement not covered" ></span>return i.tooltipFormat?e.format(t,i.tooltipFormat):e.format(t,i.displayFormats.datetime)}<span class="fstat-no" title="function not covered" ></span>_t</span>ickFormatFunction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >n.time.displayFormats,</span>a=<span class="cstat-no" title="statement not covered" >this._unit,</span>r=<span class="cstat-no" title="statement not covered" >this._majorUnit,</span>l=<span class="cstat-no" title="statement not covered" >a&amp;&amp;o[a],</span>h=<span class="cstat-no" title="statement not covered" >r&amp;&amp;o[r],</span>d=<span class="cstat-no" title="statement not covered" >i[e],</span>u=<span class="cstat-no" title="statement not covered" >r&amp;&amp;h&amp;&amp;d&amp;&amp;d.major,</span>f=<span class="cstat-no" title="statement not covered" >this._adapter.format(t,s||(u?h:l)),</span>g=<span class="cstat-no" title="statement not covered" >n.ticks.callback;<span class="cstat-no" title="statement not covered" ></span>return g?c(g,[f,e,i],this):f}<span class="fstat-no" title="function not covered" ></span>ge</span>nerateTickLabels(t){let e,i,s;<span class="cstat-no" title="statement not covered" >for(e=0,i=t.length;e&lt;i;++e)<span class="cstat-no" title="statement not covered" >s=t[e],s.label=this._tickFormatFunction(s.value,e,t)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tDecimalForValue(t){<span class="cstat-no" title="statement not covered" >return null===t?NaN:(t-this.min)/(this.max-this.min)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){const e=<span class="cstat-no" title="statement not covered" >this._offsets,</span>i=<span class="cstat-no" title="statement not covered" >this.getDecimalForValue(t);<span class="cstat-no" title="statement not covered" ></span>return this.getPixelForDecimal((e.start+i)*e.factor)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){const e=<span class="cstat-no" title="statement not covered" >this._offsets,</span>i=<span class="cstat-no" title="statement not covered" >this.getDecimalForPixel(t)/e.factor-e.end;<span class="cstat-no" title="statement not covered" ></span>return this.min+i*(this.max-this.min)}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelSize(t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks,</span>i=<span class="cstat-no" title="statement not covered" >this.ctx.measureText(t).width,</span>s=<span class="cstat-no" title="statement not covered" >H(this.isHorizontal()?e.maxRotation:e.minRotation),</span>n=<span class="cstat-no" title="statement not covered" >Math.cos(s),</span>o=<span class="cstat-no" title="statement not covered" >Math.sin(s),</span>a=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0).size;<span class="cstat-no" title="statement not covered" ></span>return{w:i*n+a*o,h:i*o+a*n}}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelCapacity(t){const e=<span class="cstat-no" title="statement not covered" >this.options.time,</span>i=<span class="cstat-no" title="statement not covered" >e.displayFormats,</span>s=<span class="cstat-no" title="statement not covered" >i[e.unit]||i.millisecond,</span>n=<span class="cstat-no" title="statement not covered" >this._tickFormatFunction(t,0,va(this,[t],this._majorUnit),s),</span>o=<span class="cstat-no" title="statement not covered" >this._getLabelSize(n),</span>a=<span class="cstat-no" title="statement not covered" >Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;<span class="cstat-no" title="statement not covered" ></span>return a&gt;0?a:1}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataTimestamps(){let t,e,i=<span class="cstat-no" title="statement not covered" >this._cache.data||[];<span class="cstat-no" title="statement not covered" ></span>if(i.length)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.getMatchingVisibleMetas();<span class="cstat-no" title="statement not covered" ></span>if(this._normalized&amp;&amp;s.length)<span class="cstat-no" title="statement not covered" >return this._cache.data=s[0].controller.getAllParsedValues(this);<span class="cstat-no" title="statement not covered" >f</span></span>or(t=0,e=s.length;t&lt;e;++t)<span class="cstat-no" title="statement not covered" >i=i.concat(s[t].controller.getAllParsedValues(this));<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._cache.data=this.normalize(i)}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelTimestamps(){const t=<span class="cstat-no" title="statement not covered" >this._cache.labels||[];</span>let e,i;<span class="cstat-no" title="statement not covered" >if(t.length)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>for(e=0,i=s.length;e&lt;i;++e)<span class="cstat-no" title="statement not covered" >t.push(xa(this,s[e]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._cache.labels=this._normalized?t:this.normalize(t)}<span class="fstat-no" title="function not covered" ></span>no</span>rmalize(t){<span class="cstat-no" title="statement not covered" >return rt(t.sort(ba))}</span>}function <span class="fstat-no" title="function not covered" >Ma(</span>t,e,i){let s,n,o,a,r=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >t.length-1;<span class="cstat-no" title="statement not covered" ></span>i?(e&gt;=t[r].pos&amp;&amp;e&lt;=t[l].pos&amp;&amp;({lo:r,hi:l}=et(t,"pos",e)),({pos:s,time:o}=t[r]),({pos:n,time:a}=t[l])):(e&gt;=t[r].time&amp;&amp;e&lt;=t[l].time&amp;&amp;({lo:r,hi:l}=et(t,"time",e)),({time:s,pos:o}=t[r]),({time:n,pos:a}=t[l]));c</span>onst h=<span class="cstat-no" title="statement not covered" >n-s;<span class="cstat-no" title="statement not covered" ></span>return h?o+(a-o)*(e-s)/h:o}<span class="cstat-no" title="statement not covered" ></span>wa.id="time",wa.defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",major:{enabled:!1}}};c</span>lass ka extends wa{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>itOffsets(){const t=<span class="cstat-no" title="statement not covered" >this._getTimestampsForTable(),</span>e=<span class="cstat-no" title="statement not covered" >this._table=this.buildLookupTable(t);<span class="cstat-no" title="statement not covered" ></span>this._minPos=Ma(e,this.min),this._tableRange=Ma(e,this.max)-this._minPos,super.initOffsets(t)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildLookupTable(t){const{min:e,max:i}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[];</span>let o,a,r,l,h;<span class="cstat-no" title="statement not covered" >for(o=0,a=t.length;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >l=t[o],l&gt;=e&amp;&amp;l&lt;=i&amp;&amp;s.push(l);<span class="cstat-no" title="statement not covered" >i</span></span>f(s.length&lt;2)<span class="cstat-no" title="statement not covered" >return[{time:e,pos:0},{time:i,pos:1}];<span class="cstat-no" title="statement not covered" >f</span></span>or(o=0,a=s.length;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >h=s[o+1],r=s[o-1],l=s[o],Math.round((h+r)/2)!==l&amp;&amp;n.push({time:l,pos:o/(a-1)});<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>_g</span>etTimestampsForTable(){let t=<span class="cstat-no" title="statement not covered" >this._cache.all||[];<span class="cstat-no" title="statement not covered" ></span>if(t.length)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.getDataTimestamps(),</span>i=<span class="cstat-no" title="statement not covered" >this.getLabelTimestamps();<span class="cstat-no" title="statement not covered" ></span>return t=e.length&amp;&amp;i.length?this.normalize(e.concat(i)):e.length?e:i,t=this._cache.all=t,t}<span class="fstat-no" title="function not covered" ></span>ge</span>tDecimalForValue(t){<span class="cstat-no" title="statement not covered" >return(Ma(this._table,t)-this._minPos)/this._tableRange}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){const e=<span class="cstat-no" title="statement not covered" >this._offsets,</span>i=<span class="cstat-no" title="statement not covered" >this.getDecimalForPixel(t)/e.factor-e.end;<span class="cstat-no" title="statement not covered" ></span>return Ma(this._table,i*this._tableRange+this._minPos,!0)}</span>}<span class="cstat-no" title="statement not covered" >ka.id="timeseries",ka.defaults=wa.defaults;v</span>ar Sa=<span class="cstat-no" title="statement not covered" >Object.freeze({__proto__:null,CategoryScale:ta,LinearScale:sa,LogarithmicScale:oa,RadialLinearScale:ga,TimeScale:wa,TimeSeriesScale:ka});<span class="cstat-no" title="statement not covered" ></span>return bn.register(Bn,Sa,co,Jo),bn.helpers={...Ti},bn._adapters=wn,bn.Animation=xs,bn.Animations=ys,bn.animator=mt,bn.controllers=Us.controllers.items,bn.DatasetController=Ls,bn.Element=Es,bn.elements=co,bn.Interaction=Vi,bn.layouts=Zi,bn.platforms=ps,bn.Scale=$s,bn.Ticks=Is,Object.assign(bn,Bn,Sa,co,Jo,ps),bn.Chart=bn,"undefined"!=typeof window&amp;&amp;(window.Chart=bn),bn}</span>));
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-01-20T09:55:08.196Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    